===========================================================
INSTALLING SYM+ 99 DB OBJECTS
===========================================================


creating 99 sequences
___________________________________________________________


Error starting at line : 1 File @ C:\Neulogic\private\WF\sequences\wf_seq_00_key.sql
In command -
CREATE SEQUENCE wf_seq_00_key
  START WITH 1
  INCREMENT BY 1
  MAXVALUE 9999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\sequences\wf_seq_00_key.sql
Error report -
SQL Error: Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\sequences\wf_seq_20_act.sql
In command -
CREATE SEQUENCE wf_seq_20_act
  START WITH 1
  INCREMENT BY 1
  MAXVALUE 9999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\sequences\wf_seq_20_act.sql
Error report -
SQL Error: Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\sequences\wf_seq_20_doc.sql
In command -
CREATE SEQUENCE wf_seq_20_doc
  START WITH 1
  INCREMENT BY 1
  MAXVALUE 9999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\sequences\wf_seq_20_doc.sql
Error report -
SQL Error: Closed Connection


creating 99 tables
___________________________________________________________


Error starting at line : 19 File @ C:\Neulogic\private\99\install.sql
In command -
@./scripts/install/create_99_tables.sql
Error report -
Unable to open file: "./scripts/install/create_99_tables.sql"


creating 99 views
___________________________________________________________

Creating 99 work views....

Error starting at line : 26 File @ C:\Neulogic\private\99\install.sql
In command -
@./views/99/install.sql
Error report -
Unable to open file: "./views/99/install.sql"
Creating 99 DM views....

Error starting at line : 28 File @ C:\Neulogic\private\99\install.sql
In command -
@./views/DM/install.sql
Error report -
Unable to open file: "./views/DM/install.sql"
Creating 99 LV views....

Error starting at line : 30 File @ C:\Neulogic\private\99\install.sql
In command -
@./views/LV/install.sql
Error report -
Unable to open file: "./views/LV/install.sql"
Creating 99 00 views....

Error starting at line : 32 File @ C:\Neulogic\private\99\install.sql
In command -
@./views/00/install.sql
Error report -
Unable to open file: "./views/00/install.sql"
Creating 99 10 views....

Error starting at line : 34 File @ C:\Neulogic\private\99\install.sql
In command -
@./views/10/install.sql
Error report -
Unable to open file: "./views/10/install.sql"
Creating 99 VT views....

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vt\wf_vt_00_eml.sql
In command -
CREATE OR REPLACE FORCE   VIEW wf_vt_00_eml
AS 
SELECT r_k,
       smtp_hst,
       smtp_prt,
       smtp_auth_yn,
       frm_eml,
       auth_act,
       auth_pwd,
       max_rtry_no,
       tls_yn,
       wlt_pth,
       wlt_pwd,
       ehlo_yn
FROM   wf_00_eml
WHERE  r_k = 1
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vt\wf_vt_00_eml.sql
Error report -
SQL Error: Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vt\wf_vt_10_mb.sql
In command -
CREATE OR REPLACE VIEW wf_vt_10_mb
AS
SELECT A.n38  row_key,
       A.c30  mb_id,
       A.c100 mb_dsc,
       A.n38  u_k,
       A.c1   iu_yn
  FROM wf_00_00_dtd A
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vt\wf_vt_10_mb.sql
Error report -
SQL Error: Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vt\wf_vt_10_rl.sql
In command -
CREATE OR REPLACE VIEW wf_vt_10_rl
AS
SELECT A.n38  row_key,
       A.c30  rl_id,
       A.c100 rl_dsc,
       A.c1   iu_yn
  FROM wf_00_00_dtd A
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vt\wf_vt_10_rl.sql
Error report -
SQL Error: Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vt\wf_vt_10_rl_mb.sql
In command -
CREATE OR REPLACE VIEW wf_vt_10_rl_mb
AS
SELECT A.n38 row_key,
       A.n38 rl_k,
       A.n38 mb_k,
       A.c1  iu_yn
  FROM wf_00_00_dtd A
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vt\wf_vt_10_rl_mb.sql
Error report -
SQL Error: Closed Connection
Creating 99 VL views....

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_10_mb.sql
In command -
CREATE OR REPLACE VIEW wf_vl_10_mb
AS
SELECT A.row_key,
       A.mb_id,
       A.mb_dsc,
       A.u_k,
       B.usr_name u_dsc,
       A.iu_yn,
       pkwf_00_00_dmv.fn_00_yes_no_dsc(A.iu_yn) iu_dsc
  FROM wf_10_mb A, wf_v_99_usr_l B
 WHERE A.u_k = B.usr_ky (+)
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_10_mb.sql
Error report -
SQL Error: Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_10_rl.sql
In command -
CREATE OR REPLACE VIEW wf_vl_10_rl
AS
SELECT row_key,
       rl_id,
       rl_dsc,
       iu_yn,
       pkwf_00_00_dmv.fn_00_yes_no_dsc(iu_yn) iu_dsc
  FROM wf_10_rl
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_10_rl.sql
Error report -
SQL Error: Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_10_rl_mb.sql
In command -
CREATE OR REPLACE VIEW wf_vl_10_rl_mb
AS
SELECT A.row_key,
       A.rl_k,
       B.rl_id,
       B.rl_dsc,
       A.mb_k,
       C.mb_id,
       C.mb_dsc,
       A.iu_yn,
       pkwf_00_00_dmv.fn_00_yes_no_dsc(A.iu_yn) iu_dsc
  FROM wf_10_rl_mb A, wf_10_rl B, wf_10_mb C
 WHERE A.rl_k = B.row_key
   AND A.mb_k = C.row_key
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_10_rl_mb.sql
Error report -
SQL Error: Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_10_tp_tk.sql
In command -
CREATE OR REPLACE VIEW wf_vl_10_tp_tk
AS
  SELECT a.row_key tp_k, a.tp_id, a.tp_dsc,
         b.row_key tk_k, b.tk_id, b.tk_dsc,
         c.row_key rl_k, c.rl_id, c.rl_dsc
  FROM   wf_10_tp a,
         wf_10_tp_tk b,
         wf_10_rl c
  WHERE  a.row_key = b.tp_k
  AND    b.ac_rl_k = c.row_key(+)
  ORDER BY a.tp_dsc, b.seq_no
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_10_tp_tk.sql
Error report -
SQL Error: Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_11_mb.sql
In command -
CREATE OR REPLACE VIEW wf_vl_11_mb
AS
SELECT a.mb_id, a.mb_dsc, a.u_k, a.iu_yn,
       DECODE(a.iu_yn,'1','Yes','No') iu_yn_dsc,
       b.eml_adr, NVL(b.trc_yn,0) as rmt_usr_yn,
       DECODE(b.trc_yn,1,'Symbols User','Workflow Only') rmt_usr_dsc,
       b.fl_05 as is_adm_yn,
       DECODE(b.fl_05,'1','Yes','No') as is_adm_yn_dsc,
       pkwf_11_mb.fn_get_usr_role(a.u_k) as usr_roles
FROM   wf_10_mb a,
       t_99_10_ssu b
WHERE  UPPER(a.mb_id) = UPPER(b.lgn_id)  
ORDER BY a.mb_id
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_11_mb.sql
Error report -
SQL Error: Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_11_mb_l.sql
In command -
CREATE OR REPLACE VIEW wf_vl_11_mb_l
AS
SELECT *
FROM   wf_vl_11_mb
WHERE  rmt_usr_yn ='0'
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_11_mb_l.sql
Error report -
SQL Error: Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_11_mb_r.sql
In command -
CREATE OR REPLACE VIEW wf_vl_11_mb_r
AS
SELECT *
FROM   wf_vl_11_mb
WHERE  rmt_usr_yn ='1'
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_11_mb_r.sql
Error report -
SQL Error: Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_20_cpr_doc.sql
In command -
CREATE OR REPLACE FORCE VIEW wf_vl_20_cpr_doc
AS
  SELECT dc.row_key dc_k, dc.dc_id, 
           dd.id doc_id, dd.dsc doc_dsc,
           im.im_blb doc_blb
      FROM wf_30_dc dc, wf_vd_cpr_doc dd, 
           wf_30_dc_im im
     WHERE dc.row_key = im.dc_k
       AND im.im_tp_dm = dd.id
    ORDER BY dd.dsc ASC
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_20_cpr_doc.sql
Error report -
SQL Error: Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_20_dc_ac.sql
In command -
CREATE OR REPLACE VIEW wf_vl_20_dc_ac
AS
SELECT a.row_key dc_k,
       a.dc_id,
       a.dc_dsc,
       a.st_dtt,
       b.tp_id,
       b.tp_dsc,
       c.ed_dtt,
       d.ac_dtt,
       d.ac_rmk,
       d.mb_k,
       e.mb_id,
       e.mb_dsc,
       f.tk_id,
       f.tk_dsc
FROM   wf_20_dc a,
       wf_10_tp b,
       wf_20_dc_tk c,
       wf_20_dc_ac d,
       wf_10_mb e,
       wf_10_tp_tk f
WHERE  a.dc_st_dm = 'R'
AND    d.ac_dm = '2'
AND    a.tp_k = b.row_key
AND    a.row_key = c.dc_k
AND    c.row_key = d.dc_tk_k
AND    d.mb_k = e.u_k
AND    c.tk_k = f.row_key
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_20_dc_ac.sql
Error report -
SQL Error: Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_20_dc_rej.sql
In command -
CREATE OR REPLACE VIEW wf_vl_20_dc_rej
AS
SELECT a.row_key dc_k,
       a.dc_id,
       a.dc_dsc,
       a.st_dtt,
       b.tp_id,
       b.tp_dsc,
       c.ed_dtt,
       d.ac_dtt,
       d.ac_rmk,
       d.mb_k,
       e.mb_id,
       e.mb_dsc,
       f.tk_id,
       f.tk_dsc
FROM   wf_20_dc a,
       wf_10_tp b,
       wf_20_dc_tk c,
       wf_20_dc_ac d,
       wf_10_mb e,
       wf_10_tp_tk f
WHERE  a.dc_st_dm = 'R'
AND    a.tp_k = b.row_key
AND    a.row_key = c.dc_k
AND    c.row_key = d.dc_tk_k
AND    d.mb_k = e.u_k
AND    c.tk_k = f.row_key
AND    d.ac_dm = '2'
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_20_dc_rej.sql
Error report -
SQL Error: Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_20_my_tk.sql
In command -
CREATE OR REPLACE FORCE VIEW wf_vl_20_my_tk
AS
  SELECT *
  FROM TABLE(pkwf_20_gen.fn_m_tk)
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_20_my_tk.sql
Error report -
SQL Error: Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_20_ot_tk.sql
In command -
CREATE OR REPLACE FORCE VIEW wf_vl_20_ot_tk
AS
  SELECT *
  FROM TABLE(pkwf_20_gen.fn_u_ot_tk)
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_20_ot_tk.sql
Error report -
SQL Error: Closed Connection
Creating 99 VP views....

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vp\wf_vp_30_cs_new_im.sql
In command -
CREATE OR REPLACE VIEW wf_vp_30_cs_new_im
AS
SELECT a.dc_k, b.pic_img, c.pic_sgn, d.pic_usr, e.pic_utl
FROM  (SELECT DISTINCT dc_k FROM wf_30_dc_im) a,
      (SELECT dc_k, im_blb as pic_img FROM wf_30_dc_im WHERE im_tp_dm = 'PIC_IMG') b,
      (SELECT dc_k, im_blb as pic_sgn FROM wf_30_dc_im WHERE im_tp_dm = 'PIC_SGN') c,
      (SELECT dc_k, im_blb as pic_usr FROM wf_30_dc_im WHERE im_tp_dm = 'PIC_USR') d,
      (SELECT dc_k, im_blb as pic_utl FROM wf_30_dc_im WHERE im_tp_dm = 'PIC_UTL') e
WHERE  a.dc_k = b.dc_k
AND    a.dc_k = c.dc_k
AND    a.dc_k = d.dc_k
AND    a.dc_k = e.dc_k
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vp\wf_vp_30_cs_new_im.sql
Error report -
SQL Error: Closed Connection
Creating 99 VQ views....

Error starting at line : 42 File @ C:\Neulogic\private\99\install.sql
In command -
@./views/vq/install.sql
Error report -
Unable to open file: "./views/vq/install.sql"
Creating 99 $$ views....

Error starting at line : 44 File @ C:\Neulogic\private\99\install.sql
In command -
@./views/v$$/install.sql
Error report -
Unable to open file: "./views/v$$/install.sql"


creating 99 package specs
___________________________________________________________


Error starting at line : 50 File @ C:\Neulogic\private\99\install.sql
In command -
@./package-specs/install.sql
Error report -
Unable to open file: "./package-specs/install.sql"


Recreating dependent 99 views
___________________________________________________________

Recreating 99 99 views....

Error starting at line : 57 File @ C:\Neulogic\private\99\install.sql
In command -
@./views/99/install.sql
Error report -
Unable to open file: "./views/99/install.sql"
Recreating 99 DM views....

Error starting at line : 59 File @ C:\Neulogic\private\99\install.sql
In command -
@./views/DM/install.sql
Error report -
Unable to open file: "./views/DM/install.sql"
Recreating 99 LV views....

Error starting at line : 61 File @ C:\Neulogic\private\99\install.sql
In command -
@./views/LV/install.sql
Error report -
Unable to open file: "./views/LV/install.sql"
Recreating 99 00 views....

Error starting at line : 63 File @ C:\Neulogic\private\99\install.sql
In command -
@./views/00/install.sql
Error report -
Unable to open file: "./views/00/install.sql"
Recreating 99 10 views....

Error starting at line : 65 File @ C:\Neulogic\private\99\install.sql
In command -
@./views/10/install.sql
Error report -
Unable to open file: "./views/10/install.sql"
Recreating 99 VT views....

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vt\wf_vt_00_eml.sql
In command -
CREATE OR REPLACE FORCE   VIEW wf_vt_00_eml
AS 
SELECT r_k,
       smtp_hst,
       smtp_prt,
       smtp_auth_yn,
       frm_eml,
       auth_act,
       auth_pwd,
       max_rtry_no,
       tls_yn,
       wlt_pth,
       wlt_pwd,
       ehlo_yn
FROM   wf_00_eml
WHERE  r_k = 1
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vt\wf_vt_00_eml.sql
Error report -
SQL Error: Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vt\wf_vt_10_mb.sql
In command -
CREATE OR REPLACE VIEW wf_vt_10_mb
AS
SELECT A.n38  row_key,
       A.c30  mb_id,
       A.c100 mb_dsc,
       A.n38  u_k,
       A.c1   iu_yn
  FROM wf_00_00_dtd A
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vt\wf_vt_10_mb.sql
Error report -
SQL Error: Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vt\wf_vt_10_rl.sql
In command -
CREATE OR REPLACE VIEW wf_vt_10_rl
AS
SELECT A.n38  row_key,
       A.c30  rl_id,
       A.c100 rl_dsc,
       A.c1   iu_yn
  FROM wf_00_00_dtd A
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vt\wf_vt_10_rl.sql
Error report -
SQL Error: Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vt\wf_vt_10_rl_mb.sql
In command -
CREATE OR REPLACE VIEW wf_vt_10_rl_mb
AS
SELECT A.n38 row_key,
       A.n38 rl_k,
       A.n38 mb_k,
       A.c1  iu_yn
  FROM wf_00_00_dtd A
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vt\wf_vt_10_rl_mb.sql
Error report -
SQL Error: Closed Connection
Recreating 99 VL views....

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_10_mb.sql
In command -
CREATE OR REPLACE VIEW wf_vl_10_mb
AS
SELECT A.row_key,
       A.mb_id,
       A.mb_dsc,
       A.u_k,
       B.usr_name u_dsc,
       A.iu_yn,
       pkwf_00_00_dmv.fn_00_yes_no_dsc(A.iu_yn) iu_dsc
  FROM wf_10_mb A, wf_v_99_usr_l B
 WHERE A.u_k = B.usr_ky (+)
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_10_mb.sql
Error report -
SQL Error: Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_10_rl.sql
In command -
CREATE OR REPLACE VIEW wf_vl_10_rl
AS
SELECT row_key,
       rl_id,
       rl_dsc,
       iu_yn,
       pkwf_00_00_dmv.fn_00_yes_no_dsc(iu_yn) iu_dsc
  FROM wf_10_rl
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_10_rl.sql
Error report -
SQL Error: Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_10_rl_mb.sql
In command -
CREATE OR REPLACE VIEW wf_vl_10_rl_mb
AS
SELECT A.row_key,
       A.rl_k,
       B.rl_id,
       B.rl_dsc,
       A.mb_k,
       C.mb_id,
       C.mb_dsc,
       A.iu_yn,
       pkwf_00_00_dmv.fn_00_yes_no_dsc(A.iu_yn) iu_dsc
  FROM wf_10_rl_mb A, wf_10_rl B, wf_10_mb C
 WHERE A.rl_k = B.row_key
   AND A.mb_k = C.row_key
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_10_rl_mb.sql
Error report -
SQL Error: Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_10_tp_tk.sql
In command -
CREATE OR REPLACE VIEW wf_vl_10_tp_tk
AS
  SELECT a.row_key tp_k, a.tp_id, a.tp_dsc,
         b.row_key tk_k, b.tk_id, b.tk_dsc,
         c.row_key rl_k, c.rl_id, c.rl_dsc
  FROM   wf_10_tp a,
         wf_10_tp_tk b,
         wf_10_rl c
  WHERE  a.row_key = b.tp_k
  AND    b.ac_rl_k = c.row_key(+)
  ORDER BY a.tp_dsc, b.seq_no
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_10_tp_tk.sql
Error report -
SQL Error: Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_11_mb.sql
In command -
CREATE OR REPLACE VIEW wf_vl_11_mb
AS
SELECT a.mb_id, a.mb_dsc, a.u_k, a.iu_yn,
       DECODE(a.iu_yn,'1','Yes','No') iu_yn_dsc,
       b.eml_adr, NVL(b.trc_yn,0) as rmt_usr_yn,
       DECODE(b.trc_yn,1,'Symbols User','Workflow Only') rmt_usr_dsc,
       b.fl_05 as is_adm_yn,
       DECODE(b.fl_05,'1','Yes','No') as is_adm_yn_dsc,
       pkwf_11_mb.fn_get_usr_role(a.u_k) as usr_roles
FROM   wf_10_mb a,
       t_99_10_ssu b
WHERE  UPPER(a.mb_id) = UPPER(b.lgn_id)  
ORDER BY a.mb_id
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_11_mb.sql
Error report -
SQL Error: Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_11_mb_l.sql
In command -
CREATE OR REPLACE VIEW wf_vl_11_mb_l
AS
SELECT *
FROM   wf_vl_11_mb
WHERE  rmt_usr_yn ='0'
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_11_mb_l.sql
Error report -
SQL Error: Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_11_mb_r.sql
In command -
CREATE OR REPLACE VIEW wf_vl_11_mb_r
AS
SELECT *
FROM   wf_vl_11_mb
WHERE  rmt_usr_yn ='1'
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_11_mb_r.sql
Error report -
SQL Error: Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_20_cpr_doc.sql
In command -
CREATE OR REPLACE FORCE VIEW wf_vl_20_cpr_doc
AS
  SELECT dc.row_key dc_k, dc.dc_id, 
           dd.id doc_id, dd.dsc doc_dsc,
           im.im_blb doc_blb
      FROM wf_30_dc dc, wf_vd_cpr_doc dd, 
           wf_30_dc_im im
     WHERE dc.row_key = im.dc_k
       AND im.im_tp_dm = dd.id
    ORDER BY dd.dsc ASC
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_20_cpr_doc.sql
Error report -
SQL Error: Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_20_dc_ac.sql
In command -
CREATE OR REPLACE VIEW wf_vl_20_dc_ac
AS
SELECT a.row_key dc_k,
       a.dc_id,
       a.dc_dsc,
       a.st_dtt,
       b.tp_id,
       b.tp_dsc,
       c.ed_dtt,
       d.ac_dtt,
       d.ac_rmk,
       d.mb_k,
       e.mb_id,
       e.mb_dsc,
       f.tk_id,
       f.tk_dsc
FROM   wf_20_dc a,
       wf_10_tp b,
       wf_20_dc_tk c,
       wf_20_dc_ac d,
       wf_10_mb e,
       wf_10_tp_tk f
WHERE  a.dc_st_dm = 'R'
AND    d.ac_dm = '2'
AND    a.tp_k = b.row_key
AND    a.row_key = c.dc_k
AND    c.row_key = d.dc_tk_k
AND    d.mb_k = e.u_k
AND    c.tk_k = f.row_key
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_20_dc_ac.sql
Error report -
SQL Error: Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_20_dc_rej.sql
In command -
CREATE OR REPLACE VIEW wf_vl_20_dc_rej
AS
SELECT a.row_key dc_k,
       a.dc_id,
       a.dc_dsc,
       a.st_dtt,
       b.tp_id,
       b.tp_dsc,
       c.ed_dtt,
       d.ac_dtt,
       d.ac_rmk,
       d.mb_k,
       e.mb_id,
       e.mb_dsc,
       f.tk_id,
       f.tk_dsc
FROM   wf_20_dc a,
       wf_10_tp b,
       wf_20_dc_tk c,
       wf_20_dc_ac d,
       wf_10_mb e,
       wf_10_tp_tk f
WHERE  a.dc_st_dm = 'R'
AND    a.tp_k = b.row_key
AND    a.row_key = c.dc_k
AND    c.row_key = d.dc_tk_k
AND    d.mb_k = e.u_k
AND    c.tk_k = f.row_key
AND    d.ac_dm = '2'
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_20_dc_rej.sql
Error report -
SQL Error: Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_20_my_tk.sql
In command -
CREATE OR REPLACE FORCE VIEW wf_vl_20_my_tk
AS
  SELECT *
  FROM TABLE(pkwf_20_gen.fn_m_tk)
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_20_my_tk.sql
Error report -
SQL Error: Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_20_ot_tk.sql
In command -
CREATE OR REPLACE FORCE VIEW wf_vl_20_ot_tk
AS
  SELECT *
  FROM TABLE(pkwf_20_gen.fn_u_ot_tk)
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vl\wf_vl_20_ot_tk.sql
Error report -
SQL Error: Closed Connection
Recreating 99 VP views....

Error starting at line : 1 File @ C:\Neulogic\private\WF\views\vp\wf_vp_30_cs_new_im.sql
In command -
CREATE OR REPLACE VIEW wf_vp_30_cs_new_im
AS
SELECT a.dc_k, b.pic_img, c.pic_sgn, d.pic_usr, e.pic_utl
FROM  (SELECT DISTINCT dc_k FROM wf_30_dc_im) a,
      (SELECT dc_k, im_blb as pic_img FROM wf_30_dc_im WHERE im_tp_dm = 'PIC_IMG') b,
      (SELECT dc_k, im_blb as pic_sgn FROM wf_30_dc_im WHERE im_tp_dm = 'PIC_SGN') c,
      (SELECT dc_k, im_blb as pic_usr FROM wf_30_dc_im WHERE im_tp_dm = 'PIC_USR') d,
      (SELECT dc_k, im_blb as pic_utl FROM wf_30_dc_im WHERE im_tp_dm = 'PIC_UTL') e
WHERE  a.dc_k = b.dc_k
AND    a.dc_k = c.dc_k
AND    a.dc_k = d.dc_k
AND    a.dc_k = e.dc_k
Error at Command Line : 1 Column : 1 File @ C:\Neulogic\private\WF\views\vp\wf_vp_30_cs_new_im.sql
Error report -
SQL Error: Closed Connection
Recreating 99 VQ views....

Error starting at line : 73 File @ C:\Neulogic\private\99\install.sql
In command -
@./views/vq/install.sql
Error report -
Unable to open file: "./views/vq/install.sql"
Recreating 99 $$ views....

Error starting at line : 75 File @ C:\Neulogic\private\99\install.sql
In command -
@./views/v$$/install.sql
Error report -
Unable to open file: "./views/v$$/install.sql"


creating 99 package body
___________________________________________________________


Error starting at line : 1 File @ C:\Neulogic\private\WF\package-body\pkwf_00_00_body.sql
In command -
CREATE OR REPLACE PACKAGE BODY pkwf_00_00 AS
  --
  /* Created By       : Femi Akintoye 
  ** Date Created     : 11-MAR-2016
  **
  ** PURPOSE: WF Routines for Preship Objects
  **
  ** MODIFICATION HISTORY:
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **  
  ** Copyright:  Neulogic Solutions Ltd, 2016
  **
  */
  --
  /* Private Routines */
  --
  /* Public Routines */
  FUNCTION fn_rk RETURN NUMBER IS
  BEGIN
    RETURN wf_seq_00_key.NEXTVAL;
  END fn_rk;
  --
  FUNCTION fn_doc RETURN NUMBER IS
  BEGIN
    RETURN wf_seq_20_doc.NEXTVAL;
  END fn_doc;
  --
  FUNCTION fn_act RETURN NUMBER IS
  BEGIN
    RETURN wf_seq_20_act.NEXTVAL;
  END fn_act;
  --
  FUNCTION fn_get_ctr_k(pi_id IN VARCHAR2) RETURN NUMBER IS
    v_k wf_00_00_dtd.n38%TYPE;
  BEGIN
    --
    BEGIN
      SELECT row_key
        INTO v_k
        FROM wf_vc_00_ctr
       WHERE ctr_cd = pi_id;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'Invalid country code ['||pi_id||']');
      WHEN TOO_MANY_ROWS THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'Country code ['||pi_id||'] duplicated');
    END;
    --
    RETURN v_k;
    --
  END fn_get_ctr_k;
  --
  FUNCTION fn_get_ctr_dsc(pi_id IN VARCHAR2) RETURN VARCHAR2 IS
    v_d wf_00_00_dtd.c255%TYPE;
  BEGIN
    --
    IF pi_id IS NOT NULL THEN
      BEGIN
        SELECT ctr_dsc
          INTO v_d
          FROM wf_vc_00_ctr
         WHERE ctr_cd = pi_id;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          v_d := '**ERROR** UNKNOWN';
          --pkwf_00_00_err.pr_raise(pi_msg => 'Invalid country code ['||pi_id||']');
        WHEN TOO_MANY_ROWS THEN
          pkwf_00_00_err.pr_raise(pi_msg => 'Country code ['||pi_id||'] duplicated');
      END;
    END IF;
    --
    RETURN v_d;
    --
  END fn_get_ctr_dsc;
  --
  --
  FUNCTION fn_get_nty_k(pi_id IN VARCHAR2) RETURN NUMBER IS
    v_k wf_00_00_dtd.n38%TYPE;
  BEGIN
    --
    BEGIN
      SELECT row_key
        INTO v_k
        FROM wf_vc_00_ctr
       WHERE ctr_cd = pi_id;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'Invalid nationality code ['||pi_id||']');
      WHEN TOO_MANY_ROWS THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'Nationality code ['||pi_id||'] duplicated');
    END;
    --
    RETURN v_k;
    --
  END fn_get_nty_k;
  --
  FUNCTION fn_get_nty_dsc(pi_id IN VARCHAR2) RETURN VARCHAR2 IS
    v_d wf_00_00_dtd.c255%TYPE;
  BEGIN
    --
    IF pi_id IS NOT NULL THEN
      BEGIN
        SELECT ctr_dsc
          INTO v_d
          FROM wf_vc_00_ctr
         WHERE ctr_cd = pi_id;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          v_d := '**ERROR** UNKNOWN';
          --pkwf_00_00_err.pr_raise(pi_msg => 'Invalid country code ['||pi_id||']');
        WHEN TOO_MANY_ROWS THEN
          pkwf_00_00_err.pr_raise(pi_msg => 'Country code ['||pi_id||'] duplicated');
      END;
    END IF;
    --
    RETURN v_d;
    --
  END fn_get_nty_dsc;
  --
  --
  FUNCTION fn_get_sta_k(pi_ctr_id IN VARCHAR2, pi_id IN VARCHAR2) RETURN NUMBER IS
    v_k     wf_00_00_dtd.n38%TYPE;
    v_ctr_k wf_00_00_dtd.n38%TYPE;
  BEGIN
    --
    BEGIN
      SELECT row_key
        INTO v_ctr_k
        FROM wf_vc_00_ctr
       WHERE ctr_cd = pi_ctr_id;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'Invalid country code ['||pi_ctr_id||'] for state ['||pi_id||']');
      WHEN TOO_MANY_ROWS THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'Country code ['||pi_ctr_id||'] for state ['||pi_id||'] duplicated');
    END;
    --
    /*BEGIN
      SELECT row_key
        INTO v_k
        FROM wf_vc_00_sta
       WHERE ctr_k = v_ctr_k
         AND sta_cd = pi_id;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'Invalid state code ['||pi_id||']');
      WHEN TOO_MANY_ROWS THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'State code ['||pi_id||'] duplicated');
    END;*/
    RETURN v_k;
    --
  END fn_get_sta_k;
  --
  FUNCTION fn_get_sta_dsc(pi_id IN VARCHAR2) RETURN VARCHAR2 IS
    v_d wf_00_00_dtd.c255%TYPE;
  BEGIN
    --
    IF pi_id IS NOT NULL THEN
      BEGIN
        SELECT sta_dsc
          INTO v_d
          FROM wf_vc_00_sta
         WHERE sta_cd = pi_id;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          v_d := '**ERROR** UNKNOWN';
          --pkwf_00_00_err.pr_raise(pi_msg => 'Invalid state code ['||pi_id||']');
        WHEN TOO_MANY_ROWS THEN
          pkwf_00_00_err.pr_raise(pi_msg => 'State code ['||pi_id||'] duplicated');
      END;
    END IF;
    --
    RETURN v_d;
    --
  END fn_get_sta_dsc;
  --
  --
  FUNCTION fn_get_ttl_k(pi_id IN VARCHAR2) RETURN NUMBER IS
    v_k wf_00_00_dtd.n38%TYPE;
  BEGIN
    --
    BEGIN
      SELECT ctc_ttl_k
        INTO v_k
        FROM wf_vc_00_ttl
       WHERE ctc_ttl_id = pi_id;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'Invalid title code ['||pi_id||']');
      WHEN TOO_MANY_ROWS THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'Title code ['||pi_id||'] duplicated');
    END;
    --
    RETURN v_k;
    --
  END fn_get_ttl_k;
  --
  FUNCTION fn_get_ttl_dsc(pi_id IN VARCHAR2) RETURN VARCHAR2 IS
    v_d wf_00_00_dtd.c255%TYPE;
  BEGIN
    --
    IF pi_id IS NOT NULL THEN
      BEGIN
        SELECT ctc_ttl_dsc
          INTO v_d
          FROM wf_vc_00_ttl
         WHERE ctc_ttl_id = pi_id;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          v_d := '**ERROR** UNKNOWN';
          --pkwf_00_00_err.pr_raise(pi_msg => 'Invalid title code ['||pi_id||']');
        WHEN TOO_MANY_ROWS THEN
          pkwf_00_00_err.pr_raise(pi_msg => 'Title code ['||pi_id||'] duplicated');
      END;
    END IF;
    --
    RETURN v_d;
    --
  END fn_get_ttl_dsc;
  --
  --
  FUNCTION fn_get_rln_k(pi_id IN VARCHAR2) RETURN NUMBER IS
    v_k wf_00_00_dtd.n38%TYPE;
  BEGIN
    --
    BEGIN
      SELECT ctc_rln_k
        INTO v_k
        FROM wf_vc_00_rln
       WHERE ctc_rln_id = pi_id;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'Invalid relationship code ['||pi_id||']');
      WHEN TOO_MANY_ROWS THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'Relationship code ['||pi_id||'] duplicated');
    END;
    --
    RETURN v_k;
    --
  END fn_get_rln_k;
  --
  FUNCTION fn_get_rln_dsc(pi_id IN VARCHAR2) RETURN VARCHAR2 IS
    v_d wf_00_00_dtd.c255%TYPE;
  BEGIN
    --
    IF pi_id IS NOT NULL THEN
      BEGIN
        SELECT ctc_rln_dsc
          INTO v_d
          FROM wf_vc_00_rln
         WHERE ctc_rln_id = pi_id;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          v_d := '**ERROR** UNKNOWN';
          --pkwf_00_00_err.pr_raise(pi_msg => 'Invalid relationship code ['||pi_id||']');
        WHEN TOO_MANY_ROWS THEN
          pkwf_00_00_err.pr_raise(pi_msg => 'Relationship code ['||pi_id||'] duplicated');
      END;
    END IF;
    --
    RETURN v_d;
    --
  END fn_get_rln_dsc;
  --
  --
  FUNCTION fn_get_bnk_k(pi_id IN VARCHAR2) RETURN NUMBER IS
    v_k wf_00_00_dtd.n38%TYPE;
  BEGIN
    --
    BEGIN
      SELECT bnk_k
        INTO v_k
        FROM wf_vc_00_bnk
       WHERE bnk_id = pi_id;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'Invalid bank code ['||pi_id||']');
      WHEN TOO_MANY_ROWS THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'Bank code ['||pi_id||'] duplicated');
    END;
    --
    RETURN v_k;
    --
  END fn_get_bnk_k;
  --
  FUNCTION fn_get_bnk_dsc(pi_id IN VARCHAR2) RETURN VARCHAR2 IS
    v_d wf_00_00_dtd.c255%TYPE;
  BEGIN
    --
    IF pi_id IS NOT NULL THEN
      BEGIN
        SELECT bnk_dsc
          INTO v_d
          FROM wf_vc_00_bnk
         WHERE bnk_id = pi_id;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          v_d := '**ERROR** UNKNOWN';
          --pkwf_00_00_err.pr_raise(pi_msg => 'Invalid relationship code ['||pi_id||']');
        WHEN TOO_MANY_ROWS THEN
          pkwf_00_00_err.pr_raise(pi_msg => 'Bank code ['||pi_id||'] duplicated');
      END;
    END IF;
    --
    RETURN v_d;
    --
  END fn_get_bnk_dsc;
  --
  --
END pkwf_00_00; 
Error report -
Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\package-body\pkwf_00_00_dmv_body.sql
In command -
CREATE OR REPLACE PACKAGE BODY pkwf_00_00_dmv AS
  --
  /* Created By       : Aderemi Alabi
  ** Date Created     : 21-DEC-2011
  ** Release Version  : 2.0
  **
  ** PURPOSE: System Domain Definition
  **
  ** MODIFICATION HISTORY:
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **  
  ** Copyright:  ProGenics Corp. Ltd, 2011
  **
  */
  /* Package Variables */
  --
  --pv_rec    cs_vt_00_dmv%ROWTYPE;
  --
  --
  /* Private Routines */
  --
  FUNCTION fn_dmd (pi_dm IN VARCHAR2) RETURN VARCHAR2 IS
    v_dsc  wf_00_00_dmd.dmd_dsc%TYPE;
    CURSOR cur_dmd IS
    SELECT A.dmd_dsc
      FROM wf_00_00_dmd A;
  BEGIN
    v_dsc := NULL;
    OPEN cur_dmd;
    FETCH cur_dmd INTO v_dsc;
    CLOSE cur_dmd;
    RETURN v_dsc;
  END fn_dmd;
  --
  FUNCTION fn_dmv_dsc (pi_id VARCHAR2, pi_dm IN VARCHAR2) RETURN VARCHAR2 IS
    v_dsc  wf_00_00_dmv.dmv_dsc%TYPE;
    CURSOR cur_dmv IS
    SELECT A.dmv_dsc
      FROM wf_00_00_dmv A, wf_00_00_dmd b
     WHERE b.dmd_dm = pi_id
       AND b.row_key = A.dmd_k
       AND A.dmv_id = pi_dm;
  BEGIN
    v_dsc := NULL;
    OPEN cur_dmv;
    FETCH cur_dmv INTO v_dsc;
    CLOSE cur_dmv;
    RETURN v_dsc;
  END fn_dmv_dsc;
  --  
  --
  PROCEDURE pr_val_dm (pi_id IN VARCHAR2, pi_dm IN VARCHAR2) IS
    v_dsc  VARCHAR2(100);
  BEGIN
    --
    --v_dsc:= fn_dmd (pi_dm => pi_dm);
    --
    pkwf_00_vld.pr_reqd (pi_d => pi_dm, pi_dsc =>  'Domain Type');
    pkwf_00_vld.pr_reqd (pi_d => pi_id, pi_dsc =>  'Domain Data');
    --
    BEGIN
      SELECT 'a'
        INTO v_dsc
        FROM wf_00_00_dmv A, wf_00_00_dmd b
       WHERE b.dmd_dm = pi_id
         AND b.row_key = A.dmd_k
         AND A.dmv_id = pi_dm;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        pkwf_00_00_err.pr_raise(pi_msg => '"'||pi_id||'"  is an invalid '||'value '||'. Further operation');
      WHEN TOO_MANY_ROWS THEN
        pkwf_00_00_err.pr_raise(pi_msg => '"'||pi_id||'"  is duplicated '||' '||'. Further operation');
    END;
    --
  END pr_val_dm;
  --
  /* Public Routines */
  --  
  FUNCTION fn_00_yes_no_dsc (pi_dm IN VARCHAR2) RETURN VARCHAR2 IS
    v_id  CONSTANT VARCHAR2(20) := '00_YES_NO';
    v_dsc VARCHAR2(100);
  BEGIN
    v_dsc := NULL;
    IF pi_dm IS NOT NULL THEN
      v_dsc := fn_dmv_dsc(pi_id => v_id, pi_dm => pi_dm);
    END IF;
    RETURN v_dsc;
  END fn_00_yes_no_dsc;
  --
  FUNCTION fn_00_appr_stat_dsc (pi_dm IN VARCHAR2) RETURN VARCHAR2 IS
    v_id  CONSTANT VARCHAR2(20) := '00_APPR_STAT';
    v_dsc VARCHAR2(100);
  BEGIN
    v_dsc := NULL;
    IF pi_dm IS NOT NULL THEN
      v_dsc := fn_dmv_dsc(pi_id => v_id, pi_dm => pi_dm);
    END IF;
    RETURN v_dsc;
  END fn_00_appr_stat_dsc;
  --
  FUNCTION fn_00_week_day_dsc (pi_dm IN VARCHAR2) RETURN VARCHAR2 IS
    v_id  CONSTANT VARCHAR2(20) := '00_WEEK_DAY';
    v_dsc VARCHAR2(100);
  BEGIN
    v_dsc := NULL;
    IF pi_dm IS NOT NULL THEN
      v_dsc := fn_dmv_dsc(pi_id => v_id, pi_dm => pi_dm);
    END IF;
    RETURN v_dsc;
  END fn_00_week_day_dsc;
  --
  --
  FUNCTION fn_cs_gdr_dsc (pi_dm IN VARCHAR2) RETURN VARCHAR2 IS
    v_id  CONSTANT VARCHAR2(20) := '00_GENDER';
    v_dsc VARCHAR2(100);
  BEGIN
    v_dsc := NULL;
    IF pi_dm IS NOT NULL THEN
      v_dsc := fn_dmv_dsc(pi_id => v_id, pi_dm => pi_dm);
    END IF;
    RETURN v_dsc;
  END fn_cs_gdr_dsc;
  --
  PROCEDURE pr_val_cs_gdr (pi_dm IN VARCHAR2) IS
  BEGIN
    pr_val_dm (pi_id => '00_GENDER', pi_dm => pi_dm);
  END;
  --
  --
  FUNCTION fn_cs_mar_dsc (pi_dm IN VARCHAR2) RETURN VARCHAR2 IS
    v_id  CONSTANT VARCHAR2(20) := '00_MARITAL';
    v_dsc VARCHAR2(100);
  BEGIN
    v_dsc := NULL;
    IF pi_dm IS NOT NULL THEN
      v_dsc := fn_dmv_dsc(pi_id => v_id, pi_dm => pi_dm);
    END IF;
    RETURN v_dsc;
  END fn_cs_mar_dsc;
  --
  PROCEDURE pr_val_cs_mar (pi_dm IN VARCHAR2) IS
  BEGIN
    pr_val_dm (pi_id => '00_MARITAL', pi_dm => pi_dm);
  END;
  --
  --  
END pkwf_00_00_dmv; 
Error report -
Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\package-body\pkwf_00_00_err_body.sql
In command -
CREATE OR REPLACE PACKAGE BODY pkwf_00_00_err AS
  --
  /* Created By       : Femi Akintoye
  ** Date Created     : 07-MAR-2016
  **
  ** PURPOSE: Error Handling Routines
  **
  ** MODIFICATION HISTORY:
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **  
  ** Neulogic Solutions Ltd, 2016
  **
  */
  --
  --package variables
  --pv_err_rfr st_00_00_erl.err_rfr%TYPE;
  pv_err_cd  NUMBER;
  pv_item    VARCHAR2(255);
  --
  --
  -----------------------------------------------------------------------------------
  --  Internal Routines
  -----------------------------------------------------------------------------------
  -- Generate error reference
  FUNCTION fn_err_rfr RETURN VARCHAR2
  IS
  BEGIN
    --
    --pv_err_rfr := NULL;
    DBMS_RANDOM.SEED(TO_CHAR(SYSDATE,'DDMMYYYYHH24MISS'));
    --
    RETURN DBMS_RANDOM.STRING('A',12);
    --
  END fn_err_rfr;
  --
  --
  --  Get Error Message
  FUNCTION fn_get_err(pi_err_id IN VARCHAR2) RETURN VARCHAR2
  IS
    --
    v_mss  wf_00_00_erd.err_msg%TYPE;
    --
    CURSOR c_err IS
      SELECT err_msg
        FROM wf_00_00_erd
       WHERE err_id = pi_err_id;
    --
  BEGIN
    --
    v_mss := NULL;
    --
    OPEN  c_err;
    FETCH c_err INTO v_mss;
    CLOSE c_err;
    --
    RETURN NVL(v_mss,'Undefined WF error condition [' || pi_err_id || '] detected ');
    --
  END fn_get_err;
  --
  -----------------------------------------------------------------------------------
  --  External Routines
  -----------------------------------------------------------------------------------
  /*
   *  Determine if input is null. Returns TRUE is null condition is determined
  */
  FUNCTION fn_apex_error(p_error apex_error.t_error) RETURN apex_error.t_error_result
  IS
    --
  BEGIN
    RETURN NULL;--'1'; --pk99$$err.fn_apex_error (p_error);
  END fn_apex_error;
  --
  -- Error Call Interface 1
  PROCEDURE pr_raise(pi_msg IN VARCHAR2) IS
    v_loc CONSTANT VARCHAR2(100) := apex_error.c_inline_in_notification;
  BEGIN
    logger.log(pi_msg, 'WFERR');
    raise_application_error(-20005, '{WF} '||pi_msg);
  END pr_raise;
  --
  -- Error Call Interface 2
  PROCEDURE pr_raise(pi_id IN VARCHAR2,
                     pi_p1 IN VARCHAR2 DEFAULT NULL,
                     pi_p2 IN VARCHAR2 DEFAULT NULL,
                     pi_p3 IN VARCHAR2 DEFAULT NULL,
                     pi_p4 IN VARCHAR2 DEFAULT NULL,
                     pi_p5 IN VARCHAR2 DEFAULT NULL,
                     pi_p6 IN VARCHAR2 DEFAULT NULL,
                     pi_p7 IN VARCHAR2 DEFAULT NULL,
                     pi_p8 IN VARCHAR2 DEFAULT NULL,
                     pi_p9 IN VARCHAR2 DEFAULT NULL)
  IS
    --
    v_loc CONSTANT VARCHAR2(100) := apex_error.c_inline_in_notification;
    v_msg  wf_00_00_erd.err_msg%TYPE;    
    --
  BEGIN
    --
    v_msg := fn_get_err(pi_err_id => pi_id);
    --
    v_msg := REPLACE (v_msg, '%p1%', pi_p1);
    v_msg := REPLACE (v_msg, '%p2%', pi_p2);
    v_msg := REPLACE (v_msg, '%p3%', pi_p3);
    v_msg := REPLACE (v_msg, '%p4%', pi_p4);
    v_msg := REPLACE (v_msg, '%p5%', pi_p5);
    v_msg := REPLACE (v_msg, '%p6%', pi_p6);
    v_msg := REPLACE (v_msg, '%p7%', pi_p7);
    v_msg := REPLACE (v_msg, '%p8%', pi_p8);
    v_msg := REPLACE (v_msg, '%p9%', pi_p9);
    --
    v_msg := '{'||pi_id||'} '||LTRIM(v_msg);
    --
    logger.log(v_msg, 'WFERR');
    raise_application_error(-20025, v_msg);
    --
    --apex_error.add_error(p_message => v_msg, 
      --                   p_display_location => v_loc);
    --
  END pr_raise;
  --
  -- Error Call Interface 3
--  PROCEDURE pr_raise(pi_id IN VARCHAR2,
--                     pi_ci IN VARCHAR2,
--                     pi_p1 IN VARCHAR2 DEFAULT NULL,
--                     pi_p2 IN VARCHAR2 DEFAULT NULL,
--                     pi_p3 IN VARCHAR2 DEFAULT NULL,
--                     pi_p4 IN VARCHAR2 DEFAULT NULL,
--                     pi_p5 IN VARCHAR2 DEFAULT NULL,
--                     pi_p6 IN VARCHAR2 DEFAULT NULL,
--                     pi_p7 IN VARCHAR2 DEFAULT NULL,
--                     pi_p8 IN VARCHAR2 DEFAULT NULL,
--                     pi_p9 IN VARCHAR2 DEFAULT NULL)
--  IS
--    --
--    v_loc1  CONSTANT VARCHAR2(100) := apex_error.c_inline_in_notification;
--    v_loc2  CONSTANT VARCHAR2(100) := apex_error.c_inline_with_field_and_notif;
--    v_msg  st_00_00_erd.err_msg%TYPE;  
--    v_page_item VARCHAR2(200); 
--    v_item VARCHAR2(200); 
--    v_page VARCHAR2(100); 
--    v_app  VARCHAR2(100); 
--    --
--  BEGIN
--    --
--   v_msg := fn_get_err(pi_err_id => pi_id);
--    --
--    v_msg := REPLACE (v_msg, '%p1%', pi_p1);
--    v_msg := REPLACE (v_msg, '%p2%', pi_p2);
--    v_msg := REPLACE (v_msg, '%p3%', pi_p3);
--    v_msg := REPLACE (v_msg, '%p4%', pi_p4);
--    v_msg := REPLACE (v_msg, '%p5%', pi_p5);
--    v_msg := REPLACE (v_msg, '%p6%', pi_p6);
--    v_msg := REPLACE (v_msg, '%p7%', pi_p7);
--    v_msg := REPLACE (v_msg, '%p8%', pi_p8);
--    v_msg := REPLACE (v_msg, '%p9%', pi_p9);
--    --
--    v_msg := '{'||pi_id||'} '||LTRIM(v_msg);
--    --
--    IF pi_ci IS NOT NULL THEN
--      v_app  := pkst_00.fn_crnt_apx_ap;
--      v_page := pkst_00.fn_crnt_apx_pg;
--      v_item := 'P' || '_' || v_page || '_' || pi_ci;
--      BEGIN
--        SELECT item_name
--          INTO v_page_item
--          FROM apex_application_page_items
--         WHERE application_id = v_app
--           AND page_id = v_page
--           AND item_name = v_item;
--        IF NVL(v_page_item,'0') <> '0' THEN
--          v_msg := '#LABEL# ' || v_msg;
--          apex_error.add_error(p_message => v_msg, 
--                               p_display_location => v_loc2,
--                               p_page_item_name => v_page_item);
--        ELSE
--          apex_error.add_error(p_message => v_msg, 
--                               p_display_location => v_loc1);
--        END IF;
--      EXCEPTION
--        WHEN OTHERS THEN
--          apex_error.add_error(p_message => v_msg, 
--                               p_display_location => v_loc1);
--      END;
--    ELSE
--      /* apex_error.add_error(p_message => v_msg, 
--                                 p_display_location => v_loc1); */
--      NULL;                                 
--    END IF;                                 
--    --
--    logger.log(v_msg, 'WFERR');
--    raise_application_error(-20055, v_msg);
--    --
--  END pr_raise;
  --
END pkwf_00_00_err;
Error report -
Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\package-body\pkwf_00_apx_body.sql
In command -
CREATE OR REPLACE PACKAGE BODY pkwf_00_apx AS
  --
  /* Created By       : Kunle Adebona
  ** Date Created     : 31-AUG-2012
  ** Release Version  : 3.0
  **
  ** PURPOSE: APEX ENGINE interfacing routines
  **
  ** MODIFICATION HISTORY:
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **  
  **
  */
  --
  /* Private Routines */
  --
  --
  FUNCTION fn_get_bool_ssv (pi_itm VARCHAR2) RETURN BOOLEAN IS
    v_yn  PLS_INTEGER := 0;
  BEGIN
    BEGIN
      v_yn := TO_NUMBER(APEX_UTIL.GET_SESSION_STATE(pi_itm));
    EXCEPTION
      WHEN OTHERS THEN
        NULL;
    END;
    IF v_yn = 1 THEN    
      RETURN TRUE;
    ELSE
      RETURN FALSE;
    END IF;  
  END fn_get_bool_ssv;
  --  
  -- CHAR Session States
  FUNCTION fn_get_char_ssv (pi_itm VARCHAR2) RETURN VARCHAR2 IS
    v_val VARCHAR2(500) := NULL;
  BEGIN
    BEGIN
      v_val := APEX_UTIL.GET_SESSION_STATE(pi_itm);
    EXCEPTION
      WHEN OTHERS THEN
        NULL;
    END;
    RETURN v_val;
  END fn_get_char_ssv;
  -- 
  -- NUMBER Session States
  FUNCTION fn_get_num_ssv (pi_itm VARCHAR2) RETURN NUMBER IS
    v_val NUMBER := NULL;
  BEGIN
    BEGIN
      v_val := TO_NUMBER(APEX_UTIL.GET_SESSION_STATE(pi_itm));
    EXCEPTION
      WHEN OTHERS THEN
        NULL;
    END;
    RETURN v_val;
  END fn_get_num_ssv;
  --  
  -- Reset 00 Session States
  PROCEDURE pr_clr_all IS
  BEGIN
    APEX_UTIL.SET_SESSION_STATE('AI_USR_KY',NULL);     -- Login User Key
    APEX_UTIL.SET_SESSION_STATE('AI_USR_BRCH',NULL);   -- Current Login Branch
    -- APEX_UTIL.SET_SESSION_STATE('AI_BRCH_INTM',NULL);  -- Current Branch Login Time
    -- APEX_UTIL.SET_SESSION_STATE('AI_USR_ID',NULL);  -- Login User ID
  END pr_clr_all;
  --     
  -- Clear Application Session State
  PROCEDURE pr_reset_app_ssv (pi_ssn VARCHAR2) IS
    v_sn  VARCHAR2(100) := UPPER(pi_ssn);
  BEGIN
    IF v_sn IS NOT NULL THEN
      APEX_UTIL.SET_SESSION_STATE(v_sn,NULL);
    END IF;  
  END pr_reset_app_ssv;
  --  
  -- Set Session State
  PROCEDURE pr_set_app_ssv (pi_ssn VARCHAR2, pi_ssv VARCHAR2) IS
    v_sn  VARCHAR2(100) := UPPER(pi_ssn);
  BEGIN
    IF v_sn IS NOT NULL THEN
      APEX_UTIL.SET_SESSION_STATE(v_sn,pi_ssv);
    END IF;
  END pr_set_app_ssv;
  --
  -- Set Session State
  PROCEDURE pr_set_app_ssv (pi_ssn VARCHAR2, pi_ssv NUMBER) IS
    v_sn  VARCHAR2(100) := UPPER(pi_ssn);
  BEGIN
    IF v_sn IS NOT NULL THEN
      APEX_UTIL.SET_SESSION_STATE(v_sn,TO_CHAR(pi_ssv));
    END IF;
  END pr_set_app_ssv;
  --    
  --       
  /* Public Routines */
  --  
  -- Clear all Application Session values
  PROCEDURE pr_reset_all_ssv IS
  BEGIN
    pr_clr_all;
  END pr_reset_all_ssv;
  --
  -- Clear Branch Session values
  PROCEDURE pr_reset_brch_ssv IS
  BEGIN
    pr_reset_app_ssv (pi_ssn => 'AI_USR_BRCH');
    -- pr_reset_app_ssv (pi_ssn => 'AI_BRCH_INTM');
    -- pr_reset_app_ssv (pi_ssn => 'AI_USR_ID');
  END pr_reset_brch_ssv;
  --  
  -- Current APEX User
  FUNCTION fn_crnt_apx_usr RETURN VARCHAR2 IS
    v_itm CONSTANT VARCHAR2(100) := 'APP_USER';
  BEGIN
    RETURN fn_get_char_ssv (pi_itm => v_itm);
  END fn_crnt_apx_usr;
  --
  -- Current APEX Application
  FUNCTION fn_crnt_apx_ap RETURN VARCHAR2 IS
    v_itm CONSTANT VARCHAR2(100) := 'APP_ID';
  BEGIN
    RETURN fn_get_char_ssv(pi_itm => v_itm);
  END fn_crnt_apx_ap;
  --
  -- Current APEX Page
  FUNCTION fn_crnt_apx_pg RETURN VARCHAR2 IS
    v_itm CONSTANT VARCHAR2(100) := 'APP_PAGE_ID';
  BEGIN
    RETURN fn_get_char_ssv(pi_itm => v_itm);
  END fn_crnt_apx_pg;
  --
  -- Current APEX User Agent
  FUNCTION fn_crnt_apx_ag RETURN VARCHAR2 IS
    v_ag VARCHAR2(500) := NULL;
  BEGIN
    v_ag := SUBSTR(OWA_UTIL.GET_CGI_ENV ('HTTP_USER_AGENT'),1,100); 
    RETURN v_ag;
  END fn_crnt_apx_ag;
  --
  -- Current APEX User IP
  FUNCTION fn_crnt_apx_ip RETURN VARCHAR2 IS
    v_ip VARCHAR2(500) := NULL;
  BEGIN
    v_ip := SUBSTR(OWA_UTIL.GET_CGI_ENV ('REMOTE_ADDR'),1,20); 
    RETURN v_ip;
  END fn_crnt_apx_ip;
  --
  -- Current User Key
  FUNCTION fn_usr_ky RETURN NUMBER IS
    v_itm CONSTANT VARCHAR2(100) := 'AI_USR_KY';
  BEGIN
    RETURN fn_get_num_ssv (pi_itm => v_itm);
  END fn_usr_ky;
  --
  -- Current User ID
  FUNCTION fn_usr_id RETURN VARCHAR2 IS
    v_itm CONSTANT VARCHAR2(100) := 'AI_USR_ID';
  BEGIN
    RETURN fn_crnt_apx_usr; -- fn_get_char_ssv (pi_itm => v_itm);
  END fn_usr_id;
  --  
  -- Set User Key
  PROCEDURE pr_set_usr_ky (pi_key NUMBER)  IS
    v_itm CONSTANT VARCHAR2(100) := 'AI_USR_KY';
  BEGIN
    pr_set_app_ssv (pi_ssn => v_itm, pi_ssv => pi_key);
  END pr_set_usr_ky;
  --
  -- Set User Branch
  PROCEDURE pr_brch_login (pi_brch_id VARCHAR2, pi_usr_id VARCHAR2) IS
    v_now TIMESTAMP;
  BEGIN
    v_now := pkwf_00.fn_now;
    pr_set_app_ssv (pi_ssn => 'AI_USR_BRCH', pi_ssv => pi_brch_id);
    -- pr_set_app_ssv (pi_ssn => 'AI_BRCH_INTM', pi_ssv => v_now);
    -- pr_set_app_ssv (pi_ssn => 'AI_USR_BRCH', pi_ssv => pi_usr_id);
  END pr_brch_login;
  --
  -- APEX wrapper for apex_util.string_to_table
  FUNCTION fn_apx_str_to_tbl(pi_str IN VARCHAR2, pi_sep IN VARCHAR2 DEFAULT ':') RETURN APEX_APPLICATION_GLOBAL.vc_arr2 IS
  BEGIN
    RETURN APEX_UTIL.STRING_TO_TABLE(pi_str, pi_sep);
  END;
  --
  -- APEX wrapper for apex_util.table_to_string
  FUNCTION fn_apx_tbl_to_str(pi_tbl IN APEX_APPLICATION_GLOBAL.vc_arr2, pi_sep IN VARCHAR2 DEFAULT ':') RETURN VARCHAR2 IS
  BEGIN
    RETURN APEX_UTIL.TABLE_TO_STRING(pi_tbl, pi_sep);
  END;
  --
  -- APEX wrapper for apex_util.public_check_authorization
  FUNCTION fn_apx_chk_auth(pi_scheme IN VARCHAR2) RETURN NUMBER IS
    v_return NUMBER;
  BEGIN
    v_return := 0;
    IF apex_util.public_check_authorization(pi_scheme) THEN
      v_return := 1;
    END IF;
    --
    RETURN v_return;
    --
  END fn_apx_chk_auth;
  --
  PROCEDURE pr_clr_pss IS
  BEGIN
    pr_reset_app_ssv('AI_P01');
    pr_reset_app_ssv('AI_P02');
    pr_reset_app_ssv('AI_P03');
    pr_reset_app_ssv('AI_P04');
    pr_reset_app_ssv('AI_P05');
    pr_reset_app_ssv('AI_P06');
    pr_reset_app_ssv('AI_P07');
    pr_reset_app_ssv('AI_P08');
    pr_reset_app_ssv('AI_P09');
    pr_reset_app_ssv('AI_P10');
  END pr_clr_pss;
  --
  PROCEDURE pr_set_pss (p01 IN VARCHAR2 DEFAULT NULL,  
                        p02 IN VARCHAR2 DEFAULT NULL,
                        p03 IN VARCHAR2 DEFAULT NULL,  
                        p04 IN VARCHAR2 DEFAULT NULL,
                        p05 IN VARCHAR2 DEFAULT NULL,  
                        p06 IN VARCHAR2 DEFAULT NULL,
                        p07 IN VARCHAR2 DEFAULT NULL,  
                        p08 IN VARCHAR2 DEFAULT NULL,
                        p09 IN VARCHAR2 DEFAULT NULL,  
                        p10 IN VARCHAR2 DEFAULT NULL) IS
  BEGIN
    pr_clr_pss;
    pr_set_app_ssv (pi_ssn => 'AI_P01', pi_ssv => p01);
    pr_set_app_ssv (pi_ssn => 'AI_P02', pi_ssv => p02);
    pr_set_app_ssv (pi_ssn => 'AI_P03', pi_ssv => p03);
    pr_set_app_ssv (pi_ssn => 'AI_P04', pi_ssv => p04);
    pr_set_app_ssv (pi_ssn => 'AI_P05', pi_ssv => p05);
    pr_set_app_ssv (pi_ssn => 'AI_P06', pi_ssv => p06);
    pr_set_app_ssv (pi_ssn => 'AI_P07', pi_ssv => p07);
    pr_set_app_ssv (pi_ssn => 'AI_P08', pi_ssv => p08);
    pr_set_app_ssv (pi_ssn => 'AI_P09', pi_ssv => p09);
    pr_set_app_ssv (pi_ssn => 'AI_P10', pi_ssv => p10);
  END pr_set_pss;
  --  
  FUNCTION fn_get_pss (p_no PLS_INTEGER) RETURN VARCHAR2 IS
    v_itm VARCHAR2(50) := NULL;
  BEGIN
    IF p_no BETWEEN 1 AND 9 THEN
      v_itm := 'AI_P0'||TO_CHAR(p_no);
    ELSIF p_no = 10 THEN
      v_itm := 'AI_P10';
    END IF;
    IF v_itm IS NOT NULL THEN
      RETURN fn_get_char_ssv (pi_itm => v_itm);
    ELSE
      RETURN NULL;
    END IF;
  END fn_get_pss;
  --
  -- 
  PROCEDURE pr_set_uss IS
  BEGIN
    --
    -- Set APEX context security group 
    wwv_flow_api.set_security_group_id;
    apex_application.g_user := 'SYSTEM';
    --
    -- Set UPDATES Session States
    pr_reset_all_ssv;
    --
    pr_set_app_ssv (pi_ssn => 'AI_USR_KY', pi_ssv => 1);
    pr_set_app_ssv (pi_ssn => 'APP_USER', pi_ssv => 'SYSTEM');
    --
    --
  END pr_set_uss;
  --  
  PROCEDURE pr_clr_uss IS
  BEGIN
    pr_reset_all_ssv;
  END pr_clr_uss;
  --    
  --
END pkwf_00_apx;
Error report -
Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\package-body\pkwf_00_ath_body.sql
In command -
create or replace PACKAGE BODY pkwf_00_ath AS
  --
  /* Created By       : Aderemi ALabi
  ** Date Created     : 09-JUN-2016
  ** Release Version  : 2.0
  **
  ** PURPOSE: WF Routines for dual authentication
  **
  ** MODIFICATION HISTORY:
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **
  */
  --
  pv_lgn_id VARCHAR2(30);
  gv_k      VARCHAR2(500) := NULL;
  --
  /* Pprivate Routines */
  --
  FUNCTION fn_is_local(pi_lgn_id VARCHAR2) RETURN BOOLEAN IS
    --
  CURSOR c_local IS
    SELECT trc_yn
    FROM   t_99_10_ssu
    where UPPER(lgn_id) = UPPER(pi_lgn_id);
    --
    v_local  VARCHAR2(100);
    v_return BOOLEAN := TRUE;
    --
  BEGIN
    --
    OPEN  c_local;
    FETCH c_local INTO v_local;
    CLOSE c_local;
    --
    v_local := NVL(v_local,'0');
    --
    IF v_local = '1' THEN
      v_return := FALSE;
    END IF;
    --
    RETURN v_return;
    --
  END fn_is_local;
  --
  PROCEDURE pr_load_gvs IS
  BEGIN
    SELECT SYS_CONTEXT ('USERENV', 'LANGUAGE') ||
           SYS_CONTEXT ('USERENV', 'SESSION_USER') ||
           SYS_CONTEXT ('USERENV', 'SESSIONID') ||
           SYS_CONTEXT ('USERENV', 'NLS_DATE_FORMAT') 
    INTO gv_k
    FROM dual;
  END pr_load_gvs;
  --
  /* Public Routines */
  --
  FUNCTION fn_login(p_username VARCHAR2, p_password VARCHAR2) RETURN BOOLEAN IS
  BEGIN
    logger.log('fn_login IN | p_username => '||p_username);
    pv_lgn_id := p_username;
    IF fn_is_local(p_username) THEN
      logger.log('fn_login LOCAL USER');
      pr_load_gvs;
      RETURN pk$990.fn_login(p_username, p_password);
    ELSE
      logger.log('fn_login REMOTE USER');
      RETURN pk99$$wf.fn_login@wf_sy(p_username, p_password);
    END IF;  
    logger.log('fn_login OUT');
  END fn_login;
  --
  PROCEDURE pr_blath(pi_user IN VARCHAR2) IS
  BEGIN
    logger.log('pr_blath IN | p1_user => '||pi_user);
    pv_lgn_id := NULL;
    IF fn_is_local(pi_user) THEN
      logger.log('pr_blath LOCAL USER');
      pk$990.pr_blath(pi_user);
     ELSE
     logger.log('pr_blath REMOTE USER');
      pk99$$wf.pr_blath@wf_sy(pi_user);
    END IF; 
    logger.log('pr_blath OUT');
  END pr_blath;
  --
  PROCEDURE pr_alath IS 
  BEGIN
    logger.log('pr_alath LOCAL USER');
    logger.log('pr_alayt user => '|| pv_lgn_id);
    IF fn_is_local(pv_lgn_id) THEN
      logger.log('pr_alath LOCAL USER');
      pk$990.pr_alath;
    ELSE
      logger.log('pr_alath REMOTE USER');
      --pk$990.pr_alath@wf_sy;
    END IF;  
    logger.log('pr_alath OUT');
  END pr_alath;
  --
END pkwf_00_ath;
Error report -
Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\package-body\pkwf_00_body.sql
In command -
create or replace PACKAGE BODY pkwf_00 AS
  --
  /* Created By       : Mike Onuoha
  ** Date Created     : 06-SEPT-2012
  ** Release Version  : 3.0
  **
  ** PURPOSE: General Routines
  **
  ** MODIFICATION HISTORY:
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **  
  ** Copyright:  ProGenics Corp. Ltd, 2012
  **
  */
  --
  /* Package Variables */
  --
  --
  /* Private Routines */
  --  
  FUNCTION fn_dmv_dsc (pi_dm_id VARCHAR2, pi_dmv_id VARCHAR2) RETURN VARCHAR2 IS
    v_dsc  wf_00_00_dmv.dmv_dsc%TYPE;
    CURSOR cur_dmv IS
    SELECT A.dmv_dsc
      FROM wf_00_00_dmv A, wf_00_00_dmd b
     WHERE b.dmd_dm = pi_dm_id
       AND b.row_key = A.dmd_k
       AND A.dmv_id = pi_dmv_id
       AND A.ius_yn = 1;
  BEGIN
    v_dsc := NULL;
    OPEN cur_dmv;
    FETCH cur_dmv INTO v_dsc;
    CLOSE cur_dmv;
    RETURN v_dsc;
  END fn_dmv_dsc;
  --
  FUNCTION fn_valid_conn RETURN BOOLEAN IS
  BEGIN
    RETURN TRUE; --pk99$$00.fn_valid_session;
  END fn_valid_conn;
  --
  --
  /* Public Routines */
  --  
  -- Next Row Key
  FUNCTION fn_nxt_key RETURN NUMBER IS
  BEGIN
    RETURN s_99_rk.NEXTVAL;
  END fn_nxt_key;
  --
  -- Current DB Time
  FUNCTION fn_now RETURN TIMESTAMP IS
  BEGIN
    RETURN SYSDATE; -- pk99$$00.fn_sys_dtm;
  END fn_now;
  --
  -- Current APEX User
  FUNCTION fn_crnt_apx_usr RETURN VARCHAR2 IS
  BEGIN
    RETURN pkwf_00_apx.fn_crnt_apx_usr;
  END fn_crnt_apx_usr;
  --
  -- Current APEX Application
  FUNCTION fn_crnt_apx_ap RETURN VARCHAR2 IS
  BEGIN
    RETURN pkwf_00_apx.fn_crnt_apx_ap;
  END fn_crnt_apx_ap;
  --
  -- Current APEX Page
  FUNCTION fn_crnt_apx_pg RETURN VARCHAR2 IS
  BEGIN
    RETURN pkwf_00_apx.fn_crnt_apx_pg;
  END fn_crnt_apx_pg;
  --
  -- Current APEX User Agent
  FUNCTION fn_crnt_apx_ag RETURN VARCHAR2 IS
  BEGIN
   RETURN pkwf_00_apx.fn_crnt_apx_ag;
  END fn_crnt_apx_ag;
  --
  -- Current APEX User IP
  FUNCTION fn_crnt_apx_ip RETURN VARCHAR2 IS
  BEGIN
   RETURN pkwf_00_apx.fn_crnt_apx_ip;
  END fn_crnt_apx_ip;
  --
  -- Counter Number
  FUNCTION fn_c_n (pi_c_n IN NUMBER) RETURN NUMBER IS
    v_c_n NUMBER;
  BEGIN
    v_c_n := NVL(pi_c_n,0) + 1;
    RETURN v_c_n;
  END fn_c_n;
  --
  -- APPR_STAT_DSC
  FUNCTION fn_appr_stat(pi_id IN VARCHAR2) RETURN VARCHAR2 RESULT_CACHE IS
  BEGIN
    RETURN fn_dmv_dsc (pi_dm_id => '00_APPR_STAT', pi_dmv_id => pi_id);
  END fn_appr_stat;
  --
  -- YN columns
  FUNCTION fn_yn(pi_id IN VARCHAR2) RETURN VARCHAR2 RESULT_CACHE IS
  BEGIN
    RETURN fn_dmv_dsc (pi_dm_id => '00_YES_NO', pi_dmv_id => pi_id);
  END fn_yn;
  --
  PROCEDURE pr_commit IS
  BEGIN
    COMMIT;
  END pr_commit;
  --
  PROCEDURE pr_rollback IS
  BEGIN
    ROLLBACK;
  END pr_rollback;
  --
  FUNCTION fn_bus_dt RETURN DATE IS
  BEGIN
    RETURN SYSDATE;--pk99$$00.fn_bus_dt;
  END;
END pkwf_00;
Error report -
Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\package-body\pkwf_00_dsp_body.sql
In command -
CREATE OR REPLACE PACKAGE BODY pkwf_00_dsp AS
  --
  /* Created By       : Kunle Adebona
  ** Date Created     : 03-DEC-2011
  ** Release Version  : 3.0
  **
  ** PURPOSE: Message Display Formatting
  **
  ** MODIFICATION HISTORY:
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **  
  ** Copyright:  ProGenics Corp. Ltd, 2011
  **
  */
  --
  --
  /* Package Variables */
  --
  gv_amt_fmt       VARCHAR2(30) := '999,999,999,999,990.00';
  gv_amt_fmt2       VARCHAR2(30) := '999,999,999,999,990.0000';
  gv_prc_fmt        VARCHAR2(30) := '999,999,999,990.00000';
  gv_qty_fmt        VARCHAR2(30) := '999,999,999,999,990';
  gv_unt_fmt        VARCHAR2(30) := '999,999,999,990.0000';
  gv_untbnd_fmt     VARCHAR2(30) := '999,999,999,990.00000000';
  --
  /* Private Routines */
  --    
  FUNCTION fn_dflt_num (pi_val VARCHAR2) RETURN NUMBER IS
    v_out  NUMBER := NULL;
  BEGIN
    IF pi_val IS NOT NULL THEN
      BEGIN
        v_out := TO_NUMBER(pi_val);
      EXCEPTION
        WHEN OTHERS THEN
          NULL;
      END;
    END IF;
    RETURN v_out;
  END fn_dflt_num;
  --
  --
  /* Public Routines */
  --   
  -- Return new line
  FUNCTION fn_new_line RETURN VARCHAR IS
  BEGIN
    RETURN CHR(13)||CHR(10);
  END fn_new_line;
  --
  -- Format the Quantity Input (Output Format: 999,999,999,999,990 trimming Leading Blanks if so specified)
  FUNCTION fn_fmt_qty (pi_qty NUMBER, pi_trim_yn VARCHAR2 DEFAULT '1') RETURN VARCHAR2 IS
    v_out   VARCHAR2(100) := NULL;
  BEGIN
    --
    IF pi_qty IS NOT NULL THEN 
      IF pi_trim_yn = '1' THEN
        SELECT TO_CHAR(NVL(pi_qty,0),'FM'||gv_qty_fmt) INTO v_out FROM DUAL;
      ELSE
        SELECT TO_CHAR(NVL(pi_qty,0),gv_qty_fmt) INTO v_out FROM DUAL;
      END IF;
    END IF;
    --
    RETURN v_out;
    --
  END fn_fmt_qty;
  --
  -- Format the Amount Input (Output Format: 999,999,999,999,990.99 trimming Leading Blanks if so specified)
  FUNCTION fn_fmt_amt (pi_amt NUMBER, pi_trim_yn VARCHAR2 DEFAULT '1') RETURN VARCHAR2 IS
    v_out   VARCHAR2(100) := NULL;
  BEGIN
    --
    IF pi_amt IS NOT NULL THEN 
      IF pi_trim_yn = '1' THEN
        SELECT TO_CHAR(NVL(pi_amt,0),'FM'||gv_amt_fmt) INTO v_out FROM DUAL;
      ELSE
        SELECT TO_CHAR(NVL(pi_amt,0),gv_amt_fmt) INTO v_out FROM DUAL;
      END IF;
    END IF;
    --
    RETURN v_out;
    --
  END fn_fmt_amt;
  --
  -- Format the Rate Input (Output Format: 999,999.99999% to input decimal places, trimming Leading Blanks if so specified)
  FUNCTION fn_fmt_rt (pi_rt NUMBER, pi_dcml_pls NUMBER DEFAULT 2, pi_trim_yn VARCHAR2 DEFAULT '1') RETURN VARCHAR2 IS
    v_dp    PLS_INTEGER;
    v_rt    NUMBER;
    v_out   VARCHAR2(100) := NULL;
    v_fmt   VARCHAR2(30);
  BEGIN
    --
    IF pi_rt IS NOT NULL THEN
      --
      v_dp := ROUND(pi_dcml_pls);
      IF v_dp <= 0 THEN
        v_dp := 0;
      END IF;
      --
      v_rt := NVL(pi_rt,0);
      v_rt := ROUND(pi_rt,v_dp);
      --
      IF pi_trim_yn = '1' THEN
        v_fmt := 'FM999,990';
      ELSE
        v_fmt := '999,990';
      END IF;
      --
      IF v_dp > 0 THEN
        v_fmt := v_fmt||'.';
        FOR i IN 1..v_dp LOOP
          v_fmt := v_fmt||'0';
        END LOOP;
      END IF;
      --
      SELECT TO_CHAR(v_rt,v_fmt)||'%' INTO v_out FROM DUAL;    
      --
    END IF;
    --
    RETURN v_out;
    --
  END fn_fmt_rt;
  -- 
  --
  -- Format any number Input (Output Format: 999,999.99999 to input decimal places, trimming Leading Blanks if so specified)
  FUNCTION fn_fmt_no (pi_no NUMBER, pi_dcml_pls NUMBER DEFAULT 2, pi_trim_yn VARCHAR2 DEFAULT '1') RETURN VARCHAR2 IS
    v_dp    PLS_INTEGER;
    v_no    NUMBER;
    v_out   VARCHAR2(100) := NULL;
    v_fmt   VARCHAR2(30);
  BEGIN
    --
    IF pi_no IS NOT NULL THEN
      --
      v_dp := ROUND(pi_dcml_pls);
      IF v_dp <= 0 THEN
        v_dp := 0;
      END IF;
      --
      v_no := NVL(pi_no,0);
      v_no := ROUND(pi_no,v_dp);
      --
      IF pi_trim_yn = '1' THEN
        v_fmt := 'FM999,990';
      ELSE
        v_fmt := '999,990';
      END IF;
      --
      IF v_dp > 0 THEN
        v_fmt := v_fmt||'.';
        FOR i IN 1..v_dp LOOP
          v_fmt := v_fmt||'0';
        END LOOP;
      END IF;
      --
      SELECT TO_CHAR(v_no,v_fmt) INTO v_out FROM DUAL;    
      --
    END IF;
    --
    RETURN v_out;
    --
  END fn_fmt_no;
  -- 
  -- Format the Date Input (Output Format: DD-MONTH-YYYY)
  FUNCTION fn_fmt_dt1 (pi_dt DATE) RETURN VARCHAR2 IS
  BEGIN
    IF pi_dt IS NULL THEN
      RETURN NULL;
    ELSE
      RETURN TO_CHAR(pi_dt,'FMDD-MONTH-YYYY');
    END IF;
  END fn_fmt_dt1;
  --
  -- Format the Date Input (Output Format: DD-MON-YYYY)
  FUNCTION fn_fmt_dt2 (pi_dt DATE) RETURN VARCHAR2 IS
  BEGIN
    IF pi_dt IS NULL THEN
      RETURN NULL;
    ELSE
      RETURN TO_CHAR(pi_dt,'DD-MON-YYYY');
    END IF;
  END fn_fmt_dt2;  
  --  
  -- Format the Date Input (Output Format: DD/MM/YYYY)
  FUNCTION fn_fmt_dt3 (pi_dt DATE) RETURN VARCHAR2 IS
  BEGIN
    IF pi_dt IS NULL THEN
      RETURN NULL;
    ELSE
      RETURN TO_CHAR(pi_dt,'DD/MM/YYYY');
    END IF;
  END fn_fmt_dt3;  
  --
  -- Unformat Amount
  FUNCTION fn_unfmt_amt (pi_val IN VARCHAR2) RETURN NUMBER IS
    v_out   NUMBER := NULL;
  BEGIN
    --
    IF pi_val IS NOT NULL THEN 
      SELECT TO_NUMBER(NVL(pi_val,'0'),gv_amt_fmt) INTO v_out FROM DUAL;
    END IF;
    --
    RETURN v_out;
    --
  EXCEPTION
    WHEN OTHERS THEN
      RETURN fn_dflt_num (pi_val);
  END fn_unfmt_amt;
  --
  -- Unformat Quantity
  FUNCTION fn_unfmt_qty (pi_val IN VARCHAR2) RETURN NUMBER IS
    v_out   NUMBER := NULL;
  BEGIN
    --
    IF pi_val IS NOT NULL THEN 
      SELECT TO_NUMBER(NVL(pi_val,'0'),gv_qty_fmt) INTO v_out FROM DUAL;
    END IF;
    --
    RETURN v_out;
    --
  EXCEPTION
    WHEN OTHERS THEN
      RETURN fn_dflt_num (pi_val);
  END fn_unfmt_qty;  
  --
  -- Unformat Rate
  FUNCTION fn_unfmt_rt (pi_val IN VARCHAR2) RETURN NUMBER IS
    v_val   VARCHAR2(100) := NULL;
    v_out   NUMBER := NULL;
  BEGIN
    --
    IF pi_val IS NOT NULL THEN 
      v_val := REPLACE(pi_val,'%');
      SELECT TO_NUMBER(NVL(v_val,'0'),'999,999,990.00000000') INTO v_out FROM DUAL;
    END IF;
    --
    RETURN v_out;
    --
  EXCEPTION
    WHEN OTHERS THEN
      RETURN fn_dflt_num (pi_val);
  END fn_unfmt_rt;  
  --
  -- Unformat Number
  FUNCTION fn_unfmt_no (pi_val IN VARCHAR2) RETURN NUMBER IS
    v_out   NUMBER := NULL;
  BEGIN
    --
    IF pi_val IS NOT NULL THEN 
      SELECT TO_NUMBER(NVL(pi_val,'0'),'999,999,990.00000000') INTO v_out FROM DUAL;
    END IF;
    --
    RETURN v_out;
    --
  EXCEPTION
    WHEN OTHERS THEN
      RETURN fn_dflt_num (pi_val);
  END fn_unfmt_no ;  
  --
  -- Format the Price Input (Output Format: 999,999,999,990.000000 trimming Leading Blanks if so specified)
  FUNCTION fn_fmt_prc (pi_prc NUMBER, pi_trim_yn VARCHAR2 DEFAULT '1') RETURN VARCHAR2 IS
    v_out   VARCHAR2(100) := NULL;
  BEGIN
    --
    IF pi_prc IS NOT NULL THEN 
      IF pi_trim_yn = '1' THEN
        SELECT TO_CHAR(NVL(pi_prc,0),'FM'||gv_prc_fmt) INTO v_out FROM DUAL;
      ELSE
        SELECT TO_CHAR(NVL(pi_prc,0),gv_prc_fmt) INTO v_out FROM DUAL;
      END IF;
    END IF;
    --
    RETURN v_out;
    --
  END fn_fmt_prc;
  --
  -- Unformat Price
  FUNCTION fn_unfmt_prc (pi_val IN VARCHAR2) RETURN NUMBER IS
    v_out   NUMBER := NULL;
  BEGIN
    --
    IF pi_val IS NOT NULL THEN 
      SELECT TO_NUMBER(NVL(pi_val,'0'),gv_prc_fmt) INTO v_out FROM DUAL;
    END IF;
    --
    RETURN v_out;
    --
  EXCEPTION
    WHEN OTHERS THEN
      RETURN fn_dflt_num (pi_val);
  END fn_unfmt_prc;
  --  
  -- Format the Units Input (Output Format: 999,999,999,990.0000 trimming Leading Blanks if so specified)
  FUNCTION fn_fmt_unt (pi_unt NUMBER, pi_trim_yn VARCHAR2 DEFAULT '1') RETURN VARCHAR2 IS
    v_out   VARCHAR2(100) := NULL;
  BEGIN
    --
    IF pi_unt IS NOT NULL THEN 
      IF pi_trim_yn = '1' THEN
        SELECT TO_CHAR(NVL(pi_unt,0),'FM'||gv_unt_fmt) INTO v_out FROM DUAL;
      ELSE
        SELECT TO_CHAR(NVL(pi_unt,0),gv_unt_fmt) INTO v_out FROM DUAL;
      END IF;
    END IF;
    --
    RETURN v_out;
    --
  END fn_fmt_unt;
  --
  -- Unformat Units
  FUNCTION fn_unfmt_unt (pi_val IN VARCHAR2) RETURN NUMBER IS
    v_out   NUMBER := NULL;
  BEGIN
    --
    IF pi_val IS NOT NULL THEN 
      SELECT TO_NUMBER(NVL(pi_val,'0'),gv_unt_fmt) INTO v_out FROM DUAL;
    END IF;
    --
    RETURN v_out;
    --
  EXCEPTION
    WHEN OTHERS THEN
      RETURN fn_dflt_num (pi_val);
  END fn_unfmt_unt;
  --    
  -- Format the Bonds Units Input (Output Format: 999,999,999,990.00000000 trimming Leading Blanks if so specified)
  FUNCTION fn_fmt_untbnd (pi_unt NUMBER, pi_trim_yn VARCHAR2 DEFAULT '1') RETURN VARCHAR2 IS
    v_out   VARCHAR2(100) := NULL;
  BEGIN
    --
    IF pi_unt IS NOT NULL THEN 
      IF pi_trim_yn = '1' THEN
        SELECT TO_CHAR(NVL(pi_unt,0),'FM'||gv_untbnd_fmt) INTO v_out FROM DUAL;
      ELSE
        SELECT TO_CHAR(NVL(pi_unt,0),gv_untbnd_fmt) INTO v_out FROM DUAL;
      END IF;
    END IF;
    --
    RETURN v_out;
    --
  END fn_fmt_untbnd;
  --
  -- Unformat Units
  FUNCTION fn_unfmt_untbnd (pi_val IN VARCHAR2) RETURN NUMBER IS
    v_out   NUMBER := NULL;
  BEGIN
    --
    IF pi_val IS NOT NULL THEN 
      SELECT TO_NUMBER(NVL(pi_val,'0'),gv_untbnd_fmt) INTO v_out FROM DUAL;
    END IF;
    --
    RETURN v_out;
    --
  EXCEPTION
    WHEN OTHERS THEN
      RETURN fn_dflt_num (pi_val);
  END fn_unfmt_untbnd;
  --  
  -- Converts Integer to Word
  FUNCTION fn_int_in_word (pi_int IN NUMBER) RETURN VARCHAR2 IS
    v_desc VARCHAR2(4000);
    v_int  NUMBER := ABS(TRUNC(NVL(pi_int,0)));
  BEGIN
    IF v_int > 1000000000000 THEN -- MUST NOT BE GREATER THAN ONE TRILLION
      v_desc := 'Cannot Convert Value Exceeding 1,000,000,000,000';
    ELSIF v_int = 0 THEN
      v_desc := 'ZERO';
    ELSE
      IF v_int = 1000000000000 THEN
        v_desc := 'ONE TRILLION';
      ELSE
        SELECT
          decode(v_int, 0, '',
          decode(trunc(v_int/1000000000),0,'',
          decode(greatest(trunc(v_int/1000000000),99),
          99,to_char(to_date(trunc(v_int/1000000000),'J'),'JSP'),
          to_char(to_date(trunc(trunc(v_int/1000000000)/100),'J'),'JSP')||
          decode(mod(trunc(v_int/1000000000),100),0,' HUNDRED',' HUNDRED AND '||
          to_char(to_date(mod(trunc(v_int/1000000000),100),'J'),'JSP') ) )||
          decode( mod(v_int,1000000000),0,' BILLION',
          decode( greatest(mod(v_int,1000000000),99),99,' BILLION AND ',' BILLION, ') ) )||
          decode( trunc(mod(v_int,1000000000)/1000000),0,'',
          decode( greatest(trunc(mod(v_int,1000000000)/1000000),99),
          99,to_char(to_date(trunc(mod(v_int,1000000000)/1000000),'J'),'JSP'),
          to_char(to_date(trunc(trunc(mod(v_int,1000000000)/1000000)/100),'J'),'JSP')||
          decode( mod(trunc(mod(v_int,1000000000)/1000000),100),0,' HUNDRED',' HUNDRED AND '||
          to_char(to_date(mod(trunc(mod(v_int,1000000000)/1000000),100),'J'),'JSP') ) )||
          decode( trunc(mod(mod(v_int,1000000000),1000000)),0,' MILLION',
          decode( greatest(trunc(mod(mod(v_int,1000000000),1000000)),99),
          99,' MILLION AND ',' MILLION, ' ) ) )||
          decode( trunc(mod(v_int,1000000)/1000),0,'',
          decode( greatest(trunc(mod(v_int,1000000)/1000),99),
          99,to_char(to_date(trunc(mod(v_int,1000000)/1000),'J'),'JSP'),
          to_char(to_date(trunc(trunc(mod(v_int,1000000)/1000)/100),'J'),'JSP')||
          decode( mod(trunc(mod(v_int,1000000)/1000),100),0,' HUNDRED',' HUNDRED AND '||
          to_char(to_date(mod(trunc(mod(v_int,1000000)/1000),100),'J'),'JSP') ) )||
          decode( trunc(mod(mod(v_int,1000000),1000)),0,' THOUSAND',
          decode( greatest(trunc(mod(mod(v_int,1000000),1000)),99),
          99,' THOUSAND AND ',' THOUSAND, ' ) ) )||
          decode( greatest(trunc(mod(v_int,1000)),99),
          99,decode( trunc(mod(v_int,1000)),0,'',
          to_char(to_date(trunc(mod(v_int,1000)),'J'),'JSP') ),
          decode( trunc(trunc(mod(v_int,1000))/100),0,'',
          decode( greatest(trunc(mod(v_int,1000)),99),
          99,to_char(to_date(trunc(mod(v_int,1000)),'J'),'JSP'),
          to_char(to_date(trunc(trunc(mod(v_int,1000))/100),'J'),'JSP')||
          decode( trunc(mod(trunc(mod(v_int,1000)),100)),0,' HUNDRED ',' HUNDRED AND '||
          to_char(to_date(mod(trunc(mod(v_int,1000)),100),'J'),'JSP') ) ) ) ) )
        INTO v_desc
        FROM DUAL;
      END IF;
      --
      IF pi_int < 0 THEN
        v_desc := 'MINUS '||v_desc;
      END IF;
      --
    END IF;
    --
    RETURN v_desc;
    --
  END fn_int_in_word;
  --    
  --  
  FUNCTION fn_amt_in_word (pi_amt IN NUMBER, pi_curr_id IN VARCHAR2) RETURN VARCHAR2 IS
    --
    v_desc              VARCHAR2(2000);
    v_basic_unit_name   VARCHAR2(100);
    v_subdivision_name  VARCHAR2(100);
    --
    v_amt   NUMBER := NVL(pi_amt,0);
    v_num   NUMBER;
    --
  BEGIN
    --          
    IF ABS(v_amt) > 1000000000000 THEN -- MUST NOT BE GREATER THAN ONE TRILLION
      v_desc := 'Cannot Convert Amount Exceeding 1,000,000,000,000.00';
    ELSE      
      --
      v_basic_unit_name := 'NAIRA';
      v_subdivision_name := 'KOBO';
      --
      IF pi_curr_id IS NOT NULL THEN
        BEGIN
          SELECT UPPER(NVL(unt_dsc,'*****')), UPPER(NVL(sunt_dsc,'*****'))
            INTO v_basic_unit_name, v_subdivision_name
            FROM v_99_$$_lst_cur
           WHERE UPPER(cur_id) = UPPER(pi_curr_id);
        EXCEPTION
          WHEN OTHERS THEN  
            v_basic_unit_name := '*****';
            v_subdivision_name := '*****';
        END;
      END IF;
      --
      IF v_amt = 0 THEN
        v_desc := 'ZERO '||v_basic_unit_name||' ONLY';
      ELSIF v_amt = 1000000000000 THEN
        v_desc := 'ONE TRILLION '||v_basic_unit_name||' ONLY';
      ELSE
        -- Quotient 
        v_num := ABS(TRUNC(v_amt));
        IF v_num > 0 THEN
          v_desc := fn_int_in_word(v_num);
        ELSE
          v_desc := 'ZERO';
        END IF;
        v_desc := v_desc||' '||v_basic_unit_name;
        -- Mantissa
        v_num := ABS(ROUND(MOD(v_amt,1),2)*100);
        IF v_num = 0 THEN
          v_desc := v_desc||' ONLY';
        ELSE
          v_desc := v_desc||' '||fn_int_in_word(v_num)||' '||v_subdivision_name||' ONLY';
        END IF;
      END IF;
      --
      IF v_amt < 0 THEN
        v_desc := 'MINUS '||v_desc;
      END IF;      
      --
    END IF;
    --
    RETURN v_desc;
    --
  END fn_amt_in_word;  
  --
  --      
END pkwf_00_dsp;
Error report -
Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\package-body\pkwf_00_flx_body.sql
In command -
CREATE OR REPLACE PACKAGE BODY pkwf_00_flx AS
  --
  /* Created By       : Femi Akintoye
  ** Date Created     : 08-MAR-2016
  ** Release Version  : 2.0
  **
  ** PURPOSE: Flex Field Management
  **
  ** MODIFICATION HISTORY:
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  ** Copyright:  Neulogic Solutions Ltd, 2016
  **
  */
  /* Package Variables */
  --
  /* Public Routines */
  --
  --
  --
  FUNCTION fn_g_defn (pi_tk_k IN VARCHAR2,
                      pi_c_no IN NUMBER) RETURN r_flx IS
    --
    v_r    wf_10_tp_tk%ROWTYPE;
    r_rec  r_flx;
    --
  BEGIN
    BEGIN
      SELECT *
        INTO v_r
        FROM wf_10_tp_tk
       WHERE row_key = pi_tk_k;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN NULL;
      WHEN TOO_MANY_ROWS THEN NULL;
    END;
    --
    IF pi_c_no = 1 THEN
      r_rec.ius_yn  := v_r.p1_iu_yn;
      r_rec.mnd_yn  := NVL(v_r.p1_mnd_yn,'0');
      r_rec.col_nm  := v_r.p1_dsc;
      r_rec.col_tp  := v_r.p1_tp_dm;
    ELSIF pi_c_no = 2 THEN
      r_rec.ius_yn  := v_r.p2_iu_yn;
      r_rec.mnd_yn  := NVL(v_r.p2_mnd_yn,'0');
      r_rec.col_nm  := v_r.p2_dsc;
      r_rec.col_tp  := v_r.p2_tp_dm;
    ELSIF pi_c_no = 3 THEN
      r_rec.ius_yn  := v_r.p3_iu_yn;
      r_rec.mnd_yn  := NVL(v_r.p3_mnd_yn,'0');
      r_rec.col_nm  := v_r.p3_dsc;
      r_rec.col_tp  := v_r.p3_tp_dm;
    ELSIF pi_c_no = 4 THEN
      r_rec.ius_yn  := v_r.p4_iu_yn;
      r_rec.mnd_yn  := NVL(v_r.p4_mnd_yn,'0');
      r_rec.col_nm  := v_r.p4_dsc;
      r_rec.col_tp  := v_r.p4_tp_dm;
    ELSIF pi_c_no = 5 THEN
      r_rec.ius_yn  := v_r.p5_iu_yn;
      r_rec.mnd_yn  := NVL(v_r.p5_mnd_yn,'0');
      r_rec.col_nm  := v_r.p5_dsc;
      r_rec.col_tp  := v_r.p5_tp_dm;
    ELSE
      pkwf_00_00_err.pr_raise(pi_msg => 'Invalid X-Field Definition ['||pi_c_no||']');      
    END IF;
    --
    RETURN r_rec;
    --
  END fn_g_defn;
  --
  /**
    * Returns a boolean that determines if the task uses parameters or not
    * @param pi_tk_k Task Name
  */  
  FUNCTION fn_use_par (pi_tk_k IN VARCHAR2) RETURN BOOLEAN IS
  BEGIN
    RETURN TRUE;
  END fn_use_par;
  --
  /**
    * Returns a boolean that determines if the field should be displayed or not
    * @param pi_tk_k Task Name
    * @param pi_c_no Column Number
  */  
  FUNCTION fn_is_vis (pi_tk_k IN VARCHAR2,
                      pi_c_no IN NUMBER) RETURN BOOLEAN IS
    --
    r_rec   r_flx;
    v_ret   BOOLEAN := FALSE;
    --
  BEGIN
    --
    r_rec := fn_g_defn(pi_tk_k => pi_tk_k,
                       pi_c_no => pi_c_no);
    --
    IF r_rec.ius_yn = '1' THEN
      v_ret := TRUE;
    END IF;
    --
    RETURN v_ret;
    --
  END fn_is_vis;
  /**
    * Returns Coloumn Description
    * @param pi_tk_k Table Name
    * @param pi_c_no Column Number
  */
  --
  FUNCTION fn_g_col_dsc (pi_tk_k IN VARCHAR2,
                         pi_c_no IN NUMBER) RETURN VARCHAR2 IS
    --
    r_rec   r_flx;
    v_nm    wf_00_00_dtd.c50%TYPE;
    --
  BEGIN
    --
    r_rec := fn_g_defn(pi_tk_k => pi_tk_k,
                       pi_c_no => pi_c_no);
    --
    IF r_rec.ius_yn = '1' THEN
      v_nm := NVL(r_rec.col_nm, 'Undefined');
    END IF;
    --
    RETURN v_nm;
    --
  END fn_g_col_dsc;
  --
  /**
    * Procedure to validate that the data passed in meets definition
    * @param pi_key Customer key
  */
  PROCEDURE pr_v_data (pi_tk_k IN VARCHAR2,
                       pi_c_no IN NUMBER,
                       pi_data IN VARCHAR2) IS
    --
    r_rec   r_flx;
    v_nm    wf_00_00_dtd.c50%TYPE;
    v_dt    wf_00_00_dtd.dt%TYPE;
    v_no    wf_00_00_dtd.n2812%TYPE;
    --
  BEGIN
    --
    r_rec := fn_g_defn(pi_tk_k => pi_tk_k,
                       pi_c_no => pi_c_no);
    --
    IF r_rec.ius_yn = '1' THEN
      IF r_rec.col_tp = 'D' THEN
        BEGIN
          v_dt := TO_DATE(pi_data);
        EXCEPTION
          WHEN OTHERS THEN
            pkwf_00_00_err.pr_raise(pi_msg => 'Invalid Date Data ['||pi_data||']');
        END;
      ELSIF r_rec.col_tp = 'N' THEN
        BEGIN
          v_no := TO_NUMBER(REPLACE(pi_data, ',', ''));
        EXCEPTION
          WHEN OTHERS THEN
            pkwf_00_00_err.pr_raise(pi_msg => 'Invalid Number Data ['||pi_data||']');
        END;
      END IF;
      --
      IF r_rec.mnd_yn = '1' THEN
        pkwf_00_vld.pr_reqd(pi_d => pi_data, pi_dsc => r_rec.col_nm);
      END IF;
      --
    END IF;
    --   
  END pr_v_data;
  --  
  --    
END pkwf_00_flx;
Error report -
Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\package-body\pkwf_00_jsn_body.sql
In command -
CREATE OR REPLACE PACKAGE BODY pkwf_00_jsn AS
  --
  /* Created By       : Aderemi Alabi 
  ** Date Created     : 09-APR-2016
  **
  ** PURPOSE: WF Routines for JSON
  **
  ** MODIFICATION HISTORY:
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **  
  ** Copyright:  Neulogic Solutions Ltd, 2016
  **
  */
  --
   /* Package Variables */
  -- 
  pv_ls logger_logs.scope%type := $$plsql_unit;
  --pv_lp logger.tab_param;
  --
  /* Private Routines */
  --  
  --
  /* Public Routines */
  -- 
  -- 
  FUNCTION fn_new_customer(pi_doc IN CLOB) RETURN CLOB IS
    v_json   CLOB;
    v_rec    wf_vi_30_cs_new%ROWTYPE;
    v_return CLOB;
    v_resp   pkwf_90_gen.r_ret;
  BEGIN
    pv_ls := pv_ls || '.fn_new_customer';
    logger.log('JSON received', pv_ls, 'JSON Object => '||pi_doc);
    apex_json.initialize_clob_output;    
    v_json := pi_doc;
    IF v_json IS NOT NULL THEN
      BEGIN        
        apex_json.parse(v_json);
        logger.log('JSON parsed', pv_ls, NULL);
      EXCEPTION
        WHEN OTHERS THEN
           logger.log_error('exception', pv_ls, dbms_utility.format_error_stack ||'|'||
                                          dbms_utility.format_error_backtrace);
          apex_json.open_object();
          apex_json.write('Response', '000');      
          apex_json.write('Error', 'Poorly formatted document'); 
          apex_json.write('Status', '.'); 
          apex_json.close_object;
          v_return := apex_json.get_clob_output;
          RETURN v_return;
      END;
    END IF;
    --
    v_rec.row_key      := 0;
    v_rec.tt_dm        := apex_json.get_varchar2(p_path => 'title');
    v_rec.ls_nm        := apex_json.get_varchar2(p_path => 'lastname');
    v_rec.md_nm        := apex_json.get_varchar2(p_path => 'othernames');
    v_rec.fi_nm        := apex_json.get_varchar2(p_path => 'firstname');
    v_rec.gdr_dm       := apex_json.get_varchar2(p_path => 'gender');
    v_rec.dob_dt       := apex_json.get_date(p_path => 'birthdate');
    v_rec.mar_st_dm    := apex_json.get_varchar2(p_path => 'maritalstatus');
    v_rec.nty_cd       := apex_json.get_varchar2(p_path => 'nationality');
    v_rec.pry_a_ad1    := apex_json.get_varchar2(p_path => 'raddress1');
    v_rec.pry_a_ad2    := apex_json.get_varchar2(p_path => 'raddress2');
    v_rec.pry_a_cty    := apex_json.get_varchar2(p_path => 'rcity');
    v_rec.pry_a_sta_cd := apex_json.get_varchar2(p_path => 'rstate');
    v_rec.pry_a_zip    := apex_json.get_varchar2(p_path => 'rzip');
    v_rec.pry_a_ctr_cd := apex_json.get_varchar2(p_path => 'rcountry');
    v_rec.pst_a_ad1    := apex_json.get_varchar2(p_path => 'paddress1');
    v_rec.pst_a_ad2    := apex_json.get_varchar2(p_path => 'paddress2');
    v_rec.pst_a_cty    := apex_json.get_varchar2(p_path => 'pcity');
    v_rec.pst_a_sta_cd := apex_json.get_varchar2(p_path => 'pstate');
    v_rec.pst_a_zip    := apex_json.get_varchar2(p_path => 'pzip');
    v_rec.pst_a_ctr_cd := apex_json.get_varchar2(p_path => 'pcountry');
    v_rec.pry_em_ad    := apex_json.get_varchar2(p_path => 'email1');
    v_rec.sec_em_ad    := apex_json.get_varchar2(p_path => 'email2');
    v_rec.mbl_phn      := apex_json.get_varchar2(p_path => 'phone1');
    v_rec.oth_phn      := apex_json.get_varchar2(p_path => 'phone2');
    v_rec.mmd_nm       := apex_json.get_varchar2(p_path => 'mmaidenname');
    v_rec.nok_nm       := apex_json.get_varchar2(p_path => 'nokname');
    v_rec.nok_phn      := apex_json.get_varchar2(p_path => 'nokphone');
    v_rec.nok_a_ad1    := apex_json.get_varchar2(p_path => 'naddress1');
    v_rec.nok_a_ad2    := apex_json.get_varchar2(p_path => 'naddress2');
    v_rec.nok_a_cty    := apex_json.get_varchar2(p_path => 'ncity');
    v_rec.nok_a_sta_cd := apex_json.get_varchar2(p_path => 'nstate');
    v_rec.nok_a_zip    := apex_json.get_varchar2(p_path => 'nzip');
    v_rec.nok_a_ctr_cd := apex_json.get_varchar2(p_path => 'ncountry');
    v_rec.bk_nm        := apex_json.get_varchar2(p_path => 'bankname');
    v_rec.bk_ac_no     := apex_json.get_varchar2(p_path => 'account');
    v_rec.bk_bv_no     := apex_json.get_varchar2(p_path => 'bvn');
    v_rec.bk_ac_nm     := apex_json.get_varchar2(p_path => 'accountname');
    v_rec.bk_br_nm     := apex_json.get_varchar2(p_path => 'bankbranch');
    v_rec.bk_st_cd     := apex_json.get_varchar2(p_path => 'sortcode');
    v_rec.bk_a_ad1     := apex_json.get_varchar2(p_path => 'baddress1');
    v_rec.bk_a_ad2     := apex_json.get_varchar2(p_path => 'baddress2');
    v_rec.bk_a_cty     := apex_json.get_varchar2(p_path => 'bcity');
    v_rec.bk_a_sta_cd  := apex_json.get_varchar2(p_path => 'bstate');
    v_rec.bk_a_zip     := apex_json.get_varchar2(p_path => 'bzip');
    v_rec.bk_a_ctr_cd  := apex_json.get_varchar2(p_path => 'bcountry');
    v_rec.ocp_nm       := apex_json.get_varchar2(p_path => 'occupation');
    v_rec.emp_nm       := apex_json.get_varchar2(p_path => 'employer');
    v_rec.emp_a_ad1    := apex_json.get_varchar2(p_path => 'eaddress1');
    v_rec.emp_a_ad2    := apex_json.get_varchar2(p_path => 'eaddress2');
    v_rec.emp_a_cty    := apex_json.get_varchar2(p_path => 'ecity');
    v_rec.emp_a_sta_cd := apex_json.get_varchar2(p_path => 'estate');
    v_rec.emp_a_zip    := apex_json.get_varchar2(p_path => 'ezip');
    v_rec.emp_a_ctr_cd := apex_json.get_varchar2(p_path => 'ecountry');
    v_rec.emp_phn      := apex_json.get_varchar2(p_path => 'ephone');
    v_rec.ann_inc_amt  := NVL(apex_json.get_number(p_path => 'income'),0);
    v_rec.c_pic_yn     := apex_json.get_varchar2(p_path => 'haspix');
    v_rec.c_sig_yn     := apex_json.get_varchar2(p_path => 'hassig');
    v_rec.c_ubl_yn     := apex_json.get_varchar2(p_path => 'hasbill');
    v_rec.c_idc_yn     := apex_json.get_varchar2(p_path => 'hasid');
    --
    BEGIN
      v_resp := pkwf_90_gen.fn_01_cus_ins(v_rec);
      logger.log('WF-90-GEN', pv_ls, 'Response => '||v_resp.ret_cd);
      logger.log('WF-90-GEN', pv_ls, 'Key => '||v_resp.po_dc_k);
      logger.log('WF-90-GEN', pv_ls, 'Error => '||v_resp.err_dsc);
      logger.log('WF-90-GEN', pv_ls, 'Status => '||v_resp.err_sta);
    EXCEPTION  
      WHEN OTHERS THEN
        logger.log_error('exception', pv_ls, dbms_utility.format_error_stack ||'|'||
                                          dbms_utility.format_error_backtrace);
        v_resp.ret_cd  := '000';
        v_resp.err_dsc := 'Application Error';
        v_resp.err_sta := dbms_utility.format_error_stack ||chr(13)||chr(10) ||
                          dbms_utility.format_error_backtrace;
    END;                      
    --
    apex_json.initialize_clob_output;
    apex_json.open_object();
    apex_json.write('Response', v_resp.ret_cd);      
    apex_json.write('Key',      v_resp.po_dc_k); 
    apex_json.write('Error',    v_resp.err_dsc); 
    apex_json.write('Status',   v_resp.err_sta); 
    apex_json.close_object;
    --
    v_return := apex_json.get_clob_output;
    RETURN v_return;
    --
  END fn_new_customer;  
  --
  --
  FUNCTION fn_web_access(pi_doc IN CLOB) RETURN CLOB IS
    v_json   CLOB;
    v_rec    wf_vi_30_cs_reg%ROWTYPE;
    v_return CLOB;
    v_resp   pkwf_90_gen.r_ret;
  BEGIN
    pv_ls := pv_ls || '.fn_web_access';
    logger.log('JSON received', pv_ls, 'JSON Object => '||pi_doc);
    apex_json.initialize_clob_output;
    v_json := pi_doc;
    IF v_json IS NOT NULL THEN
      BEGIN
        apex_json.parse(v_json);
        logger.log('JSON parsed', pv_ls, NULL);
      EXCEPTION
        WHEN OTHERS THEN
          logger.log_error('exception', pv_ls, dbms_utility.format_error_stack ||'|'||
                                          dbms_utility.format_error_backtrace);
          apex_json.open_object();
          apex_json.write('Response', '000');      
          apex_json.write('Key', 0);      
          apex_json.write('Error', 'Poorly formatted document'); 
          apex_json.write('Status', '.'); 
          apex_json.close_object;
          v_return := apex_json.get_clob_output;
          RETURN v_return;
      END;
    END IF;
    --
    v_rec.row_key      := 0;
    v_rec.mk_ac_id    := apex_json.get_varchar2(p_path => 'cscsaccount');
    v_rec.ac_nm       := apex_json.get_varchar2(p_path => 'accountname');
    v_rec.dob_dt      := apex_json.get_date(p_path => 'birthdate');
    v_rec.pry_em_ad   := apex_json.get_varchar2(p_path => 'email');
    v_rec.mbl_phn     := apex_json.get_varchar2(p_path => 'mobilephone');
    --
    BEGIN
      v_resp := pkwf_90_gen.fn_02_reg_ins(v_rec);
      logger.log('WF-90-GEN', pv_ls, 'Response => '||v_resp.ret_cd);
      logger.log('WF-90-GEN', pv_ls, 'Key => '||v_resp.po_dc_k);
      logger.log('WF-90-GEN', pv_ls, 'Error => '||v_resp.err_dsc);
      logger.log('WF-90-GEN', pv_ls, 'Status => '||v_resp.err_sta);
    EXCEPTION  
      WHEN OTHERS THEN
        logger.log_error('exception', pv_ls, dbms_utility.format_error_stack ||'|'||
                                          dbms_utility.format_error_backtrace);
        v_resp.ret_cd  := '000';
        v_resp.err_dsc := 'Application Error';
        v_resp.err_sta := dbms_utility.format_error_stack ||chr(13)||chr(10) ||
                          dbms_utility.format_error_backtrace;
    END;                      
    --
    apex_json.initialize_clob_output;
    apex_json.open_object();
    apex_json.write('Response', v_resp.ret_cd);      
    apex_json.write('Key',      v_resp.po_dc_k);     
    apex_json.write('Error',    v_resp.err_dsc); 
    apex_json.write('Status',   v_resp.err_sta); 
    apex_json.close_object;
    v_return := apex_json.get_clob_output;
    RETURN v_return;
    --
  END fn_web_access; 
  --
  --
  FUNCTION fn_cash_withdraw(pi_doc IN CLOB) RETURN CLOB IS
    v_json   CLOB;
    v_rec    wf_vi_30_ch_wdr%ROWTYPE;
    v_return CLOB;
    v_resp   pkwf_90_gen.r_ret;
  BEGIN
    apex_json.initialize_clob_output;
    v_json := pi_doc;
    IF v_json IS NOT NULL THEN
      BEGIN
        apex_json.parse(v_json);
      EXCEPTION
        WHEN OTHERS THEN
          apex_json.open_object();
          apex_json.write('Response', '000');      
          apex_json.write('Key', 0);      
          apex_json.write('Error', 'Poorly formatted document'); 
          apex_json.write('Status', '.'); 
          apex_json.close_object;
          v_return := apex_json.get_clob_output;
          RETURN v_return;
      END;
    END IF;
    --
    v_rec.row_key      := 0;
    v_rec.ac_id       := apex_json.get_varchar2(p_path => 'accountnumber');
    v_rec.pm_bk_id    := 'FCMB';
    v_rec.pm_bk_ac_no := '00';
    v_rec.wdr_amt     := apex_json.get_number(p_path => 'amount');
    --
    --
    BEGIN
      v_resp := pkwf_90_gen.fn_03_wdr_ins(v_rec);
    EXCEPTION  
      WHEN OTHERS THEN
        v_resp.ret_cd  := '000';
        v_resp.err_dsc := 'Application Error';
        v_resp.err_sta := dbms_utility.format_error_stack ||chr(13)||chr(10) ||
                          dbms_utility.format_error_backtrace;
    END;                      
    --
    apex_json.initialize_clob_output;
    apex_json.open_object();
    apex_json.write('Response', v_resp.ret_cd);      
    apex_json.write('Key',      v_resp.po_dc_k);     
    apex_json.write('Error',    v_resp.err_dsc); 
    apex_json.write('Status',   v_resp.err_sta); 
    apex_json.close_object;
    --
    v_return := apex_json.get_clob_output;
    RETURN v_return;
    --
  END fn_cash_withdraw;  
  --
END pkwf_00_jsn; 
Error report -
Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\package-body\pkwf_00_pdf_body.sql
In command -
CREATE OR REPLACE PACKAGE BODY pkwf_00_pdf AS
  --
  /* Created By       : Aderemi Alabi 
  ** Date Created     : 19-MAR-2016
  **
  ** PURPOSE: WF PDF Management
  **
  ** MODIFICATION HISTORY:
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **  
  ** Copyright:  Neulogic Solutions Ltd, 2016
  **
  */
  --
  /* Private Routines */
  --
  /* Public Routines */
  --
  --
  PROCEDURE pr_get_pdf IS
    --
    v_mime  VARCHAR2(48) := 'application/pdf'; --'application/octet'  
    v_len   NUMBER;  
    v_file  VARCHAR2(2000);  
    v_blob  BLOB; 
    --
    CURSOR c_blob IS
      SELECT  file_name, pdf_file, DBMS_LOB.GETLENGTH(pdf_file) 
      FROM    wf_00_pdf;
    --  
  BEGIN
    --
    OPEN  c_blob;
    FETCH c_blob INTO v_file, v_blob, v_len;
    CLOSE c_blob;
    --
    owa_util.mime_header(v_mime, FALSE);
    htp.p('Content-length: ' || v_len);
    htp.p('Content-Disposition:  inline; filename="'||
             replace(replace(substr
                 (v_file,instr(v_file,'/')+1),chr(10),null),
                 chr(13),null)|| '"');  
    owa_util.http_header_close;
    wpg_docload.download_file(v_blob); 
    --         
  END pr_get_pdf;
  --
END pkwf_00_pdf; 
Error report -
Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\package-body\pkwf_00_pmr_body.sql
In command -
CREATE OR REPLACE PACKAGE BODY pkwf_00_pmr AS
  --
  /* Created By       : Kunle Adebona
  ** Date Created     : 06-SEP-2012
  ** Release Version  : 2.0
  **
  ** PURPOSE: Operating Parameters
  **
  ** MODIFICATION HISTORY:
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **  
  **
  */
  --
  /* Private Routines */
  --
  --
  FUNCTION fn_get_pmr_bool (pi_id VARCHAR2) RETURN BOOLEAN IS
    v_v  wf_00_00_pvl.bln_val%TYPE;
    CURSOR cur_pmv_b IS
    SELECT A.bln_val
    FROM wf_00_00_pvl A
    WHERE A.pmr_id = pi_id
    AND   A.tp_dm = 'B';
  BEGIN
    v_v := NULL;
    OPEN cur_pmv_b;
    FETCH cur_pmv_b INTO v_v;
    CLOSE cur_pmv_b;     
    IF v_v = 1 THEN    
      RETURN TRUE;
    ELSIF v_v = 0 THEN
      RETURN FALSE;
    ELSE -- DEFAULT=FALSE
      RETURN FALSE;
    END IF;
  END fn_get_pmr_bool;
  --
  FUNCTION fn_get_pmr_char (pi_id VARCHAR2) RETURN VARCHAR2 IS
    v_v  wf_00_00_pvl.chr_val%TYPE;
    CURSOR cur_pmv_c IS
    SELECT A.chr_val
    FROM wf_00_00_pvl A
    WHERE A.pmr_id = pi_id
    AND   A.tp_dm = 'C';
  BEGIN
    v_v := NULL;
    OPEN cur_pmv_c;
    FETCH cur_pmv_c INTO v_v;
    CLOSE cur_pmv_c;     
    RETURN v_v;
  END fn_get_pmr_char;
  --  
  FUNCTION fn_get_pmr_num (pi_id VARCHAR2) RETURN NUMBER IS
    v_v  wf_00_00_pvl.nbr_val%TYPE;
    CURSOR cur_pmv_n IS
    SELECT A.nbr_val
    FROM wf_00_00_pvl A
    WHERE A.pmr_id = pi_id
    AND   A.tp_dm = 'N';
  BEGIN
    v_v := NULL;
    OPEN cur_pmv_n;
    FETCH cur_pmv_n INTO v_v;
    CLOSE cur_pmv_n;     
    RETURN v_v;
  END fn_get_pmr_num;
  --  
  FUNCTION fn_get_pmr_dt (pi_id VARCHAR2) RETURN DATE IS
    v_v  wf_00_00_pvl.dt_val%TYPE;
    CURSOR cur_pmv_d IS
    SELECT A.dt_val
    FROM wf_00_00_pvl A
    WHERE A.pmr_id = pi_id
    AND   A.tp_dm = 'D';
  BEGIN
    v_v := NULL;
    OPEN cur_pmv_d;
    FETCH cur_pmv_d INTO v_v;
    CLOSE cur_pmv_d;     
    RETURN v_v;
  END fn_get_pmr_dt;
  --      
  --    
  /* Public Routines */
  --  
  --
  -- Yes if using remote users
  FUNCTION fn_rmt_usr_only RETURN BOOLEAN IS
  BEGIN
    RETURN fn_get_pmr_bool (pi_id => 'WF_USC');
  END fn_rmt_usr_only;
  --
  -- Returns TRUE if remote users are allowed
  FUNCTION fn_alw_rmt_usr RETURN BOOLEAN IS
  BEGIN
    RETURN fn_get_pmr_bool (pi_id => 'WF_ALW_RMT');
  END fn_alw_rmt_usr;
  -- 
  -- Returns TRUE if remote users are allowed
  FUNCTION fn_alw_lcl_usr RETURN BOOLEAN IS
  BEGIN
    RETURN fn_get_pmr_bool (pi_id => 'WF_ALW_LCL');
  END fn_alw_lcl_usr;
  -- 
  -- Returns default email from address
  FUNCTION fn_eml_frm_adr RETURN VARCHAR2 IS
  BEGIN
    RETURN fn_get_pmr_char (pi_id => 'EML_FRM_ADR');
  END fn_eml_frm_adr;
  --
  -- Returns default page auto refresh time
  FUNCTION fn_pg_rfrsh RETURN NUMBER IS
  BEGIN
    RETURN fn_get_pmr_num (pi_id => 'WF_RFH_TM');
  END fn_pg_rfrsh;
  --   
  --
END pkwf_00_pmr;
Error report -
Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\package-body\pkwf_00_vld_body.sql
In command -
CREATE OR REPLACE PACKAGE BODY pkwf_00_vld AS 
  --
  --
  /* Created By       : Chiedu Okeleke 
  ** Date Created     : 11-FEB-2016
  ** Release Version  : 3.0
  **
  ** PURPOSE: General Validation routines
  **
  ** MODIFICATION HISTORY:
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **  
  ** Copyright:  Neulogic Solutions Ltd, 2016
  **
  */
  --
  -- Package variables
  gv_k          VARCHAR2(100);
  --
  PROCEDURE pr_load_gvs IS
  BEGIN
    SELECT SYS_CONTEXT ('USERENV', 'SESSIONID') ||
           SYS_CONTEXT ('USERENV', 'LANGUAGE') ||
           SYS_CONTEXT ('USERENV', 'SESSION_USER') ||           
           SYS_CONTEXT ('USERENV', 'NLS_DATE_FORMAT')     
    INTO gv_k
    FROM dual;
  END pr_load_gvs;
  --
  --
  /* Public Routines */
  --
  --
  PROCEDURE pr_reqd (pi_d IN VARCHAR2, pi_dsc IN VARCHAR2) IS
  BEGIN
    IF pi_d IS NULL THEN
      pkwf_00_00_err.pr_raise (pi_id => '000010', pi_p1 => NVL(pi_dsc,'Value'));
    END IF;
  END pr_reqd;
  --
  PROCEDURE pr_reqd (pi_d IN NUMBER, pi_dsc IN VARCHAR2) IS
  BEGIN
    IF pi_d IS NULL THEN
      pkwf_00_00_err.pr_raise (pi_id => '000010', pi_p1 => NVL(pi_dsc,'Number'));
    END IF;
  END pr_reqd;
  --
  PROCEDURE pr_reqd (pi_d IN DATE, pi_dsc IN VARCHAR2) IS
  BEGIN
    IF pi_d IS NULL THEN
      pkwf_00_00_err.pr_raise (pi_id => '000010', pi_p1 => NVL(pi_dsc,'Date'));
    END IF;
  END pr_reqd;
  --
  PROCEDURE pr_above_zero (pi_d NUMBER, pi_dsc VARCHAR2) IS
  BEGIN
    IF NVL(pi_d,0) <= 0 THEN 
      pkwf_00_00_err.pr_raise (pi_id => '000012', pi_p1 => NVL(pi_dsc,'Number')||' ['||pi_d||']');
    END IF;
  END pr_above_zero;
  --
  PROCEDURE pr_not_above_zero (pi_d NUMBER, pi_dsc VARCHAR2) IS
  BEGIN
    IF pi_d > 0 THEN 
      pkwf_00_00_err.pr_raise (pi_id => '000015', pi_p1 => NVL(pi_dsc,'Number')||' ['||pi_d||']');
    END IF;
  END pr_not_above_zero;
  --  
  PROCEDURE pr_below_zero (pi_d NUMBER, pi_dsc VARCHAR2) IS
  BEGIN
    IF NVL(pi_d,0) >= 0 THEN 
      pkwf_00_00_err.pr_raise (pi_id => '000013', pi_p1 => NVL(pi_dsc,'Number')||' ['||pi_d||']');
    END IF;
  END pr_below_zero;
  --  
  PROCEDURE pr_not_below_zero (pi_d NUMBER, pi_dsc VARCHAR2) IS
  BEGIN
    IF pi_d < 0 THEN 
      pkwf_00_00_err.pr_raise (pi_id => '000016', pi_p1 => NVL(pi_dsc,'Number')||' ['||pi_d||']');
    END IF;
  END pr_not_below_zero;
  --  
  PROCEDURE pr_equal_zero (pi_d NUMBER, pi_dsc VARCHAR2) IS
  BEGIN
    IF NVL(pi_d,0) <> 0 THEN 
      pkwf_00_00_err.pr_raise (pi_id => '000014', pi_p1 => NVL(pi_dsc,'Number')||' ['||pi_d||']');    
    END IF;
  END pr_equal_zero;
  --   
  -- Validate that Input Value is greater than Limit Number
  PROCEDURE pr_above_num (pi_d   IN NUMBER, 
                          pi_lim IN NUMBER DEFAULT 0, 
                          pi_dsc IN VARCHAR2 DEFAULT 'Value', 
                          pi_ci IN VARCHAR2 DEFAULT NULL) IS
  BEGIN
    IF NOT (pi_d > pi_lim) THEN
      pkwf_00_00_err.pr_raise (pi_id => '000017', pi_p1 => pi_dsc, pi_p2 => TO_CHAR(pi_lim));
    END IF;  
  END pr_above_num;
  --
  -- Validate that Input Value is not greater than Limit Number
  PROCEDURE pr_not_above_num (pi_d   IN NUMBER, 
                              pi_lim IN NUMBER DEFAULT 0, 
                              pi_dsc IN VARCHAR2 DEFAULT 'Value', 
                              pi_ci IN VARCHAR2 DEFAULT NULL) IS
  BEGIN
    IF pi_d > pi_lim THEN
      pkwf_00_00_err.pr_raise (pi_id => '000020', pi_p1 => pi_dsc, pi_p2 => TO_CHAR(pi_lim));
    END IF;  
  END pr_not_above_num;
  --  
  -- Validate that Input Value is less than Limit Number
  PROCEDURE pr_below_num (pi_d   IN NUMBER, 
                          pi_lim IN NUMBER DEFAULT 0, 
                          pi_dsc IN VARCHAR2 DEFAULT 'Value', 
                          pi_ci IN VARCHAR2 DEFAULT NULL) IS
  BEGIN
    IF NOT (pi_d < pi_lim) THEN
      pkwf_00_00_err.pr_raise (pi_id => '000018', pi_p1 => pi_dsc, pi_p2 => TO_CHAR(pi_lim));
    END IF;  
  END pr_below_num;
  -- 
  -- Validate that Input Value equals Limit Number
  PROCEDURE pr_equal_num (pi_d   IN NUMBER, 
                          pi_lim IN NUMBER DEFAULT 0, 
                          pi_dsc IN VARCHAR2 DEFAULT 'Value', 
                          pi_ci IN VARCHAR2 DEFAULT NULL) IS
  BEGIN
    IF NOT (pi_d = pi_lim) THEN
      pkwf_00_00_err.pr_raise (pi_id => '000019', pi_p1 => pi_dsc, pi_p2 => TO_CHAR(pi_lim));
    END IF;  
  END pr_equal_num;
  --    
  -- Validate that Input Value is not less than Limit Number
  PROCEDURE pr_not_below_num (pi_d   IN NUMBER, 
                              pi_lim IN NUMBER DEFAULT 0, 
                              pi_dsc IN VARCHAR2 DEFAULT 'Value', 
                              pi_ci IN VARCHAR2 DEFAULT NULL) IS
  BEGIN
    IF pi_d < pi_lim THEN
      pkwf_00_00_err.pr_raise (pi_id => '000021', pi_p1 => pi_dsc, pi_p2 => TO_CHAR(pi_lim));
    END IF;  
  END pr_not_below_num;
  --  
  -- Checks that 1ST NUMBER is not greater than 2ND NUMBER
  PROCEDURE pr_n1_not_above_n2 (pi_n1 IN NUMBER, pi_dsc1 IN VARCHAR2, pi_n2 IN NUMBER, pi_dsc2 IN VARCHAR2) IS
  BEGIN
    IF pi_n1 > pi_n2 THEN
      pkwf_00_00_err.pr_raise (pi_id => '000020', pi_p1 => NVL(pi_dsc1,'Number 1'), pi_p2 => NVL(pi_dsc2,'Number 2'));    
    END IF;
  END pr_n1_not_above_n2;
  --
  PROCEDURE pr_rate_below_100pct (pi_d NUMBER, pi_dsc VARCHAR2 DEFAULT 'Rate') IS
  BEGIN
    IF NVL(pi_d,0) >= 100 THEN 
      pkwf_00_00_err.pr_raise (pi_id => '000018', pi_p1 => pi_dsc, pi_p2 => '100%');
    END IF;
  END pr_rate_below_100pct;
  --    
  -- Checks that Date Input is earlier than Current Business Date
  PROCEDURE pr_bef_bus_dt (pi_d IN DATE, pi_dsc IN VARCHAR2) IS
  BEGIN
    IF TRUNC(pi_d) >= TRUNC(pkwf_00.fn_bus_dt) THEN
      pkwf_00_00_err.pr_raise (pi_id => '000030', pi_p1 => NVL(pi_dsc,'Date'), pi_p2 => 'Current Business Date');
    END IF;
  END pr_bef_bus_dt;
  --
  -- Checks that Date Input is not earlier than Current Business Date
  PROCEDURE pr_not_bef_bus_dt (pi_d IN DATE, pi_dsc IN VARCHAR2) IS
  BEGIN
    IF TRUNC(pi_d) < TRUNC(pkwf_00.fn_bus_dt) THEN
      pkwf_00_00_err.pr_raise (pi_id => '000033', pi_p1 => NVL(pi_dsc,'Date'), pi_p2 => 'Current Business Date');
    END IF;
  END pr_not_bef_bus_dt;
  --  
  -- Checks that Date Input is later than Current Business Date
  PROCEDURE pr_aft_bus_dt (pi_d IN DATE, pi_dsc IN VARCHAR2) IS
  BEGIN
    IF TRUNC(pi_d) <= TRUNC(pkwf_00.fn_bus_dt) THEN
      pkwf_00_00_err.pr_raise (pi_id => '000029', pi_p1 => NVL(pi_dsc,'Date'), pi_p2 => 'Current Business Date');
    END IF;
  END pr_aft_bus_dt;
  --
  -- Checks that Date Input is not later than Current Business Date
  PROCEDURE pr_not_aft_bus_dt (pi_d IN DATE, pi_dsc IN VARCHAR2) IS
  BEGIN  
    IF TRUNC(pi_d) > TRUNC(pkwf_00.fn_bus_dt) THEN
      pkwf_00_00_err.pr_raise (pi_id => '000032', pi_p1 => NVL(pi_dsc,'Date'), pi_p2 => 'Current Business Date');
    END IF;
  END pr_not_aft_bus_dt;
  --    
  -- Checks that Date Input is earlier than Current System Date
  PROCEDURE pr_bef_sys_dt (pi_d IN DATE, pi_dsc IN VARCHAR2) IS
  BEGIN
    IF TRUNC(pi_d) >= TRUNC(pkwf_00.fn_now) THEN
      pkwf_00_00_err.pr_raise (pi_id => '000025', pi_p1 => NVL(pi_dsc,'Date'));    
    END IF;
  END pr_bef_sys_dt;
  --
  -- Checks that Date Input is not earlier than Current System Date
  PROCEDURE pr_not_bef_sys_dt (pi_d IN DATE, pi_dsc IN VARCHAR2) IS
  BEGIN
    IF TRUNC(pi_d) < TRUNC(pkwf_00.fn_now) THEN
      pkwf_00_00_err.pr_raise (pi_id => '000028', pi_p1 => NVL(pi_dsc,'Date'));    
    END IF;
  END pr_not_bef_sys_dt;
  --  
  -- Checks that Date Input is later than Current System Date
  PROCEDURE pr_aft_sys_dt (pi_d IN DATE, pi_dsc IN VARCHAR2) IS
  BEGIN
    IF TRUNC(pi_d) <= TRUNC(pkwf_00.fn_now) THEN
      pkwf_00_00_err.pr_raise (pi_id => '000024', pi_p1 => NVL(pi_dsc,'Date'));    
    END IF;
  END pr_aft_sys_dt;
  --
  -- Checks that Date Input is not later than Current System Date
  PROCEDURE pr_not_aft_sys_dt (pi_d IN DATE, pi_dsc IN VARCHAR2) IS
  BEGIN
    IF TRUNC(pi_d) > TRUNC(pkwf_00.fn_now) THEN
      pkwf_00_00_err.pr_raise (pi_id => '000027', pi_p1 => NVL(pi_dsc,'Date'));    
    END IF;
  END pr_not_aft_sys_dt;
  --     
  -- Checks that 1ST DATE is earlier than 2ND DATE
  PROCEDURE pr_d1_bef_d2 (pi_d1 IN DATE, pi_dsc1 IN VARCHAR2, pi_d2 IN DATE, pi_dsc2 IN VARCHAR2) IS
  BEGIN
    IF TRUNC(pi_d1) >= TRUNC(pi_d2) THEN
      pkwf_00_00_err.pr_raise (pi_id => '000030', pi_p1 => NVL(pi_dsc1,'Date1'), pi_p2 => NVL(pi_dsc2,'Date2'));    
    END IF;
  END pr_d1_bef_d2;
  --
  -- Checks that 1ST DATE is not earlier than 2ND DATE
  PROCEDURE pr_d1_not_bef_d2 (pi_d1 IN DATE, pi_dsc1 IN VARCHAR2, pi_d2 IN DATE, pi_dsc2 IN VARCHAR2) IS
  BEGIN
    IF TRUNC(pi_d1) < TRUNC(pi_d2) THEN
      pkwf_00_00_err.pr_raise (pi_id => '000033', pi_p1 => NVL(pi_dsc1,'Date1'), pi_p2 => NVL(pi_dsc2,'Date2'));    
    END IF;
  END pr_d1_not_bef_d2;
  --  
  -- Checks that 1ST DATE is later than 2ND DATE
  PROCEDURE pr_d1_aft_d2 (pi_d1 IN DATE, pi_dsc1 IN VARCHAR2, pi_d2 IN DATE, pi_dsc2 IN VARCHAR2) IS
  BEGIN
    IF TRUNC(pi_d1) <= TRUNC(pi_d2) THEN
      pkwf_00_00_err.pr_raise (pi_id => '000029', pi_p1 => NVL(pi_dsc1,'Date1'), pi_p2 => NVL(pi_dsc2,'Date2'));    
    END IF;  
  END pr_d1_aft_d2;
  --  
  -- Checks that 1ST DATE is not later than 2ND DATE
  PROCEDURE pr_d1_not_aft_d2 (pi_d1 IN DATE, pi_dsc1 IN VARCHAR2, pi_d2 IN DATE, pi_dsc2 IN VARCHAR2) IS
  BEGIN
    IF TRUNC(pi_d1) > TRUNC(pi_d2) THEN
      pkwf_00_00_err.pr_raise (pi_id => '000032', pi_p1 => NVL(pi_dsc1,'Date1'), pi_p2 => NVL(pi_dsc2,'Date2'));    
    END IF;
  END pr_d1_not_aft_d2;
  --     
  -- Check that Value is a whole number
  PROCEDURE pr_whole_num (pi_d NUMBER, pi_dsc VARCHAR2) IS
  BEGIN
    IF NVL(pi_d,0) = 0 THEN
      NULL;
    ELSIF MOD(pi_d,1) = 0 THEN
      NULL;
    ELSE
      pkwf_00_00_err.pr_raise (pi_id => '000023', pi_p1 => NVL(pi_dsc,'Number'));    
    END IF;
  END pr_whole_num;
  --
  -- Check Valid Money: Max 2 decimal places and not < 0
  FUNCTION fn_is_valid_money (pi_d IN NUMBER) RETURN BOOLEAN IS
  BEGIN
    IF pi_d < 0 THEN
      RETURN FALSE;
    ELSIF NVL(pi_d,0) = 0 THEN
      RETURN TRUE;
    ELSIF MOD(pi_d*100,1) = 0 THEN
      RETURN TRUE;
    ELSE
      RETURN FALSE;
    END IF;
  END fn_is_valid_money;
  --
  -- 
  PROCEDURE pr_money (pi_d IN NUMBER, pi_dsc IN VARCHAR2) IS
  BEGIN
    IF NOT fn_is_valid_money (pi_d) THEN
      pkwf_00_00_err.pr_raise (pi_id => '000034', pi_p1 => NVL(pi_dsc,'Value')||' ['||pi_d||']');    
    END IF; 
  END pr_money;  
  --
  -- Validate that record status is 'Pending'
  PROCEDURE pr_pending_rec (pi_d IN NUMBER) IS
  BEGIN
    IF pi_d IN (-1,0) THEN
      NULL;
    ELSE
      IF pi_d = 1 THEN
        pkwf_00_00_err.pr_raise (pi_id => '000038'); -- Already approved
      ELSIF pi_d = 2 THEN
        pkwf_00_00_err.pr_raise (pi_id => '000041'); -- Already rejected
      ELSE
        pkwf_00_00_err.pr_raise (pi_id => '000040'); -- Invalid status
      END IF;
    END IF;
    --
  END pr_pending_rec;
  --   
  -- Validate that record status is 'Approved'
  PROCEDURE pr_approved_rec (pi_d IN NUMBER) IS
  BEGIN
    IF pi_d = 1 THEN
      NULL;
    ELSE
      IF pi_d IN (-1,0) THEN
        pkwf_00_00_err.pr_raise (pi_id => '000039'); -- Pending
      ELSIF pi_d = 2 THEN
        pkwf_00_00_err.pr_raise (pi_id => '000041'); -- Already rejected
      ELSE
        pkwf_00_00_err.pr_raise (pi_id => '000040'); -- Invalid status
      END IF;
    END IF;
    --
  END pr_approved_rec;
  --  
  -- Validate that Data length is not greater than specified value
  PROCEDURE pr_dat_len_max (pi_d IN VARCHAR2, pi_len IN NUMBER DEFAULT 50, pi_dsc IN VARCHAR2) IS
  BEGIN
    IF LENGTH(pi_d) > pi_len THEN
      pkwf_00_00_err.pr_raise (pi_id => '000035', pi_p1 => NVL(pi_dsc,'Data'), pi_p2 => TO_CHAR(pi_len));
    END IF;  
  END pr_dat_len_max;
  --
  -- Validate that Data length is not less than specified value
  PROCEDURE pr_dat_len_min (pi_d IN VARCHAR2, pi_len IN NUMBER DEFAULT 10, pi_dsc IN VARCHAR2) IS
  BEGIN
    IF LENGTH(pi_d) < pi_len THEN
      pkwf_00_00_err.pr_raise (pi_id => '000036', pi_p1 => NVL(pi_dsc,'Data'), pi_p2 => TO_CHAR(pi_len));
    END IF;  
  END pr_dat_len_min;
  --   
  -- Validate that Data length equals specified value
  PROCEDURE pr_dat_len_equal (pi_d IN VARCHAR2, pi_len IN NUMBER DEFAULT 10, pi_dsc IN VARCHAR2) IS
  BEGIN
    IF NOT (LENGTH(pi_d) = pi_len) THEN
      pkwf_00_00_err.pr_raise (pi_id => '000037', pi_p1 => NVL(pi_dsc,'Data'), pi_p2 => TO_CHAR(pi_len));
    END IF;  
  END pr_dat_len_equal;
  --   
  -- Validate that Number Value is not greater than specified value
  PROCEDURE pr_num_val_max (pi_d IN NUMBER, pi_lim IN NUMBER DEFAULT 99999999999, pi_dsc IN VARCHAR2) IS
  BEGIN
    IF pi_d > pi_lim THEN
      pkwf_00_00_err.pr_raise (pi_id => '000020', pi_p1 => NVL(pi_dsc,'Value'), pi_p2 => TO_CHAR(pi_lim));
    END IF;  
  END pr_num_val_max;
  --
  -- Validate that Number Value is not less than specified value
  PROCEDURE pr_num_val_min (pi_d IN NUMBER, pi_lim IN NUMBER DEFAULT 0, pi_dsc IN VARCHAR2) IS
  BEGIN
    IF pi_d < pi_lim THEN
      pkwf_00_00_err.pr_raise (pi_id => '000021', pi_p1 => NVL(pi_dsc,'Value'), pi_p2 => TO_CHAR(pi_lim));
    END IF;  
  END pr_num_val_min;
  --
  PROCEDURE pr_valid_eml (pi_d VARCHAR2, pi_dsc IN VARCHAR2) IS
    v_r  BOOLEAN;
  BEGIN
    IF NOT pk99$$00_eml.fn_is_valid_adr (pi_adr => pi_d) THEN
      pkwf_00_00_err.pr_raise(pi_msg => pi_dsc||' is not a valid email address');
    END IF;
  END pr_valid_eml;
  --
  PROCEDURE pr_valid_phn (pi_d VARCHAR2, pi_dsc IN VARCHAR2) IS
  BEGIN
    IF REGEXP_LIKE(pi_d,'^\+([0-9]){7,15}$|^([0-9]){7,15}$') THEN 
      NULL;
    ELSE
      pkwf_00_00_err.pr_raise(pi_msg => pi_dsc||' is not a valid phone number');
    END IF;
  END pr_valid_phn;
  --
  --      
END pkwf_00_vld;
Error report -
Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\package-body\pkwf_10_eml_body.sql
In command -
CREATE OR REPLACE   PACKAGE BODY pkwf_10_eml AS
  --
  /* Author : Aderemi Alabi, 02-MAY-2013
  **
  ** Purpose  : WB -  Email Processing Routines
  **
  ** Modification History :
  **
  ** Copyright :  ProGenics Corp. Ltd, 2013
  **
  */
  --
  --
  -- Package Variables
  pv_00_eml       wf_vt_00_eml%ROWTYPE;  -- Email Config
  --
  /* Private Routines */
  -- 
  FUNCTION fn_init RETURN BOOLEAN IS 
    v_return BOOLEAN := TRUE;
    CURSOR c_00_eml IS
      SELECT * 
      FROM   wf_vt_00_eml;
  BEGIN
    --
    OPEN  c_00_eml;
    FETCH c_00_eml INTO pv_00_eml;
    CLOSE c_00_eml;
    pv_00_eml.max_rtry_no := NVL(pv_00_eml.max_rtry_no,99);
    IF pv_00_eml.max_rtry_no < 1 THEN
      pv_00_eml.max_rtry_no := 99;
    END IF;    
    --
    IF TRIM(pv_00_eml.smtp_hst) IS NULL THEN 
      raise_application_error(-20055, 'SMTP Host Address has not been specified');
    ELSIF TRIM(pv_00_eml.smtp_prt) IS NULL THEN 
      raise_application_error(-20055, 'SMTP Port number has not been specified');
    ELSIF TRIM(pv_00_eml.frm_eml) IS NULL THEN 
      raise_application_error(-20055, 'Sender email addresss has not been specified');
    ELSIF TRIM(pv_00_eml.auth_act) IS NULL AND NVL(pv_00_eml.smtp_auth_yn, '0') = '1' THEN 
      raise_application_error(-20055, 'SMTP Authentication Account has not been specified');
    ELSIF TRIM(pv_00_eml.auth_pwd) IS NULL AND NVL(pv_00_eml.smtp_auth_yn, '0') = '1' THEN 
      raise_application_error(-20055, 'SMTP Authentication Password has not been specified');
    END IF;
    --
    RETURN v_return;
    --
  END fn_init;
  --
  FUNCTION fn_smtp_conn RETURN UTL_SMTP.CONNECTION IS
    v_conn   UTL_SMTP.CONNECTION;
  BEGIN
    IF NVL(pv_00_eml.tls_yn, '0') = '1' THEN
      v_conn := UTL_SMTP.OPEN_CONNECTION(host => pv_00_eml.smtp_hst,
                                         port => pv_00_eml.smtp_prt
                                         );--wallet_path => 'file:'||pv_00_eml.wlt_pth,
                                        -- wallet_password => pv_00_eml.wlt_pwd,
                                        -- secure_connection_before_smtp => FALSE);
      IF NVL(pv_00_eml.ehlo_yn, '0') = '1' THEN
        UTL_SMTP.EHLO(v_conn, pv_00_eml.smtp_hst);
      ELSE
        UTL_SMTP.HELO(v_conn, pv_00_eml.smtp_hst);
      END IF;
      --UTL_SMTP.STARTTLS(v_conn);
    ELSE  
      v_conn := UTL_SMTP.OPEN_CONNECTION(pv_00_eml.smtp_hst, pv_00_eml.smtp_prt, 60);
      IF NVL(pv_00_eml.ehlo_yn, '0') = '1' THEN
        UTL_SMTP.EHLO(v_conn, pv_00_eml.smtp_hst);
      ELSE
        UTL_SMTP.HELO(v_conn, pv_00_eml.smtp_hst);
      END IF;
    END IF;
    
    IF NVL(pv_00_eml.smtp_auth_yn, '0') = '1' THEN
      UTL_SMTP.COMMAND(v_conn, 'AUTH LOGIN');
      UTL_SMTP.COMMAND(v_conn, utl_raw.cast_to_varchar2( utl_encode.base64_encode( utl_raw.cast_to_raw( pv_00_eml.auth_act ))) );
      UTL_SMTP.COMMAND(v_conn, utl_raw.cast_to_varchar2( utl_encode.base64_encode( utl_raw.cast_to_raw( pv_00_eml.auth_pwd ))) );                 
    END IF;
    RETURN v_conn;
  EXCEPTION
    WHEN OTHERS THEN
      UTL_SMTP.QUIT(v_conn);
      raise_application_error(-20055, SQLERRM);        
  END fn_smtp_conn;
  --
  --
  /* Public Routines */
  --    
  PROCEDURE pr_send_mail(pi_rcpt IN VARCHAR2, pi_msg CLOB) IS
    v_conn   UTL_SMTP.CONNECTION;
    v_err    VARCHAR2(500);
    v_crlf   VARCHAR2(10) := CHR(13) || CHR(10);
    v_to_adr VARCHAR2(500) := NULL;
    v_msg    CLOB;
  BEGIN
    -- 
    v_to_adr := pi_rcpt;
    IF v_to_adr IS NULL THEN
      raise_application_error(-20055, 'Recipient Address has not been defined');
    END IF;
    --
    IF fn_init THEN
      -- 
      v_conn := fn_smtp_conn;
      -- 
      UTL_SMTP.MAIL (v_conn, 'admin@10.0.0.204');
      --
      v_msg := 
      'MIME-version: 1.0' || v_crlf ||
                     'Content-Type: text/html; charset=ISO-8859-15' || v_crlf ||
                     'Content-Transfer-Encoding: 8bit' || v_crlf ||
                     'Date: '   || to_char(sysdate, 'Dy, DD Mon YYYY hh24:mi:ss') || v_crlf ||
                     'From: '   || pv_00_eml.frm_eml || v_crlf ||
                     'Subject: Test Message' || v_crlf ||
                     'To: '     || v_to_adr || v_crlf || v_crlf ||
                     NVL(pi_msg,'This is a test message from the Customer Portal. Please ignore.')|| v_crlf;
      BEGIN
        UTL_SMTP.RCPT(v_conn, v_to_adr);
        UTL_SMTP.DATA(v_conn, v_msg);
      EXCEPTION
        WHEN OTHERS THEN
          v_err := SQLERRM;
          raise_application_error(-20055, 'EMAIL Error: '||v_err);
      END;
      --
      UTL_SMTP.QUIT(v_conn);
      --
    END IF;
    -- 
  END pr_send_mail;
  --
END pkwf_10_eml;
Error report -
Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\package-body\pkwf_10_mb_body.sql
In command -
CREATE OR REPLACE PACKAGE BODY pkwf_10_mb AS
  --
  /* Created By       : Kunle Adebona
  ** Date Created     : 06-SEP-2012
  ** Release Version  : 2.0
  **
  ** PURPOSE: Operating Parameters
  **
  ** MODIFICATION HISTORY:
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **  
  **
  */
  --
  --
  pv_rec      wf_vt_10_mb%ROWTYPE;
  pv_rec_e    wf_vt_10_mb%ROWTYPE;
  --
  pv_tbl      wf_10_mb%ROWTYPE;
  pv_tbl_i    wf_10_mb%ROWTYPE;
  --
  /* Private Routines */
  --      
  --
  PROCEDURE pr_clear_recs IS
  BEGIN
    pv_tbl          := NULL;
    pv_rec          := NULL;
    pv_rec_e        := NULL;
  END pr_clear_recs;
  --    
  /* Public Routines */
  --  
  --
  PROCEDURE pr_prc(pi_rec IN OUT wf_vt_10_mb%ROWTYPE) IS
  BEGIN
    --    
  --  pr_auth;
    --
    pr_clear_recs;
    --  
    pv_rec_e := pi_rec;
    --
    pv_rec_e.row_key := NVL(pv_rec_e.row_key,0);
    --
--    IF pv_rec_e.row_key = 0 THEN -- NEW
--      --
--      pv_rec_e.appr_stat_dm := '0';
--      --
--    ELSE  -- UPDATE
--      --
--      pr_load_cur_rec (pi_key => pv_rec_e.row_key);
--      --
--      IF pv_tbl.row_key = pv_rec_e.row_key THEN -- record found
--        --
--        IF pv_tbl.appr_stat_dm = '0' THEN
--          NULL;
--        ELSIF pv_tbl.appr_stat_dm IN ('1','3') THEN 
--          pv_rec_e.cur_id := pv_tbl.cur_id;
--        ELSE
--          pkst_00_xcp.pr_not_valid (pi_dsc => 'Currency record');
--        END IF;
--        --
--      ELSE
--        pkst_00_xcp.pr_not_valid (pi_dsc => 'Currency record');
--      END IF;
--      --
--      pv_rec_e.appr_stat_dm := pv_tbl.appr_stat_dm;
--      --
--    END IF;
    --
    --
    --pr_fmt_pv_rec_e;
    --pr_val_pv_rec_e;
    --  
    --
     IF pv_rec_e.row_key = 0 THEN -- INSERT
      --  
      pv_tbl_i.row_key := pkwf_00.fn_nxt_key;
      pv_tbl_i.appr_stat_dm := '0';
      pv_tbl_i.c_n := 1;
      --
      pv_tbl_i.mb_id  := pv_rec_e.mb_id;
      pv_tbl_i.mb_dsc := pv_rec_e.mb_dsc;
      pv_tbl_i.u_k    := pv_rec_e.u_k;
      pv_tbl_i.iu_yn  := pv_rec_e.iu_yn;
      --
      INSERT INTO wf_10_mb VALUES pv_tbl_i;
      --
      pv_rec_e.row_key := pv_tbl_i.row_key;
--      pv_rec_e.c_n     := pv_tbl_i.c_n;
      --
    ELSE -- UPDATE
--      IF fn_same_cn (pi_key => pv_tbl_i.row_key, pi_cn => pv_tbl_i.c_n) THEN
--        IF pv_rec_e.appr_stat_dm IN('0','1','3') THEN
          UPDATE wf_10_mb
             SET mb_id       = pv_rec_e.mb_id,     
                 mb_dsc      = pv_rec_e.mb_dsc,  
                 u_k         = pv_rec_e.u_k,   
                 iu_yn       = pv_rec_e.iu_yn     
           WHERE row_key =  pv_rec_e.row_key;
--        END IF;
--      ELSE
--        pkst_00_xcp.pr_rec_changed (pi_dsc => 'Currency record', pi_ci  => 'cur_id');
--      END IF;
    END IF;
   --
    pi_rec := pv_rec_e; 
   --
   END pr_prc;
  --
  PROCEDURE pr_del(pi_k IN NUMBER) IS
  BEGIN
    DELETE
      FROM wf_10_mb
     WHERE row_key = pi_k
       AND pi_k NOT IN (SELECT mb_k
                          FROM wf_10_rl_mb);
  END pr_del;
  --     
  --
END pkwf_10_mb;
Error report -
Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\package-body\pkwf_10_rl_body.sql
In command -
CREATE OR REPLACE PACKAGE BODY pkwf_10_rl AS
  --
  /* Created By       : Kunle Adebona
  ** Date Created     : 06-SEP-2012
  ** Release Version  : 2.0
  **
  ** PURPOSE: Operating Parameters
  **
  ** MODIFICATION HISTORY:
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **  
  **
  */
  --
  --
  pv_rec      wf_vt_10_rl%ROWTYPE;
  pv_rec_e    wf_vt_10_rl%ROWTYPE;
  --
  pv_tbl      wf_10_rl%ROWTYPE;
  pv_tbl_i    wf_10_rl%ROWTYPE;
  --
  /* Private Routines */
  --      
  --
  PROCEDURE pr_clear_recs IS
  BEGIN
    pv_tbl          := NULL;
    pv_rec          := NULL;
    pv_rec_e        := NULL;
  END pr_clear_recs;
  --    
  /* Public Routines */
  --  
  --
  PROCEDURE pr_prc(pi_rec IN OUT wf_vt_10_rl%ROWTYPE) IS
  BEGIN
    --    
  --  pr_auth;
    --
    pr_clear_recs;
    --  
    pv_rec_e := pi_rec;
    --
    pv_rec_e.row_key := NVL(pv_rec_e.row_key,0);
    --
--    IF pv_rec_e.row_key = 0 THEN -- NEW
--      --
--      pv_rec_e.appr_stat_dm := '0';
--      --
--    ELSE  -- UPDATE
--      --
--      pr_load_cur_rec (pi_key => pv_rec_e.row_key);
--      --
--      IF pv_tbl.row_key = pv_rec_e.row_key THEN -- record found
--        --
--        IF pv_tbl.appr_stat_dm = '0' THEN
--          NULL;
--        ELSIF pv_tbl.appr_stat_dm IN ('1','3') THEN 
--          pv_rec_e.cur_id := pv_tbl.cur_id;
--        ELSE
--          pkst_00_xcp.pr_not_valid (pi_dsc => 'Currency record');
--        END IF;
--        --
--      ELSE
--        pkst_00_xcp.pr_not_valid (pi_dsc => 'Currency record');
--      END IF;
--      --
--      pv_rec_e.appr_stat_dm := pv_tbl.appr_stat_dm;
--      --
--    END IF;
    --
    --
    --pr_fmt_pv_rec_e;
    --pr_val_pv_rec_e;
    --  
    --
     IF pv_rec_e.row_key = 0 THEN -- INSERT
      --  
      pv_tbl_i.row_key := pkwf_00.fn_nxt_key;
      pv_tbl_i.appr_stat_dm := '0';
      pv_tbl_i.c_n := 1;
      --
      pv_tbl_i.rl_id  := pv_rec_e.rl_id;
      pv_tbl_i.rl_dsc := pv_rec_e.rl_dsc;
      pv_tbl_i.iu_yn  := pv_rec_e.iu_yn;
      --
      INSERT INTO wf_10_rl VALUES pv_tbl_i;
      --
      pv_rec_e.row_key := pv_tbl_i.row_key;
--      pv_rec_e.c_n     := pv_tbl_i.c_n;
      --
    ELSE -- UPDATE
--      IF fn_same_cn (pi_key => pv_tbl_i.row_key, pi_cn => pv_tbl_i.c_n) THEN
--        IF pv_rec_e.appr_stat_dm IN('0','1','3') THEN
          UPDATE wf_10_rl
             SET rl_id       = pv_rec_e.rl_id,     
                 rl_dsc      = pv_rec_e.rl_dsc,     
                 iu_yn       = pv_rec_e.iu_yn     
           WHERE row_key =  pv_rec_e.row_key;
--        END IF;
--      ELSE
--        pkst_00_xcp.pr_rec_changed (pi_dsc => 'Currency record', pi_ci  => 'cur_id');
--      END IF;
    END IF;
   --
    pi_rec := pv_rec_e; 
   --
   END pr_prc;
  --
  PROCEDURE pr_del(pi_k IN NUMBER) IS
  BEGIN
    DELETE
      FROM wf_10_rl
     WHERE row_key = pi_k
       AND pi_k NOT IN (SELECT rl_k
                          FROM wf_10_rl_mb);
  END pr_del;
  --     
  --
END pkwf_10_rl;
Error report -
Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\package-body\pkwf_10_rl_mb_body.sql
In command -
CREATE OR REPLACE PACKAGE BODY pkwf_10_rl_mb AS
  --
  /* Created By       : Kunle Adebona
  ** Date Created     : 06-SEP-2012
  ** Release Version  : 2.0
  **
  ** PURPOSE: Operating Parameters
  **
  ** MODIFICATION HISTORY:
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **  
  **
  */
  --
  --
  pv_rec      wf_vt_10_rl_mb%ROWTYPE;
  pv_rec_e    wf_vt_10_rl_mb%ROWTYPE;
  --
  pv_tbl      wf_10_rl_mb%ROWTYPE;
  pv_tbl_i    wf_10_rl_mb%ROWTYPE;
  --
  /* Private Routines */
  --      
  --
  PROCEDURE pr_clear_recs IS
  BEGIN
    pv_tbl          := NULL;
    pv_rec          := NULL;
    pv_rec_e        := NULL;
  END pr_clear_recs;
  --    
  /* Public Routines */
  --  
  --
  PROCEDURE pr_prc(pi_rec IN OUT wf_vt_10_rl_mb%ROWTYPE) IS
  BEGIN
    --    
  --  pr_auth;
    --
    pr_clear_recs;
    --  
    pv_rec_e := pi_rec;
    --
    pv_rec_e.row_key := NVL(pv_rec_e.row_key,0);
    --
--    IF pv_rec_e.row_key = 0 THEN -- NEW
--      --
--      pv_rec_e.appr_stat_dm := '0';
--      --
--    ELSE  -- UPDATE
--      --
--      pr_load_cur_rec (pi_key => pv_rec_e.row_key);
--      --
--      IF pv_tbl.row_key = pv_rec_e.row_key THEN -- record found
--        --
--        IF pv_tbl.appr_stat_dm = '0' THEN
--          NULL;
--        ELSIF pv_tbl.appr_stat_dm IN ('1','3') THEN 
--          pv_rec_e.cur_id := pv_tbl.cur_id;
--        ELSE
--          pkst_00_xcp.pr_not_valid (pi_dsc => 'Currency record');
--        END IF;
--        --
--      ELSE
--        pkst_00_xcp.pr_not_valid (pi_dsc => 'Currency record');
--      END IF;
--      --
--      pv_rec_e.appr_stat_dm := pv_tbl.appr_stat_dm;
--      --
--    END IF;
    --
    --
    --pr_fmt_pv_rec_e;
    --pr_val_pv_rec_e;
    --  
    --
     IF pv_rec_e.row_key = 0 THEN -- INSERT
      --  
      pv_tbl_i.row_key := pkwf_00.fn_nxt_key;
      pv_tbl_i.appr_stat_dm := '0';
      pv_tbl_i.c_n := 1;
      --
      pv_tbl_i.rl_k  := pv_rec_e.rl_k;
      pv_tbl_i.mb_k  := pv_rec_e.mb_k;
      pv_tbl_i.iu_yn := pv_rec_e.iu_yn;
      --
      INSERT INTO wf_10_rl_mb VALUES pv_tbl_i;
      --
      pv_rec_e.row_key := pv_tbl_i.row_key;
--      pv_rec_e.c_n     := pv_tbl_i.c_n;
      --
    ELSE -- UPDATE
--      IF fn_same_cn (pi_key => pv_tbl_i.row_key, pi_cn => pv_tbl_i.c_n) THEN
--        IF pv_rec_e.appr_stat_dm IN('0','1','3') THEN
          UPDATE wf_10_rl_mb
             SET rl_k       = pv_rec_e.rl_k,     
                 mb_k       = pv_rec_e.mb_k,  
                 iu_yn      = pv_rec_e.iu_yn     
           WHERE row_key =  pv_rec_e.row_key;
--        END IF;
--      ELSE
--        pkst_00_xcp.pr_rec_changed (pi_dsc => 'Currency record', pi_ci  => 'cur_id');
--      END IF;
    END IF;
   --
    pi_rec := pv_rec_e; 
   --
   END pr_prc;
  --
  PROCEDURE pr_del(pi_k IN NUMBER) IS
  BEGIN
    DELETE
      FROM wf_10_rl_mb
     WHERE row_key = pi_k;
  END pr_del;
  --     
  --
END pkwf_10_rl_mb;
Error report -
Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\package-body\pkwf_11_mb_body.sql
In command -
CREATE OR REPLACE PACKAGE BODY pkwf_11_mb AS
  --
  /* Created By       : Aderemi Alabi
  ** Date Created     : 02-JUN-2016
  ** Release Version  : 2.0
  **
  ** PURPOSE: Workflow User Management
  **
  ** MODIFICATION HISTORY:
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **  
  **
  */
  --
  --
  gv_k                  VARCHAR2(100);
  r_gv_k                VARCHAR2(100);
  v_is_valid_session    BOOLEAN := FALSE;
  r_v_is_valid_session  BOOLEAN := FALSE;
  --
  pv_rec      wf_vt_10_mb%ROWTYPE;
  pv_rec_e    wf_vt_10_mb%ROWTYPE;
  --
  pv_tbl      wf_10_mb%ROWTYPE;
  pv_tbl_i    wf_10_mb%ROWTYPE;
  --
  /* Private Routines */
  -- 
  -- global variables
  PROCEDURE pr_load_gvs IS
  BEGIN
    --
    v_is_valid_session := FALSE;
    --
    SELECT SYS_CONTEXT ('USERENV', 'LANGUAGE') ||
           SYS_CONTEXT ('USERENV', 'SESSION_USER') ||
           SYS_CONTEXT ('USERENV', 'SESSIONID') ||
           SYS_CONTEXT ('USERENV', 'NLS_DATE_FORMAT') 
    INTO gv_k
    FROM dual;
    --
    v_is_valid_session := TRUE; --pk99_glb.fn_vld_conn (gv_k);
    --
  END pr_load_gvs;
  --
  -- remote global variable
  PROCEDURE pr_load_r_gvs IS
  BEGIN
    --
    r_v_is_valid_session := FALSE;
    --
    SELECT SYS_CONTEXT ('USERENV', 'LANGUAGE') ||
           SYS_CONTEXT ('USERENV', 'SESSION_USER') ||
           SYS_CONTEXT ('USERENV', 'SESSIONID') ||
           SYS_CONTEXT ('USERENV', 'NLS_DATE_FORMAT') 
    INTO r_gv_k
    FROM dual@wf_sy;
    --
    --r_v_is_valid_session := pk99_glb.fn_vld_conn@wf_sy(r_gv_k);
    --
  END pr_load_r_gvs; 
  --
  --
  /* Public Routines */
  --      
  --
  PROCEDURE pr_clear_recs IS
  BEGIN
    pv_tbl          := NULL;
    pv_rec          := NULL;
    pv_rec_e        := NULL;
  END pr_clear_recs;
  --    
  /* Public Routines */
  --  
  --
  PROCEDURE pr_refresh IS
    --  
    CURSOR c_ssu IS -- new remote users
      SELECT A.*
      FROM   t_99_10_ssu@wf_sy A
      WHERE  usr_dm IN ('USR')
      AND    sta_dm IN ('N','L')
      AND    (r_k <> 100 OR r_k > 20)
      AND NOT EXISTS (SELECT 1
                      FROM   t_99_10_ssu b
                      WHERE  UPPER(A.lgn_id) = UPPER(b.lgn_id));
    --
    CURSOR c_not_mb IS -- removed users
      SELECT A.row_key
      FROM   wf_10_mb A
      WHERE NOT EXISTS (SELECT 1 
                        FROM   t_99_10_ssu b
                        WHERE  UPPER(A.mb_id) = UPPER(b.lgn_id));
    --  
    CURSOR c_mb IS -- new members
      SELECT A.lgn_id AS mb_id,
             UPPER(A.lst_nm )||' '||INITCAP(A.fir_nm) AS mb_dsc,
             A.r_k AS u_k
      FROM   t_99_10_ssu A
      WHERE  A.usr_dm IN ('USR')
      AND    A.sta_dm IN ('N','L')
      AND   (A.r_k <> 100 OR A.r_k > 20)
      AND NOT EXISTS (SELECT 1
                        FROM   wf_10_mb b
                        WHERE  UPPER(A.lgn_id) = UPPER(b.mb_id));
    --                    
    v_ssu t_99_10_ssu%ROWTYPE;
    v_mb  wf_10_mb%ROWTYPE;
    --    
  BEGIN
    --
    pr_load_gvs;
    pr_load_r_gvs;
    --
    -- manage remote users
    pk99_trg.pr_set_sdml (pi_k => gv_k);
    --
    DELETE FROM t_99_10_ssu A -- delete users that are no longer in use in symbols
    WHERE NVL(trc_yn,0) = 1  
    AND EXISTS (SELECT 1
                  FROM   t_99_10_ssu@wf_sy b
                  WHERE  b.sta_dm = 'D'
                  AND    UPPER(A.lgn_id) = UPPER(b.lgn_id));
    DELETE FROM t_99_10_ssu A -- delete users that are no longer in use in symbols
    WHERE NVL(trc_yn,0) = 1  
    AND NOT EXISTS (SELECT 1
                    FROM   t_99_10_ssu@wf_sy b
                    WHERE   UPPER(A.lgn_id) = UPPER(b.lgn_id));
    --
    FOR cr IN c_ssu LOOP -- bring in new users from symbols
      v_ssu := cr;
      v_ssu.i_ky := 1;
      v_ssu.trc_yn := '1';
      --INSERT INTO t_99_10_ssu VALUES v_ssu;
       INSERT INTO t_99_10_ssu 
      ( r_k, r_s, i_ky, sta_dm, sta_dt, lgn_id, usr_dm, 
        fir_nm, lst_nm, sht_nm, lgg_dm, eml_adr, eml_yn, 
        sms_yn, gdr_dm, ttl_dsc, adr_l1, adr_l2, adr_cty, 
        prm_phn, sms_phn, --dob_dt,
        err_yn, qry_yn, trc_yn, oth_rmk, cng_pw_yn,
        fl_01, fl_02, fl_03, fl_04, fl_05) 
      VALUES 
      ( cr.r_k, 0, 0,
     -- ( pk99_glb.fn_get_rk (pi_k => gv_k), 0, 0,
        cr.sta_dm, 
        cr.sta_dt, cr.lgn_id, cr.usr_dm, cr.fir_nm, 
        cr.lst_nm, cr.sht_nm, cr.lgg_dm, cr.eml_adr, 
        cr.eml_yn, cr.sms_yn, cr.gdr_dm, cr.ttl_dsc, 
        cr.adr_l1, cr.adr_l2, cr.adr_cty,
        cr.prm_phn, cr.sms_phn, --cr.dob_dt,
        0, 0, 1, cr.oth_rmk, cr.cng_pw_yn,
        cr.fl_01, cr.fl_02, cr.fl_03, cr.fl_04, '0');
    END LOOP;  
    --
    pk99_trg.pr_reset_sdml;
    --
    -- update WF member list
    FOR cr IN c_not_mb LOOP
      --
      DELETE FROM wf_10_rl_mb
      WHERE mb_k = cr.row_key;
      --
      DELETE FROM wf_10_mb
      WHERE row_key = cr.row_key;
      --
    END LOOP;    
    --
    FOR cr IN c_mb LOOP
      v_mb.row_key := pkwf_00.fn_nxt_key;
      v_mb.appr_stat_dm := '0';
      v_mb.c_n := 1;
      v_mb.mb_id  := cr.mb_id;
      v_mb.mb_dsc := cr.mb_dsc;
      v_mb.u_k    := cr.u_k;
      v_mb.iu_yn  := '0';
      INSERT INTO wf_10_mb VALUES v_mb;
    END LOOP;
    --
    UPDATE wf_10_mb A 
    SET    A.u_k = (SELECT b.r_k
                    FROM   t_99_10_ssu b
                    WHERE  UPPER(A.mb_id) = UPPER(b.lgn_id));
    --
  END pr_refresh;
  --
  FUNCTION fn_get_usr_l(pi_usr IN NUMBER) RETURN r_usr IS
    --
    CURSOR c_usr IS
      SELECT *
      FROM   wf_vl_11_mb_l
      WHERE  u_k = pi_usr;
    --
    v_r    r_usr;
    v_usr  wf_vl_11_mb_l%ROWTYPE;
    v_arr  apex_application_global.vc_arr2; 
  BEGIN
    --
    OPEN  c_usr;
    FETCH c_usr INTO v_usr;
    CLOSE c_usr;
    --
    IF NVL(v_usr.u_k,0) > 0 THEN
      v_r.u_k     := v_usr.u_k; 
      v_r.usr_id  := v_usr.mb_id; 
      v_r.usr_eml := v_usr.eml_adr;
      v_r.usr_dsc := v_usr.mb_dsc; 
      v_r.iu_yn   := v_usr.iu_yn;
      v_r.is_adm_yn := v_usr.is_adm_yn;
      --
      SELECT rl_k 
      BULK COLLECT 
      INTO   v_arr
      FROM   wf_10_rl_mb
      WHERE  mb_k = v_usr.u_k;
      --
      v_r.usr_rl := apex_util.table_to_string (v_arr);
      --
    END IF;
    --
    RETURN v_r;
    --
  END fn_get_usr_l;
  --
  FUNCTION fn_get_usr_r(pi_usr IN NUMBER) RETURN r_usr IS
    --
    CURSOR c_usr IS
      SELECT *
      FROM   wf_vl_11_mb_r
      WHERE  u_k = pi_usr;
    --
    v_r    r_usr;
    v_usr  wf_vl_11_mb_r%ROWTYPE;
    v_arr  apex_application_global.vc_arr2; 
  BEGIN
    --
    OPEN  c_usr;
    FETCH c_usr INTO v_usr;
    CLOSE c_usr;
    --
    IF NVL(v_usr.u_k,0) > 0 THEN
      v_r.u_k     := v_usr.u_k; 
      v_r.usr_id  := v_usr.mb_id;
      v_r.usr_dsc := v_usr.mb_dsc; 
      v_r.usr_eml := v_usr.eml_adr; 
      v_r.iu_yn   := v_usr.iu_yn;
      v_r.is_adm_yn := v_usr.is_adm_yn;
      --
      SELECT rl_k 
      BULK COLLECT 
      INTO   v_arr
      FROM   wf_10_rl_mb
      WHERE  mb_k = v_usr.u_k;
      --
      v_r.usr_rl := apex_util.table_to_string (v_arr);
      --
    END IF;
    --
    RETURN v_r;
    --
  END fn_get_usr_r;
  --
  --
  FUNCTION fn_get_usr_role(pi_usr IN NUMBER) RETURN VARCHAR2 IS
    --
    v_arr  apex_application_global.vc_arr2;
    v_r    VARCHAR2(200);
  BEGIN
    --
    SELECT INITCAP(b.rl_dsc) rl_dsc
    BULK COLLECT 
    INTO   v_arr
    FROM   wf_10_rl_mb A,
           wf_10_rl b
    WHERE  A.rl_k = b.row_key
    AND    mb_k = pi_usr;
    --
    v_r := apex_util.table_to_string (v_arr,', ');
    --
    RETURN v_r;
    --
  END fn_get_usr_role;
  --
  --
  PROCEDURE pr_new_usr_l(pi_rec IN r_usr) IS
    --
    v_arr  apex_application_global.vc_arr2; 
    v_usr  r_usr;
    v_rec  wf_10_rl_mb%ROWTYPE;
    --
  BEGIN
    -- 
    pr_load_gvs;
    --
    v_usr := pi_rec;
    --
    INSERT INTO wf_10_mb (row_key, mb_id, mb_dsc, u_k, iu_yn) 
    VALUES (wf_seq_00_key.NEXTVAL, v_usr.usr_id, v_usr.usr_dsc, v_usr.u_k, '1');
    --
    DELETE FROM wf_10_rl_mb
    WHERE mb_k = pi_rec.u_k;
    --
    v_arr := apex_util.string_to_table(pi_rec.usr_rl);
    FOR i IN 1..v_arr.COUNT LOOP
      v_rec.row_key := pkwf_00.fn_nxt_key;
      v_rec.appr_stat_dm := '0';
      v_rec.c_n := 1;
      --
      v_rec.rl_k  := v_arr(i);
      v_rec.mb_k  := pi_rec.u_k;
      v_rec.iu_yn := pi_rec.iu_yn;
      --
      INSERT INTO wf_10_rl_mb VALUES v_rec;
      --
    END LOOP;
    --
  END pr_new_usr_l;
  --
  PROCEDURE pr_upd_usr_l(pi_rec IN r_usr) IS
    --
    v_arr  apex_application_global.vc_arr2; 
    v_rec  wf_10_rl_mb%ROWTYPE;
    --
  BEGIN
    -- 
    pr_load_gvs;
    UPDATE wf_10_mb
    SET    mb_dsc = pi_rec.usr_id,
           iu_yn  = pi_rec.iu_yn
    WHERE  u_k = pi_rec.u_k;
    --
    pk99_trg.pr_set_sdml (pi_k => gv_k);
    UPDATE t_99_10_ssu
    SET    eml_adr = pi_rec.usr_eml,
           fl_05 = pi_rec.is_adm_yn
    WHERE  r_k = pi_rec.u_k;
    pk99_trg.pr_reset_sdml;
    --
    DELETE FROM wf_10_rl_mb
    WHERE mb_k = pi_rec.u_k;
    --
    v_arr := apex_util.string_to_table(pi_rec.usr_rl);
    FOR i IN 1..v_arr.COUNT LOOP
      v_rec.row_key := pkwf_00.fn_nxt_key;
      v_rec.appr_stat_dm := '0';
      v_rec.c_n := 1;
      --
      v_rec.rl_k  := v_arr(i);
      v_rec.mb_k  := pi_rec.u_k;
      v_rec.iu_yn := pi_rec.iu_yn;
      --
      INSERT INTO wf_10_rl_mb VALUES v_rec;
      --
    END LOOP;
    --
  END pr_upd_usr_l;
  --
  PROCEDURE pr_upd_usr_r(pi_rec IN r_usr) IS
    --
    v_arr  apex_application_global.vc_arr2; 
    v_rec  wf_10_rl_mb%ROWTYPE;
    --
  BEGIN
    -- 
    pr_load_gvs;
    UPDATE wf_10_mb
    SET    iu_yn  = pi_rec.iu_yn
    WHERE  u_k = pi_rec.u_k;
    --
    pk99_trg.pr_set_sdml (pi_k => gv_k);
    UPDATE t_99_10_ssu
    SET    fl_05 = pi_rec.is_adm_yn
    WHERE  r_k = pi_rec.u_k;
    pk99_trg.pr_reset_sdml;
    --
    DELETE FROM wf_10_rl_mb
    WHERE mb_k = pi_rec.u_k;
    --
    v_arr := apex_util.string_to_table(pi_rec.usr_rl);
    FOR i IN 1..v_arr.COUNT LOOP
      v_rec.row_key := pkwf_00.fn_nxt_key;
      v_rec.appr_stat_dm := '0';
      v_rec.c_n := 1;
      --
      v_rec.rl_k  := v_arr(i);
      v_rec.mb_k  := pi_rec.u_k;
      v_rec.iu_yn := pi_rec.iu_yn;
      --
      INSERT INTO wf_10_rl_mb VALUES v_rec;
      --
    END LOOP;
    --
  END pr_upd_usr_r;
  --
  FUNCTION fn_is_admin(pi_usr IN NUMBER) RETURN BOOLEAN IS
    --
    CURSOR c_adm IS
      SELECT usr_dm
      FROM   t_99_10_ssu
      WHERE  r_k = pi_usr;
    --
    v_adm_yn  VARCHAR2(1);
    v_return  BOOLEAN := FALSE;
    --
  BEGIN
    --
    OPEN  c_adm ;
    FETCH c_adm INTO v_adm_yn;
    CLOSE c_adm;
    --
    IF NVL(v_adm_yn,'USR') = 'ADM' THEN
      v_return := TRUE;
    END IF;
    --
    RETURN v_return;
    --
  END fn_is_admin; 
  -- 
  FUNCTION fn_is_admin(pi_usr IN VARCHAR2 DEFAULT NULL) RETURN BOOLEAN IS
    --
    v_k   NUMBER;
    v_usr VARCHAR2(30);
    --
    CURSOR c_usr IS
      SELECT r_k
      FROM   t_99_10_ssu
      WHERE  UPPER(lgn_id) = UPPER(v_usr);
    --
  BEGIN
    --
    v_usr := NVL(pi_usr,v('APP_USER'));
    --
    OPEN  c_usr;
    FETCH c_usr INTO v_k;
    CLOSE c_usr;
    --
    RETURN fn_is_admin(v_k);
    --
  END fn_is_admin;
  --
  FUNCTION fn_is_lcl_usr(pi_usr IN VARCHAR2 DEFAULT NULL) RETURN BOOLEAN IS
    --
    v_lcl VARCHAR2(30);
    v_usr VARCHAR2(30);
    v_return BOOLEAN := TRUE;
    --
    CURSOR c_usr IS
      SELECT trc_yn
      FROM   t_99_10_ssu
      WHERE  UPPER(lgn_id) = UPPER(v_usr);
    --
  BEGIN
    --
    v_usr := NVL(pi_usr,v('APP_USER'));
    --
    OPEN  c_usr;
    FETCH c_usr INTO v_lcl;
    CLOSE c_usr;
    --
    IF NVL(v_lcl,'0') = '1' THEN 
      v_return := FALSE;
    END IF;
    --    
    RETURN v_return;
    --
  END fn_is_lcl_usr;
  --
END pkwf_11_mb;
Error report -
Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\package-body\pkwf_20_gen_body.sql
In command -
create or replace PACKAGE BODY pkwf_20_gen AS
  --
  /* Created By       : Femi Akintoye 
  ** Date Created     : 11-MAR-2016
  **
  ** PURPOSE: WF Routines for Preship Objects
  **
  ** MODIFICATION HISTORY:
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **  
  ** Copyright:  Neulogic Solutions Ltd, 2016
  **
  */
  --
  /* Private Routines */
  FUNCTION fn_usr_k RETURN NUMBER IS
  BEGIN
    RETURN pkwf_00.fn_usr_ky; --1;
  END fn_usr_k;
  --
  FUNCTION fn_mb_u_k RETURN NUMBER IS
    --
    v_k NUMBER;
    --
    CURSOR c_usr IS
      SELECT u_k
      FROM   wf_10_mb
      WHERE  UPPER(mb_id) = UPPER(v('APP_USER'));
    --
  BEGIN
    --
    OPEN  c_usr;
    FETCH c_usr INTO v_k;
    CLOSE c_usr;
    --
    RETURN v_k;
    --
  END fn_mb_u_k;
  --
  -- Current Document Key
  FUNCTION fn_dc_k RETURN NUMBER IS
  BEGIN
    RETURN apex_util.get_session_state('AI_DC_K');
  END fn_dc_k;
  --
  -- Execute post task process
  FUNCTION fn_exec_prc(pi_prc_dsc  IN VARCHAR2,
                       pi_use_par  IN BOOLEAN,
                       pi_dc_k     IN NUMBER,
                       pi_dc_tk_k  IN NUMBER,
                       pi_p1       IN VARCHAR2 DEFAULT NULL,
                       pi_p2       IN VARCHAR2 DEFAULT NULL,
                       pi_p3       IN VARCHAR2 DEFAULT NULL,
                       pi_p4       IN VARCHAR2 DEFAULT NULL,
                       pi_p5       IN VARCHAR2 DEFAULT NULL) RETURN NUMBER IS
    --
    v_exec_txt VARCHAR2(1000);
    v_cur_id   NUMBER;
    v_dummy    NUMBER;
    --
  BEGIN
    BEGIN
      --
      IF pi_use_par THEN
        v_exec_txt := 'BEGIN '||
                       pi_prc_dsc||' (pi_dc_k => '''||pi_dc_k||''', '||
                                   '  pi_dc_tk_k => '''||pi_dc_tk_k||''', '||
                                   '  pi_p1 => '''||pi_p1||''', '||
                                   '  pi_p2 => '''||pi_p2||''', '||
                                   '  pi_p3 => '''||pi_p3||''', '||
                                   '  pi_p4 => '''||pi_p4||''', '||
                                   '  pi_p5 => '''||pi_p5||''' ); '||
                      'END;';
      ELSE
        v_exec_txt := 'BEGIN '||
                       pi_prc_dsc||' (pi_dc_k => '''||pi_dc_k||''', '||
                                   '  pi_dc_tk_k => '''||pi_dc_tk_k||''' ); '||
                      'END;';
      END IF;
logger.log('CALLING ROUTINE '||v_exec_txt,'exec');        
      --
      -- Use Dynamic SQL to execute procedure
      v_cur_id := DBMS_SQL.OPEN_CURSOR;
      DBMS_SQL.PARSE (v_cur_id, v_exec_txt, DBMS_SQL.NATIVE);
      v_dummy := DBMS_SQL.EXECUTE(v_cur_id);
      DBMS_SQL.CLOSE_CURSOR(v_cur_id);
      --
    EXCEPTION
      WHEN OTHERS THEN
      BEGIN
        IF DBMS_SQL.IS_OPEN (v_cur_id) THEN
          DBMS_SQL.CLOSE_CURSOR (v_cur_id);
        END IF;
        RAISE; -- Reraise the exeception that caused failure
      END;
    END;
    --
    RETURN 0;
    --
  END fn_exec_prc;
  --
  -- Execute post action
  FUNCTION fn_post_act(pi_act  IN wf_20_dc_ac%ROWTYPE) RETURN NUMBER IS
    v_r     wf_20_dc_ac%ROWTYPE := pi_act;
  BEGIN
    --
    v_r.row_key  := pkwf_00_00.fn_rk;
    v_r.bus_dt   := TRUNC(SYSDATE);
    v_r.sys_dtt  := SYSDATE;
    v_r.ac_sq_no := pkwf_00_00.fn_act;
    v_r.ac_dtt   := SYSDATE;
    v_r.mb_k     := fn_mb_u_k;
    -- 
    INSERT
      INTO wf_20_dc_ac
    VALUES v_r;
    --
    RETURN 0;
    --
  END fn_post_act;
  --
  FUNCTION fn_get_mb (pi_mb_k IN NUMBER) RETURN wf_10_mb%ROWTYPE IS
    r_mb   wf_10_mb%ROWTYPE;
  BEGIN
    --
    BEGIN
      SELECT *
        INTO r_mb
        FROM wf_10_mb
       WHERE u_k = pi_mb_k;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'Unable to locate user information. Please contact administrator ['||pi_mb_k||']');
      WHEN TOO_MANY_ROWS THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'Configuration for this user is duplicated. Please contact administrator ['||pi_mb_k||']');
    END;
    --
    RETURN r_mb;
    --
  END fn_get_mb;
  --
  /* Public Routines */
  --
  -- General processing routine template. Does nothing
  PROCEDURE pr_gen_prc(pi_dc_k    IN NUMBER,
                       pi_dc_tk_k IN NUMBER,
                       pi_p1      IN VARCHAR2 DEFAULT NULL,
                       pi_p2      IN VARCHAR2 DEFAULT NULL,
                       pi_p3      IN VARCHAR2 DEFAULT NULL,
                       pi_p4      IN VARCHAR2 DEFAULT NULL,
                       pi_p5      IN VARCHAR2 DEFAULT NULL) IS
  BEGIN
logger.log('Entering default processing');  
    NULL;
logger.log('Leaving default processing');
  END pr_gen_prc;
  --
  --
  FUNCTION fn_get_dc (pi_dc_k IN NUMBER) RETURN wf_20_dc%ROWTYPE IS
    r_dc   wf_20_dc%ROWTYPE;
  BEGIN
    --
    BEGIN
      SELECT *
        INTO r_dc
        FROM wf_20_dc
       WHERE row_key = pi_dc_k;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'Unable to locate process application information. Please contact administrator ['||pi_dc_k||']');
      WHEN TOO_MANY_ROWS THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'Configuration for this process application is duplicated. Please contact administrator ['||pi_dc_k||']');
    END;
    --
    RETURN r_dc;
    --
  END fn_get_dc;
  --
  --
  FUNCTION fn_u_ot_tk RETURN OT$_WF_DC_TK_TB PIPELINED IS
    --
 --   t_tk     OT$_WF_DC_TK_TB := OT$_WF_DC_TK_TB();
    v_tk     OT$_WF_DC_TK := OT$_WF_DC_TK();       
    --
    v_u_k    wf_00_00_dtd.n38%TYPE := fn_mb_u_k;
    --
    CURSOR cur_rec IS
    SELECT tp.row_key tp_k, tp.tp_id, tp.tp_dsc, tp.rp_id,
           dc.row_key dc_k, dc.dc_id, dc.dc_dsc, dc.st_dtt, dc.cr_sq_no,
           dk.row_key dc_tk_k,
           tk.tk_id cr_seq_tk_id, tk.tk_dsc cr_seq_tk_dsc
      FROM wf_20_dc dc, wf_20_dc_tk dk, wf_10_tp tp, wf_10_tp_tk tk,
           wf_10_rl_mb rm, wf_10_mb mb
     WHERE dc.tp_k = tp.row_key
       AND dc.tp_k = tk.tp_k
       AND dc.cr_sq_no = tk.seq_no
       AND dk.dc_k = dc.row_key
       AND dk.tk_k = tk.row_key
       AND dk.mb_k IS NULL
       AND tk.ac_rl_k = rm.rl_k
       AND rm.mb_k = mb.u_k
       AND mb.u_k = v_u_k
    ORDER BY dc.st_dtt ASC;
    --
  BEGIN
    --
    --t_tk.DELETE;
    --
    FOR c1 IN cur_rec LOOP
      --
      v_tk.tp_k          := c1.tp_k;
      v_tk.tp_id         := c1.tp_id;   
      v_tk.tp_dsc        := c1.tp_dsc;
      v_tk.rp_id         := c1.rp_id;
      v_tk.dc_k          := c1.dc_k;  
      v_tk.dc_id	       := c1.dc_id;   
      v_tk.dc_dsc        := c1.dc_dsc; 
      v_tk.st_dtt        := c1.st_dtt;   
      v_tk.dc_tk_k       := c1.dc_tk_k;    
      v_tk.cr_seq_no     := c1.cr_sq_no;     
      v_tk.cr_seq_tk_id  := c1.cr_seq_tk_id;
      v_tk.cr_seq_tk_dsc := c1.cr_seq_tk_dsc;
      --
      BEGIN
        SELECT MAX(ac_dtt)
          INTO v_tk.ls_ac_dtt
          FROM wf_20_dc_ac
         WHERE dc_tk_k = c1.dc_tk_k;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          v_tk.ls_ac_dtt     := NULL;
      END;
      --
      PIPE ROW(v_tk);
      --
    END LOOP;
    --
    RETURN;
    --
  END fn_u_ot_tk;
  --
  --
  FUNCTION fn_m_tk RETURN OT$_WF_DC_TK_TB PIPELINED IS
    --
    t_tk     OT$_WF_DC_TK_TB := OT$_WF_DC_TK_TB();
    v_tk     OT$_WF_DC_TK := OT$_WF_DC_TK();       
    --
    v_u_k    wf_00_00_dtd.n38%TYPE := fn_mb_u_k;
    v_y      wf_00_00_dtd.n38%TYPE;
    --
    CURSOR cur_rec IS
    SELECT tp.row_key tp_k, tp.tp_id, tp.tp_dsc, tp.rp_id,
           dc.row_key dc_k, dc.dc_id, dc.dc_dsc, dc.st_dtt, dc.cr_sq_no,
           dk.row_key dc_tk_k,
           tk.row_key cr_seq_tk_k, tk.tk_id cr_seq_tk_id, tk.tk_dsc cr_seq_tk_dsc
      FROM wf_20_dc dc, wf_20_dc_tk dk, wf_10_tp tp, wf_10_tp_tk tk,
           wf_10_rl_mb rm, wf_10_mb mb
     WHERE dc.tp_k = tp.row_key
       AND dc.tp_k = tk.tp_k
       AND dc.cr_sq_no = tk.seq_no
       AND dk.dc_k = dc.row_key
       AND dk.tk_k = tk.row_key
       AND dk.mb_k = mb.u_k
       AND dk.ed_dtt IS NULL
       AND tk.ac_rl_k = rm.rl_k
       AND rm.mb_k = mb.u_k
       AND mb.u_k = v_u_k
       AND dc.dc_st_dm <> 'R'
    ORDER BY dc.st_dtt ASC;
    --
  BEGIN
    --
    t_tk.DELETE;
    --
    FOR c1 IN cur_rec LOOP
      --
      v_tk.tp_k          := c1.tp_k;
      v_tk.tp_id         := c1.tp_id;   
      v_tk.tp_dsc        := c1.tp_dsc;
      v_tk.rp_id         := c1.rp_id;
      v_tk.dc_k          := c1.dc_k;  
      v_tk.dc_id	       := c1.dc_id;   
      v_tk.dc_dsc        := c1.dc_dsc; 
      v_tk.st_dtt        := c1.st_dtt;   
      v_tk.dc_tk_k       := c1.dc_tk_k;    
      v_tk.cr_seq_no     := c1.cr_sq_no;  
      v_tk.cr_seq_tk_k   := c1.cr_seq_tk_k;   
      v_tk.cr_seq_tk_id  := c1.cr_seq_tk_id;
      v_tk.cr_seq_tk_dsc := c1.cr_seq_tk_dsc;
      --
      BEGIN
        SELECT MAX(ac_dtt)
          INTO v_tk.ls_ac_dtt
          FROM wf_20_dc_ac
         WHERE dc_tk_k = c1.dc_tk_k;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          v_tk.ls_ac_dtt     := NULL;
      END;
      --
      BEGIN
        SELECT COUNT(tp_k)
        INTO   v_y
        FROM   wf_10_tp_tk
        WHERE  tp_k = c1.tp_k;
      END;  
      v_tk.tk_stp := c1.cr_sq_no||' of '||TO_CHAR(v_y);
      --
      PIPE ROW(v_tk);
      --
    END LOOP;
    --
    RETURN;
    --
  END fn_m_tk;
  --
  -- Coporate Documents
  --
  FUNCTION fn_cpr_doc RETURN OT$_WF_DC_CPR_DOC_TB PIPELINED IS
    --
    t_tk     OT$_WF_DC_CPR_DOC_TB := OT$_WF_DC_CPR_DOC_TB();
    v_tk     OT$_WF_DC_CPR_DOC    := OT$_WF_DC_CPR_DOC();       
    --
    v_dc_k    wf_00_00_dtd.n38%TYPE := fn_dc_k;
    --
    CURSOR cur_rec IS
    SELECT dc.row_key dc_k, dc.dc_id, 
           dd.id doc_id, dd.dsc doc_dsc,
           im.im_blb doc_blb
      FROM wf_30_dc dc, wf_vd_cpr_doc dd, 
           wf_30_dc_im im
     WHERE dc.row_key = im.dc_k
       AND im.im_tp_dm = dd.id
    ORDER BY dd.dsc ASC;
    --
  BEGIN
    --
    t_tk.DELETE;
    --
    FOR c1 IN cur_rec LOOP
      --
      v_tk.dc_k          := c1.dc_k;
      v_tk.dc_id         := c1.dc_id;   
      v_tk.doc_id        := c1.doc_id;
      v_tk.doc_dsc       := c1.doc_dsc;
      v_tk.doc_blb       := c1.doc_blb; 
      --
    END LOOP;
    --
    RETURN;
    --
  END fn_cpr_doc;
  --
  -- Document Task Status
  FUNCTION fn_dc_tk_st(pi_dc_k IN NUMBER) RETURN OT$_WF_DC_ST_TB PIPELINED IS
    --
    t_tk     OT$_WF_DC_ST_TB := OT$_WF_DC_ST_TB();
    v_tk     OT$_WF_DC_ST := OT$_WF_DC_ST();       
    --
    v_u_k    wf_00_00_dtd.n38%TYPE := fn_mb_u_k;
    --
    CURSOR cur_rec IS
    SELECT dk.row_key dc_tk_k, dk.dc_k, dk.tk_k, tk.tk_id, tk.tk_dsc, tk.seq_no, dk.st_dtt, dk.ed_dtt,
           mb.mb_id, mb.mb_dsc,
           CASE WHEN (ed_dtt IS NOT NULL) THEN 'done'
                WHEN (dk.mb_k =  v_u_k) AND (ed_dtt IS NULL) THEN 'sf_prog'
                WHEN (dk.mb_k <> v_u_k) AND (ed_dtt IS NULL) THEN 'ot_prog'
                WHEN (dk.mb_k IS NULL) THEN 'pending'
           ELSE 'unknown'
           END tk_st_id,
           CASE WHEN (ed_dtt IS NOT NULL) THEN 'Completed'
                WHEN (dk.mb_k =  v_u_k) AND (ed_dtt IS NULL) THEN 'In Progress (Myself)'
                WHEN (dk.mb_k <> v_u_k) AND (ed_dtt IS NULL) THEN 'In Progress (Others)'
                WHEN (dk.mb_k IS NULL) THEN 'Outstanding'
           ELSE 'Unknown'
           END tk_st_dsc
      FROM wf_20_dc_tk dk, wf_10_tp_tk tk, wf_10_mb mb
     WHERE dk.tk_k = tk.row_key
       AND dk.mb_k = mb.u_k (+)
       AND dk.dc_k = pi_dc_k
     ORDER BY tk.seq_no ASC;
    --
  BEGIN
    --
    t_tk.DELETE;
    --
    FOR c1 IN cur_rec LOOP
      --
      v_tk.dc_k       := c1.dc_k;
  --    v_tk.dc_id	    := c1.dc_id;
  --    v_tk.dc_dsc     := c1.dc_dsc;   
      v_tk.tk_k       := c1.tk_k;
      v_tk.tk_id      := c1.tk_id;      
      v_tk.tk_dsc     := c1.tk_dsc;
      v_tk.seq_no     := c1.seq_no;
      v_tk.st_dtt     := c1.st_dtt;
      v_tk.ed_dtt     := c1.ed_dtt;
      v_tk.mb_id      := c1.mb_id;
      v_tk.mb_dsc     := c1.mb_dsc;
      v_tk.tk_st_id   := c1.tk_st_id;
      v_tk.tk_st_dsc  := c1.tk_st_dsc;
      --
      BEGIN
        SELECT MAX(ac_dtt)
          INTO v_tk.ls_ac_dtt
          FROM wf_20_dc_ac
         WHERE dc_tk_k = c1.dc_tk_k;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          v_tk.ls_ac_dtt     := NULL;
      END;
      --
      PIPE ROW(v_tk);
      --
    END LOOP;
    --
    RETURN;
    --
  END fn_dc_tk_st;
  --
  -- Document Actions
  FUNCTION fn_dc_ac(pi_dc_k IN NUMBER, pi_dc_tk_k IN NUMBER DEFAULT NULL) RETURN OT$_WF_DC_AC_TB PIPELINED IS
    --
    t_tk     OT$_WF_DC_AC_TB := OT$_WF_DC_AC_TB();
    v_tk     OT$_WF_DC_AC := OT$_WF_DC_AC();       
    --
    v_u_k    wf_00_00_dtd.n38%TYPE := fn_usr_k;
    --
    CURSOR cur_rec IS
    SELECT dc.row_key dc_k, dc.dc_id, dc.dc_dsc,
           tk.row_key tk_k, tk.tk_id, tk.tk_dsc,
           ac.row_key ac_k, ac.dc_tk_k, ac.mb_k, 
           UPPER(mb.mb_id) mb_id, INITCAP(mb.mb_dsc) mb_dsc,
           ac.ac_sq_no, ac.ac_dtt, ac.ac_rmk, ac.ac_dm, dm.dsc ac_dm_dsc,
           ac.ac_p1, ac.ac_p2, ac.ac_p3, ac.ac_p4, ac.ac_p5,
           tk.p1_dsc, tk.p2_dsc, tk.p3_dsc, tk.p4_dsc, tk.p5_dsc,
           tk.p1_tp_dm, tk.p2_tp_dm, tk.p3_tp_dm, tk.p4_tp_dm, tk.p5_tp_dm
      FROM wf_20_dc dc, wf_20_dc_tk dk, wf_20_dc_ac ac, wf_10_tp_tk tk,
           wf_10_mb mb, wf_vd_00_ac_tp dm
     WHERE dc.row_key = pi_dc_k
       AND dk.row_key = NVL(pi_dc_tk_k, dk.row_key)
       AND dk.dc_k = dc.row_key
       AND ac.dc_tk_k = dk.row_key
       AND dk.tk_k = tk.row_key
       AND ac.mb_k = mb.u_k (+)
       AND ac.ac_dm = dm.ID (+)
     ORDER BY ac.ac_sq_no DESC;
    --
  BEGIN
    --
    t_tk.DELETE;
    --
    FOR c1 IN cur_rec LOOP
      --
      v_tk.dc_k      := c1.dc_k;
      v_tk.dc_id     := c1.dc_id;
      v_tk.dc_dsc    := c1.dc_dsc;
      v_tk.dc_tk_k   := c1.dc_tk_k;
      v_tk.tk_k      := c1.tk_k;
      v_tk.tk_id     := c1.tk_id;
      v_tk.tk_dsc    := c1.tk_dsc;
      v_tk.ac_k      := c1.ac_k;
      v_tk.ac_sq_no  := c1.ac_sq_no;
      v_tk.ac_dtt    := c1.ac_dtt;
      v_tk.ac_rmk    := c1.ac_rmk;
      v_tk.mb_k      := c1.mb_k;
      v_tk.mb_id     := c1.mb_id;
      v_tk.mb_dsc    := c1.mb_dsc;
      v_tk.ac_dm     := c1.ac_dm;
      v_tk.ac_dm_dsc := c1.ac_dm_dsc;
      v_tk.ac_p1_dsc := c1.p1_dsc;
      v_tk.ac_p1_tp  := c1.p1_tp_dm;
      v_tk.ac_p1     := c1.ac_p1;
      v_tk.ac_p2_dsc := c1.p2_dsc;
      v_tk.ac_p2_tp  := c1.p2_tp_dm;
      v_tk.ac_p2     := c1.ac_p2;
      v_tk.ac_p3_dsc := c1.p3_dsc;
      v_tk.ac_p3_tp  := c1.p3_tp_dm;
      v_tk.ac_p3     := c1.ac_p3;
      v_tk.ac_p4_dsc := c1.p4_dsc;
      v_tk.ac_p4_tp  := c1.p4_tp_dm;
      v_tk.ac_p4     := c1.ac_p4;
      v_tk.ac_p5_dsc := c1.p5_dsc;
      v_tk.ac_p5_tp  := c1.p5_tp_dm;
      v_tk.ac_p5     := c1.ac_p5;
      --
      PIPE ROW(v_tk);
      --
    END LOOP;
    --
    RETURN;
    --
  END fn_dc_ac;
  --
  -- Accept Task
  PROCEDURE pr_acc_tk(pi_dc_tk_k  IN NUMBER) IS
    --
    v_r      wf_20_dc_ac%ROWTYPE;
    r_mb     wf_10_mb%ROWTYPE;
    v_u_k    wf_00_00_dtd.n38%TYPE := fn_mb_u_k;
    v_mb_k   wf_00_00_dtd.n38%TYPE;
    v_ret    wf_00_00_dtd.n38%TYPE;
    --
  BEGIN
    --
    pkwf_00_vld.pr_reqd (pi_d => pi_dc_tk_k, pi_dsc => 'Task to be accepted not defined');
    --
    BEGIN
      --
      SELECT mb_k
        INTO v_mb_k
        FROM wf_20_dc_tk
       WHERE row_key = pi_dc_tk_k;
      --
      IF (v_mb_k IS NOT NULL) THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'This task has already been accepted by another user');
      END IF;
      --
      UPDATE wf_20_dc_tk
         SET mb_k = v_u_k
       WHERE row_key = pi_dc_tk_k;
      --
      r_mb := fn_get_mb(pi_mb_k => v_u_k);
      -- Insert 'xxx task concluded' moved to next task.
      v_r := NULL;
      --
      v_r.dc_tk_k := pi_dc_tk_k;
      v_r.ac_dm := '0';
      v_r.ac_rmk := 'Task Accepted ';--by user '||r_mb.mb_id;
      --
      v_ret := fn_post_act(pi_act => v_r);
      --
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'This task cannot be found');
      WHEN TOO_MANY_ROWS THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'This task is duplicated');
    END;
    --
  END pr_acc_tk;
  --
  -- Post Action
  PROCEDURE pr_act(pi_action   IN wf_20_dc_ac%ROWTYPE) IS
    --
    v_r     wf_20_dc_ac%ROWTYPE;
    r_dc_tk wf_20_dc_tk%ROWTYPE;
    v_ret   wf_00_00_dtd.n38%TYPE;
    --
  BEGIN
    IF NVL(pi_action.row_key,0) <> 0 THEN
      pkwf_00_00_err.pr_raise(pi_msg => 'You might be attemting to edit an action. This is not allowed');
    END IF;
    --
    BEGIN
      SELECT *
        INTO r_dc_tk
        FROM wf_20_dc_tk
       WHERE row_key = pi_action.dc_tk_k;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'Unable to locate the data definition for this task. Please contact administrator ['||pi_action.dc_tk_k||']');
    END;
    --
    -- Ensure that task selected is assigned to currently logged on user
    -- 
    v_r := pi_action; 
    --
    pkwf_00_vld.pr_reqd (pi_d => v_r.ac_rmk, pi_dsc => 'Action Remarks');
    pkwf_00_vld.pr_reqd (pi_d => v_r.ac_dm, pi_dsc => 'Action Type');
    --
    IF v_r.ac_dm = '1' THEN
      pkwf_00_flx.pr_v_data (pi_tk_k => r_dc_tk.tk_k,
                             pi_c_no => 1,
                             pi_data => v_r.ac_p1);
      --
      pkwf_00_flx.pr_v_data (pi_tk_k => r_dc_tk.tk_k,
                             pi_c_no => 2,
                             pi_data => v_r.ac_p2);
      --
      pkwf_00_flx.pr_v_data (pi_tk_k => r_dc_tk.tk_k,
                             pi_c_no => 3,
                             pi_data => v_r.ac_p3);
      --
      pkwf_00_flx.pr_v_data (pi_tk_k => r_dc_tk.tk_k,
                             pi_c_no => 4,
                             pi_data => v_r.ac_p4);
      --
      pkwf_00_flx.pr_v_data (pi_tk_k => r_dc_tk.tk_k,
                             pi_c_no => 5,
                             pi_data => v_r.ac_p5);
    END IF;
    --  
logger.log('Done validating FLEX ');
    v_ret := fn_post_act(pi_act => v_r);
logger.log('Done posting action state'||v_r.ac_dm);
    --
    -- Routine processing
    DECLARE
      r_tk   wf_10_tp_tk%ROWTYPE;
      r_n_tk wf_10_tp_tk%ROWTYPE;
      r_tp   wf_10_tp%ROWTYPE;
      --
      v_ret  NUMBER;
    BEGIN
      --
      BEGIN
        SELECT *
          INTO r_tk
          FROM wf_10_tp_tk
         WHERE row_key = r_dc_tk.tk_k;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          pkwf_00_00_err.pr_raise(pi_msg => 'Unable to locate the configuration of this task. Please contact administrator ['||pi_action.dc_tk_k||']');
        WHEN TOO_MANY_ROWS THEN
          pkwf_00_00_err.pr_raise(pi_msg => 'Configuration of this task is duplicated. Please contact administrator ['||pi_action.dc_tk_k||']');
      END;
      --
      BEGIN
        SELECT *
          INTO r_n_tk
          FROM wf_10_tp_tk A
         WHERE tp_k = r_tk.tp_k
           AND seq_no = (SELECT MIN(b.seq_no)
                           FROM wf_10_tp_tk b
                          WHERE b.tp_k = r_tk.tp_k
                            AND b.seq_no > r_tk.seq_no);
      EXCEPTION 
        WHEN NO_DATA_FOUND THEN
          NULL;
        WHEN TOO_MANY_ROWS THEN
          pkwf_00_00_err.pr_raise(pi_msg => 'Configuration of this subsequent task is duplicated. Please contact administrator ['||pi_action.dc_tk_k||']');
      END;
      --
      BEGIN
        SELECT *
          INTO r_tp
          FROM wf_10_tp
         WHERE row_key = r_tk.tp_k;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          pkwf_00_00_err.pr_raise(pi_msg => 'Unable to locate the configuration of this workflow type. Please contact administrator ['||pi_action.dc_tk_k||']');
        WHEN TOO_MANY_ROWS THEN
          pkwf_00_00_err.pr_raise(pi_msg => 'Configuration of this workflow type is duplicated. Please contact administrator ['||pi_action.dc_tk_k||']');
      END;
      --
      IF v_r.ac_dm = '1' THEN -- Accept
        -- Call post task routine
        IF r_tk.pst_prc IS NOT NULL THEN
logger.log('Executing Procedure '||r_tk.pst_prc);
          v_ret := fn_exec_prc(pi_prc_dsc  => r_tk.pst_prc,
                               pi_use_par  => TRUE,
                               pi_dc_k     => r_dc_tk.dc_k,
                               pi_dc_tk_k  => r_dc_tk.row_key,
                               pi_p1       => v_r.ac_p1,
                               pi_p2       => v_r.ac_p2,
                               pi_p3       => v_r.ac_p3,
                               pi_p4       => v_r.ac_p4,
                               pi_p5       => v_r.ac_p5);
logger.log('Done executing procedure '||r_tk.pst_prc);
        END IF;
        --
        UPDATE wf_20_dc_tk
           SET ed_dtt = SYSDATE
         WHERE row_key = r_dc_tk.row_key;
        --
--        -- Insert 'xxx task concluded' moved to next task.
--        v_r := NULL;
--        --
--        v_r.dc_tk_k := r_dc_tk.row_key;
--        v_r.ac_dm := '0';
--        v_r.ac_rmk := 'Task ['||r_tk.tk_dsc||'] Concluded Successfully.';
--        --
--        v_ret := fn_post_act(pi_act => v_r);
        --
logger.log('Is this last task? '||r_n_tk.row_key);
        IF r_n_tk.row_key IS NULL THEN         
          -- -- If last task, call global accept routine
          IF r_tp.acc_prc IS NOT NULL THEN
            v_ret := fn_exec_prc(pi_prc_dsc  => r_tp.acc_prc,
                                 pi_use_par  => FALSE,
                                 pi_dc_k     => r_dc_tk.dc_k,
                                 pi_dc_tk_k  => r_dc_tk.row_key);
          END IF;
          --
          -- Insert 'xxx task concluded' moved to next task.
          v_r := NULL;
          --
          v_r.dc_tk_k := r_dc_tk.row_key;
          v_r.ac_dm := '0';
          v_r.ac_rmk := 'Workflow Concluded Successfully';
          --
          v_ret := fn_post_act(pi_act => v_r);
          --
        ELSE
          -- -- Else call pre task routine for next task
          IF r_n_tk.pre_prc IS NOT NULL THEN
            v_ret := fn_exec_prc(pi_prc_dsc  => r_n_tk.pre_prc,
                                 pi_use_par  => FALSE,
                                 pi_dc_k     => r_dc_tk.dc_k,
                                 pi_dc_tk_k  => r_dc_tk.row_key);
          END IF;
          --
          UPDATE wf_20_dc
             SET cr_sq_no = r_n_tk.seq_no
           WHERE row_key = r_dc_tk.dc_k;
          --
          -- Send Alert to default mail group for this document
logger.log('GOT OUT HERE'||r_n_tk.acc_alt_id||' = '||r_n_tk.acc_eml);          
          IF (r_n_tk.acc_alt_id IS NOT NULL) AND (r_n_tk.acc_eml IS NOT NULL) THEN
logger.log('GOT IN HERE');          
            DECLARE
              v_al   pkwf_90_alt.v_alt;
            BEGIN
              v_al := NULL;
              v_al.pi_msg_id := r_n_tk.acc_alt_id;
              --
              v_al.pi_rcpt_adr := r_n_tk.acc_eml;
              -- Generate Alert
              v_al.pi_src_key   := 0; --v_dc.row_key;     
              v_al.pi_src_ref   := 'xx';  --v_dc.dc_id;
              v_al.pi_sbj1      := '';
              v_al.pi_sbj2      := pkwf_90_alt.fn_fmt_qty(pi_qty => 0);
              v_al.pi_sbj3      := ''; 
              v_al.pi_bdy1      := '';
              v_al.pi_bdy2      := '';
              v_al.pi_bdy3      := '';
              v_al.pi_bdy4      := '';
              v_al.pi_bdy5      := '';
              v_al.pi_bdy6      := '';
              v_al.pi_bdy7      := pkwf_90_alt.fn_fmt_qty(pi_qty => 0);
              --
              pkwf_90_alt.pr_crt_msg (pi_rec => v_al);
            END;
          END IF;
          --
        END IF;
        --
logger.log('Accept processing completed');
      ELSIF v_r.ac_dm = '2' THEN -- Reject
        -- Call global reject routine
        IF r_tp.rej_prc IS NOT NULL THEN
          v_ret := fn_exec_prc(pi_prc_dsc  => r_tp.rej_prc,
                               pi_use_par  => FALSE,
                               pi_dc_k     => r_dc_tk.dc_k,
                               pi_dc_tk_k  => r_dc_tk.row_key);
        END IF;
        --
        -- Insert 'xxx task concluded' moved to next task.
        v_r := NULL;
        --
        v_r.dc_tk_k := r_dc_tk.row_key;
        v_r.ac_dm := '0';
        v_r.ac_rmk := 'Workflow REJECTED. No further actions allowed';
        --
        v_ret := fn_post_act(pi_act => v_r);
        --
        UPDATE wf_20_dc
           SET dc_st_dm = 'R'
         WHERE row_key = r_dc_tk.dc_k;
        --
      ELSIF v_r.ac_dm = '3' THEN -- Revert
        --
        -- Ensure task is the most recent task accepted
        -- 
        -- Revert to previous task
        UPDATE wf_20_dc_tk
           SET mb_k = NULL,
               st_dtt = NULL
         WHERE row_key = r_dc_tk.row_key;
        --
        -- Insert 'xxx task concluded' moved to next task.
        v_r := NULL;
        --
        v_r.dc_tk_k := r_dc_tk.row_key;
        v_r.ac_dm := '0';
        v_r.ac_rmk := 'Workflow REVERTED to previous state';
        --
        v_ret := fn_post_act(pi_act => v_r);
        --
      END IF;
    END;
    --
logger.log('Completed action processing');
  EXCEPTION
    WHEN OTHERS THEN
      logger.log(dbms_utility.format_error_backtrace, 'wferr', dbms_utility.format_error_stack);
      RAISE;
  END pr_act;
  --
  FUNCTION fn_cpr_doc_links(pi_app_id IN VARCHAR2) RETURN VARCHAR2 IS
    --
    v_arr2   apex_application_global.vc_arr2; 
    v_return VARCHAR2(4000);
    --
  BEGIN
    --
    SELECT '<a href="'|| doc_link ||'" alt="View Document">'|| doc_dsc || '</a>'
    BULK COLLECT 
    INTO v_arr2
    FROM (SELECT doc_dsc,
                 apex_util.prepare_url(p_url => 'f?p='||v('APP_ID') || ':1:' || v('APP_SESSION') || '::NO::P1_ID,P1_TYPE:' || pi_app_id || ',' ||doc_id) as doc_link
          FROM   wf_vl_20_cpr_doc
          WHERE  dc_id = pi_app_id)
          ORDER BY doc_dsc;
    --
    v_return := apex_util.table_to_string(v_arr2, ',  ');
    --
    RETURN v_return;
    --
  END fn_cpr_doc_links;
  --
END pkwf_20_gen;
Error report -
Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\package-body\pkwf_30_am_if_mnd_body.sql
In command -
CREATE OR REPLACE PACKAGE BODY pkwf_30_am_if_mnd AS
  --
  /* Created By       : Femi Akintoye 
  ** Date Created     : 11-MAR-2016
  **
  ** PURPOSE: WF Routines for Preship Objects
  **
  ** MODIFICATION HISTORY:
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **  
  ** Copyright:  Neulogic Solutions Ltd, 2016
  **
  */
  --
  /* Private Routines */
  --
  /* Public Routines */
  --
  -- Insert/Validation of document
  FUNCTION fn_ins(pi_rec IN wf_vi_30_am_if_mnd%ROWTYPE) RETURN pkwf_90_gen.r_ret IS
    v_r     wf_vi_30_am_if_mnd%ROWTYPE := pi_rec;
    v_k     wf_00_00_dtd.n38%TYPE;
    v_ret   pkwf_90_gen.r_ret;
  BEGIN
    --
    v_ret.ret_cd := 0;
    --
    BEGIN
      --
      v_r.d_id := 'WFVI30AMIFMND';
      --pkwf_00_vld.pr_reqd (pi_d => v_r.dc_tp_k, pi_dsc => 'Document Type');
      v_r.dc_tp_k := 0;
      v_r.dc_st_dm := '0';
      v_r.dc_jsn   := NULL;
      v_r.dc_lnk_yn := '0';
      --
--      v_r.cus_id,
      v_r.fnd_id    := pkwf_30_gen.fn_set_fld(v_r.fnd_id);
      pkwf_00_vld.pr_reqd (pi_d => v_r.fnd_id, pi_dsc => 'Redemption Fund');
--      v_r.fnd_dsc,
--      v_r.ast_tp_dm,
--      v_r.ast_tp_dsc,
--      v_r.ast_cl_dsc,
--      v_r.ast_scl_dsc,
--      v_r.ast_dsc,
--      v_r.ast_curr_id,
--      v_r.ast_curr_ds,
      v_r.if_acct_id    := pkwf_30_gen.fn_set_fld(v_r.if_acct_id);
      pkwf_00_vld.pr_reqd (pi_d => v_r.if_acct_id, pi_dsc => 'Redemption Account');
--      v_r.mf_acct_dsc,
--      v_r.eff_dt,
--      v_r.tenor_dsc,
--      v_r.mat_dt,
--      v_r.unt_qty,
--      v_r.cur_prc,
--      v_r.hld_val,
--      v_r.cur_val,
--      v_r.rdp_unt
      --
      v_r.row_key := pkwf_00_00.fn_rk; 
      v_r.dc_id := pkwf_30_gen.fn_g_doc_id;
      v_r.dc_dtt   := SYSDATE;
      --
      -- Create record in object
      INSERT
        INTO wf_vi_30_am_if_mnd
      VALUES v_r;
      --
      v_ret.po_dc_k := v_r.row_key;
      --
      pkwf_30_gen.pr_set_dc_dtl(pi_d_id   => v_r.d_id,
                                pi_dc_id  => v_r.dc_id,
                                pi_dc_dsc => 'EXCEPTIONAL MANDATE FROM '||v_r.if_acct_dsc);
      --     
    EXCEPTION
      WHEN OTHERS THEN
      v_ret.ret_cd  := SQLCODE;
      --v_ret.rt_id  := 'ON20';
      v_ret.err_dsc := dbms_utility.format_error_stack;
      v_ret.err_sta := dbms_utility.format_error_backtrace;
    END;
    --
logger.log(v_r.d_id||' RETURNED '||v_ret.ret_cd||' '||v_ret.err_dsc, 'ins', v_ret.err_sta);    
    RETURN v_ret;
    --
  END fn_ins;
  -- 
  --
  --
END pkwf_30_am_if_mnd; 
Error report -
Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\package-body\pkwf_30_am_mf_rdm_body.sql
In command -
CREATE OR REPLACE PACKAGE BODY pkwf_30_am_mf_rdm AS
  --
  /* Created By       : Femi Akintoye 
  ** Date Created     : 11-MAR-2016
  **
  ** PURPOSE: WF Routines for Preship Objects
  **
  ** MODIFICATION HISTORY:
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **  
  ** Copyright:  Neulogic Solutions Ltd, 2016
  **
  */
  --
  /* Private Routines */
  --
  /* Public Routines */
  --
  -- Insert/Validation of document
  FUNCTION fn_ins(pi_rec IN wf_vi_30_am_mf_rdm%ROWTYPE) RETURN pkwf_90_gen.r_ret IS
    v_r     wf_vi_30_am_mf_rdm%ROWTYPE := pi_rec;
    v_k     wf_00_00_dtd.n38%TYPE;
    v_ret   pkwf_90_gen.r_ret;
  BEGIN
    --
    v_ret.ret_cd := 0;
    --
    BEGIN
      --
      v_r.d_id := 'WFVI30AMMFRDM';
      --pkwf_00_vld.pr_reqd (pi_d => v_r.dc_tp_k, pi_dsc => 'Document Type');
      v_r.dc_tp_k := 0;
      v_r.dc_st_dm := '0';
      v_r.dc_jsn   := NULL;
      v_r.dc_lnk_yn := '0';
      --
--      v_r.cus_id,
      v_r.fnd_id    := pkwf_30_gen.fn_set_fld(v_r.fnd_id);
      pkwf_00_vld.pr_reqd (pi_d => v_r.fnd_id, pi_dsc => 'Redemption Fund');
--      v_r.fnd_dsc,
--      v_r.ast_tp_dm,
--      v_r.ast_tp_dsc,
--      v_r.ast_cl_dsc,
--      v_r.ast_scl_dsc,
--      v_r.ast_dsc,
--      v_r.ast_curr_id,
--      v_r.ast_curr_ds,
      v_r.mf_acct_id    := pkwf_30_gen.fn_set_fld(v_r.mf_acct_id);
      pkwf_00_vld.pr_reqd (pi_d => v_r.mf_acct_id, pi_dsc => 'Redemption Account');
--      v_r.mf_acct_dsc,
--      v_r.eff_dt,
--      v_r.tenor_dsc,
--      v_r.mat_dt,
--      v_r.unt_qty,
--      v_r.cur_prc,
--      v_r.hld_val,
--      v_r.cur_val,
--      v_r.rdp_unt
      --
      v_r.row_key := pkwf_00_00.fn_rk; 
      v_r.dc_id := pkwf_30_gen.fn_g_doc_id;
      v_r.dc_dtt   := SYSDATE;
      --
      -- Create record in object
      INSERT
        INTO wf_vi_30_am_mf_rdm
      VALUES v_r;
      --
      v_ret.po_dc_k := v_r.row_key;
      --
      pkwf_30_gen.pr_set_dc_dtl(pi_d_id   => v_r.d_id,
                                pi_dc_id  => v_r.dc_id,
                                pi_dc_dsc => 'REDEMPTION-'||v_r.rdp_unt||' Units of '||v_r.fnd_dsc||' by '||v_r.mf_acct_dsc);
      --     
    EXCEPTION
      WHEN OTHERS THEN
      v_ret.ret_cd  := SQLCODE;
      --v_ret.rt_id  := 'ON20';
      v_ret.err_dsc := dbms_utility.format_error_stack;
      v_ret.err_sta := dbms_utility.format_error_backtrace;
    END;
    --
logger.log(v_r.d_id||' RETURNED '||v_ret.ret_cd||' '||v_ret.err_dsc, 'ins', v_ret.err_sta);    
    RETURN v_ret;
    --
  END fn_ins;
  --
  -- General processing routine, new customer registration, 
  -- Verify customer record, if ok
  -- -- Create customer
  -- -- Create cash account
  -- -- Create portfolio
  PROCEDURE pr_cre_rdm(pi_dc_k    IN NUMBER,
                       pi_dc_tk_k IN NUMBER,
                       pi_p1      IN VARCHAR2 DEFAULT NULL,
                       pi_p2      IN VARCHAR2 DEFAULT NULL,
                       pi_p3      IN VARCHAR2 DEFAULT NULL,
                       pi_p4      IN VARCHAR2 DEFAULT NULL,
                       pi_p5      IN VARCHAR2 DEFAULT NULL) IS
  BEGIN
logger.log('AM NEW TASK - CONFIRM DATA VERIFIED AND CREATE CUSTOMER, ');    
    -- Create redemption record
--    DECLARE
--      v_cus  pkwf_90_gen.r_cs_new;
--      v_ret  pkwf_90_gen.r_ret;
--      v_dc_id wf_00_00_dtd.c50%TYPE;
--    BEGIN
--      --
--      SELECT dc_id
--        INTO v_dc_id
--        FROM wf_20_dc
--       WHERE row_key = pi_dc_k;
--      --
--      SELECT *
--        INTO v_cus
--        FROM wf_vi_30_cs_new
--       WHERE dc_id = v_dc_id;
--      --
--      pkwf_89_cs.pr_prc_ctc(pi_rec => v_cus);
--      --
--    EXCEPTION
--      WHEN NO_DATA_FOUND THEN
--        pkwf_00_00_err.pr_raise(pi_msg => 'The source document record found ['||pi_dc_k||']');
--      WHEN TOO_MANY_ROWS THEN
--        pkwf_00_00_err.pr_raise(pi_msg => 'The source document record is duplicated');
--    END;
    --
    -- Create portfolio/cash account/market account
    --
  EXCEPTION
    WHEN OTHERS THEN
      logger.log(dbms_utility.format_error_backtrace, 'wfcsnew', dbms_utility.format_error_stack);
      RAISE;
  END pr_cre_rdm;
  -- 
  --
  --
END pkwf_30_am_mf_rdm; 
Error report -
Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\package-body\pkwf_30_ch_wdr_body.sql
In command -
CREATE OR REPLACE PACKAGE BODY pkwf_30_ch_wdr AS
  --
  /* Created By       : Femi Akintoye 
  ** Date Created     : 11-MAR-2016
  **
  ** PURPOSE: WF Routines for Preship Objects
  **
  ** MODIFICATION HISTORY:
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **  
  ** Copyright:  Neulogic Solutions Ltd, 2016
  **
  */
  --
  /* Private Routines */
  --
  /* Public Routines */
  --
  -- Insert/Validation of document
  FUNCTION fn_ins(pi_rec IN wf_vi_30_ch_wdr%ROWTYPE) RETURN pkwf_90_gen.r_ret IS
    v_r     wf_vi_30_ch_wdr%ROWTYPE := pi_rec;
    v_k     wf_00_00_dtd.n38%TYPE;
    v_ret   pkwf_90_gen.r_ret;
  BEGIN
    --
    v_ret.ret_cd := 0;
    --
    BEGIN
      --
      v_r.d_id := 'WFVI30CHWDR';
--      pkwf_00_vld.pr_reqd (pi_d => v_r.dc_tp_k, pi_dsc => 'Document Type');
      v_r.dc_tp_k := 0;
      v_r.dc_st_dm := '0';
      v_r.dc_jsn   := NULL;
      --
      v_r.ac_id    := pkwf_30_gen.fn_set_fld(v_r.ac_id);
      pkwf_00_vld.pr_reqd (pi_d => v_r.ac_id, pi_dsc => 'Account Number');
      pkwf_00_vld.pr_reqd (pi_d => v_r.wdr_amt, pi_dsc => 'Amount to Withdraw');
      --
      v_r.row_key := pkwf_00_00.fn_rk; 
      v_r.dc_id := pkwf_30_gen.fn_g_doc_id;
      v_r.dc_dtt   := SYSDATE;
      --
      -- Create record in object
      INSERT
        INTO wf_vi_30_ch_wdr
      VALUES v_r;
      --
      v_ret.po_dc_k := v_r.row_key;
      --
      pkwf_30_gen.pr_set_dc_dtl(pi_d_id   => v_r.d_id,
                                pi_dc_id  => v_r.dc_id,
                                pi_dc_dsc => 'WITHDRAWAL REQUEST '||v_r.ac_id||' ('||v_r.wdr_amt||')');
--      -- Configure workflow document link
--      DECLARE
--        v_dc    wf_20_dc%ROWTYPE;
--        v_dk    wf_20_dc_tk%ROWTYPE;
--        v_tp    wf_10_tp%ROWTYPE;
--        v_c     NUMBER(38);
--      BEGIN
--        --
--        BEGIN
--          SELECT *
--            INTO v_tp
--            FROM wf_10_tp
--           WHERE row_key = v_r.dc_tp_k;
--        EXCEPTION
--          WHEN NO_DATA_FOUND THEN
--            pkwf_00_00_err.pr_raise(pi_msg => 'Unable to locate the configuration of this workflow type. Please contact administrator ['||v_r.dc_tp_k||']');
--          WHEN TOO_MANY_ROWS THEN
--            pkwf_00_00_err.pr_raise(pi_msg => 'Configuration of this workflow type is duplicated. Please contact administrator ['||v_r.dc_tp_k||']');
--        END;
--        --
--        v_c := MOD(pkwf_00_00.fn_doc,100000);
--        --
--        v_dc.row_key   := pkwf_00_00.fn_rk; 
--        v_dc.bus_dt    := TRUNC(SYSDATE);
--        v_dc.sys_dtt   := SYSDATE;
--        v_dc.tp_k      := v_r.dc_tp_k;
--        v_dc.dc_id     := v_r.dc_id;
--        v_dc.dc_dsc    := 'WITHDRAWAL REQUEST '||v_r.ac_id||' ('||v_r.wdr_amt||')';
--        v_dc.st_dtt    := SYSDATE;
--        v_dc.ed_dtt    := NULL;
--        v_dc.dc_st_dm  := '0';
--        v_dc.cr_sq_no  := 1;
--        v_dc.tk_no     := 0;
--        --
--        --
--        INSERT
--          INTO wf_20_dc
--        VALUES v_dc;
--        --
--        FOR c1 IN (SELECT *
--                     FROM wf_10_tp_tk
--                    WHERE tp_k = v_r.dc_tp_k
--                    ORDER BY seq_no ASC)
--        LOOP
--          --
--          v_dk.row_key  := pkwf_00_00.fn_rk;
--          v_dk.bus_dt   := TRUNC(SYSDATE); 
--          v_dk.sys_dtt  := SYSDATE;
--          v_dk.dc_k     := v_dc.row_key;
--          v_dk.tk_k     := c1.row_key; 
--          v_dk.mb_k     := NULL;
--          v_dk.st_dtt   := NULL;
--          v_dk.ed_dtt   := NULL;
--          v_dk.ac_rmk   := NULL;
--          v_dk.dn_yn    := '0';
--          v_dk.tk_sq_no := c1.seq_no;
--          --
--          INSERT 
--            INTO wf_20_dc_tk
--          VALUES v_dk;
--          --
--        END LOOP;
--        --
--        -- Send Alert to default mail group for this document
--        IF (v_tp.acc_alt_id IS NOT NULL) AND (v_tp.acc_eml IS NOT NULL) THEN
--          DECLARE
--            v_al   pkwf_90_alt.v_alt;
--          BEGIN
--            v_al := NULL;
--            v_al.pi_msg_id := 'WF-0101';
--            --
--            v_al.pi_rcpt_adr := v_tp.acc_eml;
--            -- Generate Alert
--            v_al.pi_src_key   := v_dc.row_key;     
--            v_al.pi_src_ref   := v_dc.dc_id;
--            v_al.pi_sbj1      := '';
--            v_al.pi_sbj2      := pkwf_90_alt.fn_fmt_qty(pi_qty => 0);
--            v_al.pi_sbj3      := ''; 
--            v_al.pi_bdy1      := '';
--            v_al.pi_bdy2      := '';
--            v_al.pi_bdy3      := '';
--            v_al.pi_bdy4      := '';
--            v_al.pi_bdy5      := '';
--            v_al.pi_bdy6      := '';
--            v_al.pi_bdy7      := pkwf_90_alt.fn_fmt_qty(pi_qty => 0);
--            --
--            pkwf_90_alt.pr_crt_msg (pi_rec => v_al);
--          END;
--        END IF;
--        --
--      END;
      --
    EXCEPTION
      WHEN OTHERS THEN
      v_ret.ret_cd  := SQLCODE;
      --v_ret.rt_id  := 'ON20';
      v_ret.err_dsc := dbms_utility.format_error_stack;
      v_ret.err_sta := dbms_utility.format_error_backtrace;
    END;
    --
logger.log(v_r.d_id||' RETURNED '||v_ret.ret_cd||' '||v_ret.err_dsc, 'ins', v_ret.err_sta);    
    RETURN v_ret;
    --
  END fn_ins;
  --
  -- General processing routine, new customer registration, 
  -- Verify customer record, if ok
  -- -- Create customer
  -- -- Create cash account
  -- -- Create portfolio
  PROCEDURE pr_prc_vrf(pi_dc_k    IN NUMBER,
                       pi_dc_tk_k IN NUMBER,
                       pi_p1      IN VARCHAR2 DEFAULT NULL,
                       pi_p2      IN VARCHAR2 DEFAULT NULL,
                       pi_p3      IN VARCHAR2 DEFAULT NULL,
                       pi_p4      IN VARCHAR2 DEFAULT NULL,
                       pi_p5      IN VARCHAR2 DEFAULT NULL) IS
  BEGIN
logger.log('CS NEW TASK - CONFIRM DATA VERIFIED AND CREATE CUSTOMER, ');    
    -- Create customer
    DECLARE
      v_cus  pkwf_90_gen.r_cs_new;
      v_ret  pkwf_90_gen.r_ret;
      v_dc_id wf_00_00_dtd.c50%TYPE;
    BEGIN
      --
      SELECT dc_id
        INTO v_dc_id
        FROM wf_20_dc
       WHERE row_key = pi_dc_k;
      --
      SELECT *
        INTO v_cus
        FROM wf_vi_30_cs_new
       WHERE dc_id = v_dc_id;
      --
      pkwf_89_cs.pr_prc_ctc(pi_rec => v_cus);
      --
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'The source document record found ['||pi_dc_k||']');
      WHEN TOO_MANY_ROWS THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'The source document record is duplicated');
    END;
    --
    -- Create portfolio/cash account/market account
    --
  END pr_prc_vrf;
  --
  -- General processing routine, new customer registration
  -- -- Parameter - CSCS number
  -- -- Update / Create market account
  -- -- Register for WEB access
  -- -- Activate account
  PROCEDURE pr_prc_act(pi_dc_k    IN NUMBER,
                       pi_dc_tk_k IN NUMBER,
                       pi_p1      IN VARCHAR2 DEFAULT NULL,
                       pi_p2      IN VARCHAR2 DEFAULT NULL,
                       pi_p3      IN VARCHAR2 DEFAULT NULL,
                       pi_p4      IN VARCHAR2 DEFAULT NULL,
                       pi_p5      IN VARCHAR2 DEFAULT NULL) IS
  BEGIN
    NULL;
  END pr_prc_act;
  --
  -- General processing routine, new customer registration
  -- -- Parameter - CSCS number
  -- -- Update / Create market account
  -- -- Register for WEB access
  -- -- Activate account
  PROCEDURE pr_set_pmt(pi_dc_k    IN NUMBER,
                       pi_dc_tk_k IN NUMBER,
                       pi_p1      IN VARCHAR2 DEFAULT NULL,
                       pi_p2      IN VARCHAR2 DEFAULT NULL,
                       pi_p3      IN VARCHAR2 DEFAULT NULL,
                       pi_p4      IN VARCHAR2 DEFAULT NULL,
                       pi_p5      IN VARCHAR2 DEFAULT NULL) IS
    --
    v_dc wf_20_dc%ROWTYPE;
    --
  BEGIN
    --
    pkwf_00_vld.pr_reqd(pi_d => pi_p1, pi_dsc => 'Payment Number');
    --
    v_dc := pkwf_20_gen.fn_get_dc(pi_dc_k => pi_dc_k);
    --
    UPDATE wf_vi_30_ch_wdr
       SET pmt_no = pi_p1
     WHERE dc_id = v_dc.dc_id; 
    --
  END pr_set_pmt;
  --
  --
  --
  --
END pkwf_30_ch_wdr; 
Error report -
Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\package-body\pkwf_30_cs_new_body.sql
In command -
CREATE OR REPLACE PACKAGE BODY pkwf_30_cs_new AS
  --
  /* Created By       : Femi Akintoye 
  ** Date Created     : 11-MAR-2016
  **
  ** PURPOSE: WF Routines for Preship Objects
  **
  ** MODIFICATION HISTORY:
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **  
  ** Copyright:  Neulogic Solutions Ltd, 2016
  **
  */
  --
  /* Private Routines */
  --
  /* Public Routines */
  --
  -- Insert/Validation of document
  FUNCTION fn_ins(pi_rec IN wf_vi_30_cs_new%ROWTYPE) RETURN pkwf_90_gen.r_ret IS
    v_r     wf_vi_30_cs_new%ROWTYPE := pi_rec;
    v_k     wf_00_00_dtd.n38%TYPE;
    v_ret   pkwf_90_gen.r_ret;
  BEGIN
    --
    v_ret.ret_cd := 0;
    --
    BEGIN
      --
      v_r.d_id := 'WFVI30CSNEW';
      --pkwf_00_vld.pr_reqd (pi_d => v_r.dc_tp_k, pi_dsc => 'Document Type');
      v_r.dc_tp_k := 0;
      v_r.dc_st_dm := '0';
      v_r.dc_jsn   := NULL;
      --
      v_r.tt_dm    := pkwf_30_gen.fn_set_fld(v_r.tt_dm);
      IF v_r.tt_dm IS NOT NULL THEN
        v_k := pkwf_00_00.fn_get_ttl_k(pi_id => v_r.tt_dm);
      END IF;
      v_r.ls_nm    := pkwf_30_gen.fn_set_fld(v_r.ls_nm);
      pkwf_00_vld.pr_reqd (pi_d => v_r.ls_nm, pi_dsc => 'Last Name');
      v_r.md_nm    := pkwf_30_gen.fn_set_fld(v_r.md_nm);
      v_r.fi_nm    := pkwf_30_gen.fn_set_fld(v_r.fi_nm);
      pkwf_00_vld.pr_reqd (pi_d => v_r.fi_nm, pi_dsc => 'First Name');
      v_r.gdr_dm   := pkwf_30_gen.fn_set_fld(v_r.gdr_dm);
      pkwf_00_vld.pr_reqd (pi_d => v_r.gdr_dm, pi_dsc => 'Gender');
      pkwf_00_00_dmv.pr_val_cs_gdr(pi_dm => v_r.gdr_dm);
      pkwf_00_vld.pr_reqd (pi_d => v_r.dob_dt, pi_dsc => 'Date of Birth');
      pkwf_00_vld.pr_not_aft_sys_dt(pi_d => v_r.dob_dt, pi_dsc => 'Date of Birth');
      v_r.mar_st_dm   := pkwf_30_gen.fn_set_fld(v_r.mar_st_dm);
      pkwf_00_vld.pr_reqd (pi_d => v_r.mar_st_dm, pi_dsc => 'Marital Status');
      pkwf_00_00_dmv.pr_val_cs_mar(pi_dm => v_r.mar_st_dm);
      pkwf_00_vld.pr_reqd (pi_d => v_r.nty_cd, pi_dsc => 'Nationality');
      IF v_r.nty_cd IS NOT NULL THEN
        v_k := pkwf_00_00.fn_get_nty_k(pi_id => v_r.nty_cd);
      END IF;
      --
      v_r.pry_a_ad1      := pkwf_30_gen.fn_set_fld(v_r.pry_a_ad1);
      pkwf_00_vld.pr_reqd (pi_d => v_r.pry_a_ad1, pi_dsc => 'Primary Address Line 1');
      v_r.pry_a_ad2      := pkwf_30_gen.fn_set_fld(v_r.pry_a_ad2);
      v_r.pry_a_cty      := pkwf_30_gen.fn_set_fld(v_r.pry_a_cty);
      pkwf_00_vld.pr_reqd (pi_d => v_r.pry_a_cty, pi_dsc => 'Primary Address City');
      v_r.pry_a_sta_cd   := pkwf_30_gen.fn_set_fld(v_r.pry_a_sta_cd);
      v_r.pry_a_zip      := pkwf_30_gen.fn_set_fld(v_r.pry_a_zip);
      v_r.pry_a_ctr_cd   := pkwf_30_gen.fn_set_fld(v_r.pry_a_ctr_cd);
      pkwf_00_vld.pr_reqd (pi_d => v_r.pry_a_ctr_cd, pi_dsc => 'Primary Address Country');
      IF v_r.pry_a_ctr_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_r.pry_a_ctr_cd);
      END IF;
      IF v_r.pry_a_sta_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_r.pry_a_ctr_cd,
                                          pi_id     => v_r.pry_a_sta_cd);
      END IF;
      --
      v_r.pst_a_ad1      := pkwf_30_gen.fn_set_fld(v_r.pst_a_ad1);
      v_r.pst_a_ad2      := pkwf_30_gen.fn_set_fld(v_r.pst_a_ad2);
      v_r.pst_a_cty      := pkwf_30_gen.fn_set_fld(v_r.pst_a_cty);
      v_r.pst_a_sta_cd   := pkwf_30_gen.fn_set_fld(v_r.pst_a_sta_cd);
      v_r.pst_a_zip      := pkwf_30_gen.fn_set_fld(v_r.pst_a_zip);
      v_r.pst_a_ctr_cd   := pkwf_30_gen.fn_set_fld(v_r.pst_a_ctr_cd);
      IF v_r.pst_a_ctr_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_r.pst_a_ctr_cd);
      END IF;
      IF v_r.pst_a_sta_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_r.pst_a_ctr_cd,
                                          pi_id     => v_r.pst_a_sta_cd);
      END IF;
      --
      v_r.pry_em_ad      := pkwf_30_gen.fn_set_fld(v_r.pry_em_ad);
      pkwf_00_vld.pr_reqd (pi_d => v_r.pry_em_ad, pi_dsc => 'Primary Email Address');
      pkwf_00_vld.pr_valid_eml (pi_d => v_r.pry_em_ad, pi_dsc => 'Primary Email Address');
      v_r.sec_em_ad      := pkwf_30_gen.fn_set_fld(v_r.sec_em_ad);
      IF v_r.sec_em_ad IS NOT NULL THEN
        pkwf_00_vld.pr_valid_eml (pi_d => v_r.sec_em_ad, pi_dsc => 'Secondary Email Address');
      END IF;
      v_r.mbl_phn        := pkwf_30_gen.fn_set_fld(v_r.mbl_phn);
      pkwf_00_vld.pr_reqd (pi_d => v_r.mbl_phn, pi_dsc => 'Mobile Phone No.');
      --pkwf_00_vld.pr_valid_phn (pi_d => v_r.mbl_phn, pi_dsc => 'Mobile Phone No.');
      v_r.oth_phn        := pkwf_30_gen.fn_set_fld(v_r.oth_phn);
      --IF v_r.oth_phn IS NOT NULL THEN
      --  pkwf_00_vld.pr_valid_phn (pi_d => v_r.oth_phn, pi_dsc => 'Other Phone No.');
      --END IF;
      v_r.mmd_nm         := pkwf_30_gen.fn_set_fld(v_r.mmd_nm);
      pkwf_00_vld.pr_reqd (pi_d => v_r.mmd_nm, pi_dsc => 'Mothers Maiden Name');
      --
      pkwf_00_vld.pr_reqd (pi_d => v_r.nok_nm, pi_dsc => 'Next of Kin Name');
      IF v_r.nok_rln_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_rln_k(pi_id => v_r.nok_rln_cd);
      END IF;
      /*
      pkwf_00_vld.pr_reqd (pi_d => v_r.nok_phn, pi_dsc => 'Next of Kin Phone No');
      IF v_r.nok_phn IS NOT NULL THEN
        pkwf_00_vld.pr_valid_phn (pi_d => v_r.nok_phn, pi_dsc => 'Next of Kin Phone No.');
      END IF;
      */
      pkwf_00_vld.pr_reqd (pi_d => v_r.nok_a_ad1, pi_dsc => 'Next of Kin Address Line 1');
      v_r.nok_a_ad2      := pkwf_30_gen.fn_set_fld(v_r.nok_a_ad2);
      pkwf_00_vld.pr_reqd (pi_d => v_r.nok_a_cty, pi_dsc => 'Next of Kin Address City');
      v_r.nok_a_sta_cd   := pkwf_30_gen.fn_set_fld(v_r.nok_a_sta_cd);
      v_r.nok_a_zip      := pkwf_30_gen.fn_set_fld(v_r.nok_a_zip);
      pkwf_00_vld.pr_reqd (pi_d => v_r.nok_a_ctr_cd, pi_dsc => 'Next of Kin Address Country');
      IF v_r.nok_a_ctr_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_r.nok_a_ctr_cd);
      END IF;
      IF v_r.nok_a_sta_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_r.nok_a_ctr_cd,
                                          pi_id     => v_r.nok_a_sta_cd);
      END IF;
      --
      pkwf_00_vld.pr_reqd (pi_d => v_r.bk_nm, pi_dsc => 'Bank Name');
      pkwf_00_vld.pr_reqd (pi_d => v_r.bk_ac_no, pi_dsc => 'Bank Account No.');
      pkwf_00_vld.pr_reqd (pi_d => v_r.bk_bv_no, pi_dsc => 'BVN No.');
      v_r.bk_ac_nm      := pkwf_30_gen.fn_set_fld(v_r.bk_ac_nm);
      v_r.bk_br_nm      := pkwf_30_gen.fn_set_fld(v_r.bk_br_nm);
      v_r.bk_st_cd      := pkwf_30_gen.fn_set_fld(v_r.bk_st_cd);
      v_r.bk_a_ad1      := pkwf_30_gen.fn_set_fld(v_r.bk_a_ad1);
      v_r.bk_a_ad2      := pkwf_30_gen.fn_set_fld(v_r.bk_a_ad2);
      v_r.bk_a_cty      := pkwf_30_gen.fn_set_fld(v_r.bk_a_cty);
      v_r.bk_a_sta_cd   := pkwf_30_gen.fn_set_fld(v_r.bk_a_sta_cd);
      v_r.bk_a_zip      := pkwf_30_gen.fn_set_fld(v_r.bk_a_zip);
      v_r.bk_a_ctr_cd   := pkwf_30_gen.fn_set_fld(v_r.bk_a_ctr_cd);
      IF v_r.bk_a_ctr_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_r.bk_a_ctr_cd);
      END IF;
      IF v_r.bk_a_sta_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_r.bk_a_ctr_cd,
                                          pi_id     => v_r.bk_a_sta_cd);
      END IF;
      --
      v_r.ocp_nm        := pkwf_30_gen.fn_set_fld(v_r.ocp_nm);
      v_r.emp_nm        := pkwf_30_gen.fn_set_fld(v_r.emp_nm);
      v_r.emp_a_ad1      := pkwf_30_gen.fn_set_fld(v_r.emp_a_ad1);
      v_r.emp_a_ad2      := pkwf_30_gen.fn_set_fld(v_r.emp_a_ad2);
      v_r.emp_a_cty      := pkwf_30_gen.fn_set_fld(v_r.emp_a_cty);
      v_r.emp_a_sta_cd   := pkwf_30_gen.fn_set_fld(v_r.emp_a_sta_cd);
      v_r.emp_a_zip      := pkwf_30_gen.fn_set_fld(v_r.emp_a_zip);
      v_r.emp_a_ctr_cd   := pkwf_30_gen.fn_set_fld(v_r.emp_a_ctr_cd);
      IF v_r.emp_a_ctr_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_r.emp_a_ctr_cd);
      END IF;
      IF v_r.emp_a_sta_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_r.emp_a_ctr_cd,
                                          pi_id     => v_r.emp_a_sta_cd);
      END IF;
      v_r.emp_phn       := pkwf_30_gen.fn_set_fld(v_r.emp_phn);
      IF v_r.emp_phn IS NOT NULL THEN
        pkwf_00_vld.pr_valid_phn (pi_d => v_r.emp_phn, pi_dsc => 'Employer Phone No.');
      END IF;
      IF v_r.ann_inc_amt IS NOT NULL THEN
        pkwf_00_vld.pr_not_below_zero (pi_d => v_r.ann_inc_amt, pi_dsc => 'Annual Income Amount');
      END IF;
      --
--      IF NVL(v_r.jnt_yn, '0') = '1' THEN
--        v_r.j_tt_dm        := pkwf_30_gen.fn_set_fld(v_r.j_tt_dm);
--        IF v_r.j_tt_dm IS NOT NULL THEN
--          v_k := pkwf_00_00.fn_get_ttl_k(pi_id => v_r.j_tt_dm);
--        END IF;
--        v_r.j_ls_nm        := pkwf_30_gen.fn_set_fld(v_r.j_ls_nm);
--        pkwf_00_vld.pr_reqd (pi_d => v_r.j_ls_nm, pi_dsc => 'Joint Holder Last Name');
--        v_r.j_md_nm        := pkwf_30_gen.fn_set_fld(v_r.j_md_nm);
--        v_r.j_fi_nm        := pkwf_30_gen.fn_set_fld(v_r.j_fi_nm);
--        pkwf_00_vld.pr_reqd (pi_d => v_r.j_fi_nm, pi_dsc => 'Joint Holder First Name');
--        pkwf_00_vld.pr_reqd (pi_d => v_r.j_gdr_dm, pi_dsc => 'Joint Holder Gender');
--        pkwf_00_00_dmv.pr_val_cs_gdr(pi_dm => v_r.j_gdr_dm);
--        pkwf_00_vld.pr_reqd (pi_d => v_r.j_dob_dt, pi_dsc => 'Joint Holder Date of Birth');
--        pkwf_00_vld.pr_not_aft_sys_dt(pi_d => v_r.j_dob_dt, pi_dsc => 'Joint Holder Date of Birth');
--        pkwf_00_vld.pr_reqd (pi_d => v_r.j_nty_cd, pi_dsc => 'Joint Holder Nationality');
--        IF v_r.j_nty_cd IS NOT NULL THEN
--          v_k := pkwf_00_00.fn_get_nty_k(pi_id => v_r.j_nty_cd);
--        END IF;
--        pkwf_00_vld.pr_reqd (pi_d => v_r.j_pry_a_ad1, pi_dsc => 'Joint Address Line 1');
--        v_r.j_pry_a_ad2    := pkwf_30_gen.fn_set_fld(v_r.j_pry_a_ad2);
--        pkwf_00_vld.pr_reqd (pi_d => v_r.j_pry_a_cty, pi_dsc => 'Joint Holder Address City');
--        v_r.j_pry_a_sta_cd := pkwf_30_gen.fn_set_fld(v_r.j_pry_a_sta_cd);
--        v_r.j_pry_a_zip    := pkwf_30_gen.fn_set_fld(v_r.j_pry_a_zip);
--        pkwf_00_vld.pr_reqd (pi_d => v_r.j_pry_a_ctr_cd, pi_dsc => 'Joint Holder Address Country');
--        IF v_r.j_pry_a_ctr_cd IS NOT NULL THEN
--          v_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_r.j_pry_a_ctr_cd);
--        END IF;
--        IF v_r.j_pry_a_sta_cd IS NOT NULL THEN
--          v_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_r.j_pry_a_ctr_cd,
--                                            pi_id     => v_r.j_pry_a_sta_cd);
--        END IF;
--        pkwf_00_vld.pr_reqd (pi_d => v_r.j_pry_em_ad, pi_dsc => 'Joint Holder Email Address');
--        pkwf_00_vld.pr_reqd (pi_d => v_r.j_mbl_phn, pi_dsc => 'Joint Holder Mobile Phone');
--        v_r.j_pry_em_ad    := pkwf_30_gen.fn_set_fld(v_r.j_pry_em_ad);
--        IF v_r.j_pry_em_ad IS NOT NULL THEN
--          pkwf_00_vld.pr_valid_eml (pi_d => v_r.j_pry_em_ad, pi_dsc => 'Joint Holder Email Address');
--        END IF;
--        v_r.j_mbl_phn      := pkwf_30_gen.fn_set_fld(v_r.j_mbl_phn);
--        IF v_r.j_mbl_phn IS NOT NULL THEN
--          pkwf_00_vld.pr_valid_phn (pi_d => v_r.j_mbl_phn, pi_dsc => 'Joint Holder Mobile Phone');
--        END IF;
--      END IF;
      --    
      v_r.c_pic_yn := '0';
      v_r.c_sig_yn := '0';
      v_r.c_ubl_yn := '0';
      v_r.c_idc_yn := '0'; 
      --
      v_r.row_key := pkwf_00_00.fn_rk; 
      v_r.dc_id := pkwf_30_gen.fn_g_doc_id;
      v_r.dc_dtt   := SYSDATE;
      --
      -- Create record in object
      INSERT
        INTO wf_vi_30_cs_new
      VALUES v_r;
      --
      v_ret.po_dc_k := v_r.row_key;
      --
      pkwf_30_gen.pr_set_dc_dtl(pi_d_id   => v_r.d_id,
                                pi_dc_id  => v_r.dc_id,
                                pi_dc_dsc => UPPER(TRIM(v_r.ls_nm))||', '||INITCAP(v_r.fi_nm)||' '||INITCAP(v_r.md_nm));
--      -- Configure workflow document link
--      DECLARE
--        v_dc    wf_20_dc%ROWTYPE;
--        v_dk    wf_20_dc_tk%ROWTYPE;
--        v_tp    wf_10_tp%ROWTYPE;
--        v_c     NUMBER(38);
--      BEGIN
--        --
--        BEGIN
--          SELECT *
--            INTO v_tp
--            FROM wf_10_tp
--           WHERE row_key = v_r.dc_tp_k;
--        EXCEPTION
--          WHEN NO_DATA_FOUND THEN
--            pkwf_00_00_err.pr_raise(pi_msg => 'Unable to locate the configuration of this workflow type. Please contact administrator ['||v_r.dc_tp_k||']');
--          WHEN TOO_MANY_ROWS THEN
--            pkwf_00_00_err.pr_raise(pi_msg => 'Configuration of this workflow type is duplicated. Please contact administrator ['||v_r.dc_tp_k||']');
--        END;
--        --
--        v_c := MOD(pkwf_00_00.fn_doc,100000);
--        --
--        v_dc.row_key   := pkwf_00_00.fn_rk; 
--        v_dc.bus_dt    := TRUNC(SYSDATE);
--        v_dc.sys_dtt   := SYSDATE;
--        v_dc.tp_k      := v_r.dc_tp_k;
--        v_dc.dc_id     := v_r.dc_id;
--        v_dc.dc_dsc    := UPPER(TRIM(v_r.ls_nm))||', '||INITCAP(v_r.fi_nm)||' '||INITCAP(v_r.md_nm);
--        v_dc.st_dtt    := SYSDATE;
--        v_dc.ed_dtt    := NULL;
--        v_dc.dc_st_dm  := '0';
--        v_dc.cr_sq_no  := 1;
--        v_dc.tk_no     := 0;
--        --
--        INSERT
--          INTO wf_20_dc
--        VALUES v_dc;
--        --
--        FOR c1 IN (SELECT *
--                     FROM wf_10_tp_tk
--                    WHERE tp_k = v_r.dc_tp_k
--                    ORDER BY seq_no ASC)
--        LOOP
--          --
--          v_dk.row_key  := pkwf_00_00.fn_rk;
--          v_dk.bus_dt   := TRUNC(SYSDATE); 
--          v_dk.sys_dtt  := SYSDATE;
--          v_dk.dc_k     := v_dc.row_key;
--          v_dk.tk_k     := c1.row_key; 
--          v_dk.mb_k     := NULL;
--          v_dk.st_dtt   := NULL;
--          v_dk.ed_dtt   := NULL;
--          v_dk.ac_rmk   := NULL;
--          v_dk.dn_yn    := '0';
--          v_dk.tk_sq_no := c1.seq_no;
--          --
--          INSERT 
--            INTO wf_20_dc_tk
--          VALUES v_dk;
--          --
--        END LOOP;
--        --
--        -- Send Alert to default mail group for this document
--        IF (v_tp.acc_alt_id IS NOT NULL) AND (v_tp.acc_eml IS NOT NULL) THEN
--          DECLARE
--            v_al   pkwf_90_alt.v_alt;
--          BEGIN
--            v_al := NULL;
--            v_al.pi_msg_id := v_tp.acc_alt_id;
--            --
--            v_al.pi_rcpt_adr := v_tp.acc_eml;
--            -- Generate Alert
--            v_al.pi_src_key   := v_dc.row_key;     
--            v_al.pi_src_ref   := v_dc.dc_id;
--            v_al.pi_sbj1      := '';
--            v_al.pi_sbj2      := pkwf_90_alt.fn_fmt_qty(pi_qty => 0);
--            v_al.pi_sbj3      := ''; 
--            v_al.pi_bdy1      := '';
--            v_al.pi_bdy2      := '';
--            v_al.pi_bdy3      := '';
--            v_al.pi_bdy4      := '';
--            v_al.pi_bdy5      := '';
--            v_al.pi_bdy6      := '';
--            v_al.pi_bdy7      := pkwf_90_alt.fn_fmt_qty(pi_qty => 0);
--            --
--            pkwf_90_alt.pr_crt_msg (pi_rec => v_al);
--          END;
--        END IF;
--        --
--      END;
      --     
    EXCEPTION
      WHEN OTHERS THEN
      v_ret.ret_cd  := SQLCODE;
      --v_ret.rt_id  := 'ON20';
      v_ret.err_dsc := dbms_utility.format_error_stack;
      v_ret.err_sta := dbms_utility.format_error_backtrace;
    END;
    --
logger.log(v_r.d_id||' RETURNED '||v_ret.ret_cd||' '||v_ret.err_dsc, 'ins', v_ret.err_sta);    
    RETURN v_ret;
    --
  END fn_ins;
  --
  -- Set images as appropriate
  FUNCTION fn_set_img(pi_dc_k IN NUMBER) RETURN pkwf_90_gen.r_ret IS
    v_ret   pkwf_90_gen.r_ret;
  BEGIN
    --
    BEGIN
      --
      FOR c1 IN (SELECT *
                   FROM wf_30_dc_im
                  WHERE dc_k = pi_dc_k)
      LOOP
        IF c1.im_tp_dm = 'PC' THEN
          UPDATE wf_vi_30_cs_new
             SET pic_img = c1.im_blb,
                 c_pic_yn = '1'
           WHERE row_key = pi_dc_k;
        ELSIF c1.im_tp_dm = 'SG' THEN
          UPDATE wf_vi_30_cs_new
             SET sig_img = c1.im_blb,
                 c_sig_yn = '1'
           WHERE row_key = pi_dc_k;
        ELSIF c1.im_tp_dm = 'UB' THEN
          UPDATE wf_vi_30_cs_new
             SET ubl_img = c1.im_blb,
                 c_ubl_yn = '1'
           WHERE row_key = pi_dc_k;
        ELSIF c1.im_tp_dm = 'ID' THEN
          UPDATE wf_vi_30_cs_new
             SET idc_img = c1.im_blb,
                 c_idc_yn = '1'
           WHERE row_key = pi_dc_k;
        ELSE
          v_ret.ret_cd  := 99;
          v_ret.err_dsc := 'Unknown Image Type ['||c1.im_tp_dm||']';
          v_ret.err_sta := 'Unknown Image Type ['||c1.im_tp_dm||']';
        END IF;
        --
      END LOOP;
      --
    EXCEPTION
      WHEN OTHERS THEN
      v_ret.ret_cd  := SQLCODE;
      v_ret.err_dsc := dbms_utility.format_error_stack;
      v_ret.err_sta := dbms_utility.format_error_backtrace;
    END;
    --
logger.log(pi_dc_k||' IMG RETURNED '||v_ret.ret_cd||' '||v_ret.err_dsc);    
    RETURN v_ret;
    --
  END fn_set_img;
  --
  -- General processing routine, new customer registration, 
  -- Verify customer record, if ok
  -- -- Create customer
  -- -- Create cash account
  -- -- Create portfolio
  PROCEDURE pr_cre_rec(pi_dc_k    IN NUMBER,
                       pi_dc_tk_k IN NUMBER,
                       pi_p1      IN VARCHAR2 DEFAULT NULL,
                       pi_p2      IN VARCHAR2 DEFAULT NULL,
                       pi_p3      IN VARCHAR2 DEFAULT NULL,
                       pi_p4      IN VARCHAR2 DEFAULT NULL,
                       pi_p5      IN VARCHAR2 DEFAULT NULL) IS
  BEGIN
logger.log('CS NEW TASK - CONFIRM DATA VERIFIED AND CREATE CUSTOMER, ');    
    -- Create customer
    DECLARE
      v_cus  pkwf_90_gen.r_cs_new;
      v_ret  pkwf_90_gen.r_ret;
      v_dc_id wf_00_00_dtd.c50%TYPE;
    BEGIN
      --
      SELECT dc_id
        INTO v_dc_id
        FROM wf_20_dc
       WHERE row_key = pi_dc_k;
      --
      SELECT *
        INTO v_cus
        FROM wf_vi_30_cs_new
       WHERE dc_id = v_dc_id;
      --
      pkwf_89_cs.pr_prc_ctc(pi_rec => v_cus);
      --
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'The source document record found ['||pi_dc_k||']');
      WHEN TOO_MANY_ROWS THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'The source document record is duplicated');
    END;
    --
    -- Create portfolio/cash account/market account
    --
  EXCEPTION
    WHEN OTHERS THEN
      logger.log(dbms_utility.format_error_backtrace, 'wfcsnew', dbms_utility.format_error_stack);
      RAISE;
  END pr_cre_rec;
  --
  -- General processing routine, new customer registration
  -- -- Parameter - CSCS number
  -- -- Update / Create market account
  -- -- Register for WEB access
  -- -- Activate account
  PROCEDURE pr_set_act(pi_dc_k    IN NUMBER,
                       pi_dc_tk_k IN NUMBER,
                       pi_p1      IN VARCHAR2 DEFAULT NULL,
                       pi_p2      IN VARCHAR2 DEFAULT NULL,
                       pi_p3      IN VARCHAR2 DEFAULT NULL,
                       pi_p4      IN VARCHAR2 DEFAULT NULL,
                       pi_p5      IN VARCHAR2 DEFAULT NULL) IS
    --
    v_dc wf_20_dc%ROWTYPE;
    --
  BEGIN
    --
    pkwf_00_vld.pr_reqd(pi_d => pi_p1, pi_dsc => 'Market Account Number (CSCS)');
    pkwf_00_vld.pr_reqd(pi_d => pi_p2, pi_dsc => 'Market CHN Number');
    --
    v_dc := pkwf_20_gen.fn_get_dc(pi_dc_k => pi_dc_k);
    --
    UPDATE wf_vi_30_cs_new
       SET mkt_act_id = pi_p1,
           mkt_chn_no = pi_p2
     WHERE dc_id = v_dc.dc_id; 
    --
  END pr_set_act;
  -- 
  --
  --
END pkwf_30_cs_new; 
Error report -
Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\package-body\pkwf_30_cs_new_c_body.sql
In command -
CREATE OR REPLACE PACKAGE BODY pkwf_30_cs_new_c AS
  --
  /* Created By       : Femi Akintoye 
  ** Date Created     : 11-MAR-2016
  **
  ** PURPOSE: WF Routines for Preship Objects
  **
  ** MODIFICATION HISTORY:
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **  
  ** Copyright:  Neulogic Solutions Ltd, 2016
  **
  */
  --
  /* Private Routines */
  --
  /* Public Routines */
  --
  -- Insert/Validation of document
  FUNCTION fn_ins(pi_rec IN wf_vi_30_cs_new_c%ROWTYPE) RETURN pkwf_90_gen.r_ret IS
    v_r     wf_vi_30_cs_new_c%ROWTYPE := pi_rec;
    v_k     wf_00_00_dtd.n38%TYPE;
    v_ret   pkwf_90_gen.r_ret;
  BEGIN
    --
    v_ret.ret_cd := 0;
    --
    BEGIN
      --
      logger.log('Hello Corporate');
      v_r.d_id := 'WFVI30CSNEWC';
      --pkwf_00_vld.pr_reqd (pi_d => v_r.dc_tp_k, pi_dsc => 'Document Type');
      v_r.dc_tp_k := 0;
      v_r.dc_st_dm := '0';
      v_r.dc_jsn   := NULL;
      v_r.dc_lnk_yn := '1';
      v_r.dc_lnk_k := NULL;
      --
      v_r.org_nm    := pkwf_30_gen.fn_set_fld(v_r.org_nm);
      pkwf_00_vld.pr_reqd (pi_d => v_r.org_nm, pi_dsc => 'Organisation Name');
      v_r.reg_nbr  := pkwf_30_gen.fn_set_fld(v_r.reg_nbr);
      pkwf_00_vld.pr_reqd (pi_d => v_r.reg_nbr, pi_dsc => 'Registration Number');
      v_r.tax_id   := pkwf_30_gen.fn_set_fld(v_r.tax_id);
      pkwf_00_vld.pr_reqd (pi_d => v_r.reg_dt, pi_dsc => 'Registration Date');
      pkwf_00_vld.pr_not_aft_sys_dt(pi_d => v_r.reg_dt, pi_dsc => 'Registration Date');
      v_r.reg_ctr_cd   := pkwf_30_gen.fn_set_fld(v_r.reg_ctr_cd);
      pkwf_00_vld.pr_reqd (pi_d => v_r.reg_ctr_cd, pi_dsc => 'Country of Registration');
      IF v_r.reg_ctr_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_r.reg_ctr_cd);
      END IF;
      --
      v_r.org_ad1      := pkwf_30_gen.fn_set_fld(v_r.org_ad1);
      pkwf_00_vld.pr_reqd (pi_d => v_r.org_ad1, pi_dsc => 'Organisation Address Line 1');
      v_r.org_ad2      := pkwf_30_gen.fn_set_fld(v_r.org_ad2);
      v_r.org_cty      := pkwf_30_gen.fn_set_fld(v_r.org_cty);
      pkwf_00_vld.pr_reqd (pi_d => v_r.org_cty, pi_dsc => 'Organisation Address City');
      v_r.org_sta_cd   := pkwf_30_gen.fn_set_fld(v_r.org_sta_cd);
      v_r.org_zip      := pkwf_30_gen.fn_set_fld(v_r.org_zip);
      v_r.org_ctr_cd   := pkwf_30_gen.fn_set_fld(v_r.org_ctr_cd);
      pkwf_00_vld.pr_reqd (pi_d => v_r.org_ctr_cd, pi_dsc => 'Organisation Address Country');
      IF v_r.org_ctr_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_r.org_ctr_cd);
      END IF;
      IF v_r.org_sta_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_r.org_ctr_cd,
                                          pi_id     => v_r.org_sta_cd);
      END IF;
      --
      pkwf_00_vld.pr_reqd (pi_d => v_r.bk_nm, pi_dsc => 'Bank Name');
      pkwf_00_vld.pr_reqd (pi_d => v_r.bk_ac_no, pi_dsc => 'Bank Account No.');
      v_r.bk_ac_nm      := pkwf_30_gen.fn_set_fld(v_r.bk_ac_nm);
      v_r.bk_br_nm      := pkwf_30_gen.fn_set_fld(v_r.bk_br_nm);
      v_r.bk_st_cd      := pkwf_30_gen.fn_set_fld(v_r.bk_st_cd);
      v_r.bk_a_ad1      := pkwf_30_gen.fn_set_fld(v_r.bk_a_ad1);
      v_r.bk_a_ad2      := pkwf_30_gen.fn_set_fld(v_r.bk_a_ad2);
      v_r.bk_a_cty      := pkwf_30_gen.fn_set_fld(v_r.bk_a_cty);
      v_r.bk_a_sta_cd   := pkwf_30_gen.fn_set_fld(v_r.bk_a_sta_cd);
      v_r.bk_a_zip      := pkwf_30_gen.fn_set_fld(v_r.bk_a_zip);
      v_r.bk_a_ctr_cd   := pkwf_30_gen.fn_set_fld(v_r.bk_a_ctr_cd);
      IF v_r.bk_a_ctr_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_r.bk_a_ctr_cd);
      END IF;
      IF v_r.bk_a_sta_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_r.bk_a_ctr_cd,
                                          pi_id     => v_r.bk_a_sta_cd);
      END IF;
      --
      v_r.row_key := pkwf_00_00.fn_rk; 
      v_r.dc_id := pkwf_30_gen.fn_g_doc_id;
      v_r.dc_dtt   := SYSDATE;
      --
      -- Create record in object
      INSERT
        INTO wf_vi_30_cs_new_c
      VALUES v_r;
      --
      v_ret.po_dc_k := v_r.row_key;
      --
      pkwf_30_gen.pr_set_dc_dtl(pi_d_id   => v_r.d_id,
                                pi_dc_id  => v_r.dc_id,
                                pi_dc_dsc => UPPER(TRIM(v_r.org_nm)));
      --     
    EXCEPTION
      WHEN OTHERS THEN
      v_ret.ret_cd  := SQLCODE;
      --v_ret.rt_id  := 'ON20';
      v_ret.err_dsc := dbms_utility.format_error_stack;
      v_ret.err_sta := dbms_utility.format_error_backtrace;
    END;
    --
logger.log(v_r.d_id||' RETURNED '||v_ret.ret_cd||' '||v_ret.err_dsc, 'ins', v_ret.err_sta);    
    RETURN v_ret;
    --
  END fn_ins;
  --
  --
  FUNCTION fn_ins_sig(pi_rec IN wf_vi_30_cs_new_c_sig%ROWTYPE) RETURN pkwf_90_gen.r_ret IS
    v_r     wf_vi_30_cs_new_c_sig%ROWTYPE := pi_rec;
    v_k     wf_00_00_dtd.n38%TYPE;
    v_ret   pkwf_90_gen.r_ret;
  BEGIN
    --
    v_ret.ret_cd := 0;
    --
    BEGIN
      --
      v_r.d_id := 'WFVI30CSNEWCSIG';
      --pkwf_00_vld.pr_reqd (pi_d => v_r.dc_tp_k, pi_dsc => 'Document Type');
      v_r.dc_tp_k := 0;
      v_r.dc_st_dm := '0';
      v_r.dc_jsn   := NULL;
      v_r.dc_lnk_yn := '0';
      --v_r.dc_lnk_k := NULL;
      pkwf_00_vld.pr_reqd (pi_d => v_r.dc_lnk_k, pi_dsc => 'Signatory Link Key');
      --
      v_r.tt_dm    := pkwf_30_gen.fn_set_fld(v_r.tt_dm);
      IF v_r.tt_dm IS NOT NULL THEN
        v_k := pkwf_00_00.fn_get_ttl_k(pi_id => v_r.tt_dm);
      END IF;
      v_r.ls_nm    := pkwf_30_gen.fn_set_fld(v_r.ls_nm);
      pkwf_00_vld.pr_reqd (pi_d => v_r.ls_nm, pi_dsc => 'Last Name');
      v_r.md_nm    := pkwf_30_gen.fn_set_fld(v_r.md_nm);
      v_r.fi_nm    := pkwf_30_gen.fn_set_fld(v_r.fi_nm);
      pkwf_00_vld.pr_reqd (pi_d => v_r.fi_nm, pi_dsc => 'First Name');
      v_r.gdr_dm   := pkwf_30_gen.fn_set_fld(v_r.gdr_dm);
      pkwf_00_vld.pr_reqd (pi_d => v_r.gdr_dm, pi_dsc => 'Gender');
      pkwf_00_00_dmv.pr_val_cs_gdr(pi_dm => v_r.gdr_dm);
      pkwf_00_vld.pr_reqd (pi_d => v_r.dob_dt, pi_dsc => 'Date of Birth');
      pkwf_00_vld.pr_not_aft_sys_dt(pi_d => v_r.dob_dt, pi_dsc => 'Date of Birth');
      pkwf_00_vld.pr_reqd (pi_d => v_r.nty_cd, pi_dsc => 'Nationality');
      IF v_r.nty_cd IS NOT NULL THEN
        v_k := pkwf_00_00.fn_get_nty_k(pi_id => v_r.nty_cd);
      END IF;
      --
      v_r.pry_a_ad1      := pkwf_30_gen.fn_set_fld(v_r.pry_a_ad1);
      pkwf_00_vld.pr_reqd (pi_d => v_r.pry_a_ad1, pi_dsc => 'Primary Address Line 1');
      v_r.pry_a_ad2      := pkwf_30_gen.fn_set_fld(v_r.pry_a_ad2);
      v_r.pry_a_cty      := pkwf_30_gen.fn_set_fld(v_r.pry_a_cty);
      pkwf_00_vld.pr_reqd (pi_d => v_r.pry_a_cty, pi_dsc => 'Primary Address City');
      v_r.pry_a_sta_cd   := pkwf_30_gen.fn_set_fld(v_r.pry_a_sta_cd);
      v_r.pry_a_zip      := pkwf_30_gen.fn_set_fld(v_r.pry_a_zip);
      v_r.pry_a_ctr_cd   := pkwf_30_gen.fn_set_fld(v_r.pry_a_ctr_cd);
      pkwf_00_vld.pr_reqd (pi_d => v_r.pry_a_ctr_cd, pi_dsc => 'Primary Address Country');
      IF v_r.pry_a_ctr_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_r.pry_a_ctr_cd);
      END IF;
      IF v_r.pry_a_sta_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_r.pry_a_ctr_cd,
                                          pi_id     => v_r.pry_a_sta_cd);
      END IF;
      --
      v_r.pry_em_ad      := pkwf_30_gen.fn_set_fld(v_r.pry_em_ad);
      pkwf_00_vld.pr_reqd (pi_d => v_r.pry_em_ad, pi_dsc => 'Primary Email Address');
      pkwf_00_vld.pr_valid_eml (pi_d => v_r.pry_em_ad, pi_dsc => 'Primary Email Address');
      v_r.sec_em_ad      := pkwf_30_gen.fn_set_fld(v_r.sec_em_ad);
      IF v_r.sec_em_ad IS NOT NULL THEN
        pkwf_00_vld.pr_valid_eml (pi_d => v_r.sec_em_ad, pi_dsc => 'Secondary Email Address');
      END IF;
      v_r.mbl_phn        := pkwf_30_gen.fn_set_fld(v_r.mbl_phn);
      pkwf_00_vld.pr_reqd (pi_d => v_r.mbl_phn, pi_dsc => 'Mobile Phone No.');
      pkwf_00_vld.pr_valid_phn (pi_d => v_r.mbl_phn, pi_dsc => 'Mobile Phone No.');
      v_r.oth_phn        := pkwf_30_gen.fn_set_fld(v_r.oth_phn);
      IF v_r.oth_phn IS NOT NULL THEN
        pkwf_00_vld.pr_valid_phn (pi_d => v_r.oth_phn, pi_dsc => 'Other Phone No.');
      END IF;
      --
      v_r.c_pic_yn := '0';
      v_r.c_sig_yn := '0';
      v_r.c_ubl_yn := '0';
      v_r.c_idc_yn := '0'; 
      --
      v_r.row_key := pkwf_00_00.fn_rk; 
      v_r.dc_id := pkwf_30_gen.fn_g_doc_id;
      v_r.dc_dtt   := SYSDATE;
      --
      -- Create record in object
      INSERT
        INTO wf_vi_30_cs_new_c_sig
      VALUES v_r;
      --
      v_ret.po_dc_k := v_r.row_key;
      --
      pkwf_30_gen.pr_set_dc_dtl(pi_d_id   => v_r.d_id,
                                pi_dc_id  => v_r.dc_id,
                                pi_dc_dsc => UPPER(TRIM(v_r.ls_nm))||', '||INITCAP(v_r.fi_nm)||' '||INITCAP(v_r.md_nm));
      --     
    EXCEPTION
      WHEN OTHERS THEN
      v_ret.ret_cd  := SQLCODE;
      --v_ret.rt_id  := 'ON20';
      v_ret.err_dsc := dbms_utility.format_error_stack;
      v_ret.err_sta := dbms_utility.format_error_backtrace;
    END;
    --
logger.log(v_r.d_id||' RETURNED '||v_ret.ret_cd||' '||v_ret.err_dsc, 'ins', v_ret.err_sta);    
    RETURN v_ret;
    --
  END fn_ins_sig;
  --
  -- Set images as appropriate
  FUNCTION fn_set_sig_img(pi_dc_k IN NUMBER) RETURN pkwf_90_gen.r_ret IS
    v_ret   pkwf_90_gen.r_ret;
  BEGIN
    --
    BEGIN
      --
      FOR c1 IN (SELECT *
                   FROM wf_30_dc_im
                  WHERE dc_k = pi_dc_k)
      LOOP
        IF c1.im_tp_dm = 'PC' THEN
          UPDATE wf_vi_30_cs_new
             SET pic_img = c1.im_blb,
                 c_pic_yn = '1'
           WHERE row_key = pi_dc_k;
        ELSIF c1.im_tp_dm = 'SG' THEN
          UPDATE wf_vi_30_cs_new
             SET sig_img = c1.im_blb,
                 c_sig_yn = '1'
           WHERE row_key = pi_dc_k;
        ELSIF c1.im_tp_dm = 'UB' THEN
          UPDATE wf_vi_30_cs_new
             SET ubl_img = c1.im_blb,
                 c_ubl_yn = '1'
           WHERE row_key = pi_dc_k;
        ELSIF c1.im_tp_dm = 'ID' THEN
          UPDATE wf_vi_30_cs_new
             SET idc_img = c1.im_blb,
                 c_idc_yn = '1'
           WHERE row_key = pi_dc_k;
        ELSE
          v_ret.ret_cd  := 99;
          v_ret.err_dsc := 'Unknown Image Type ['||c1.im_tp_dm||']';
          v_ret.err_sta := 'Unknown Image Type ['||c1.im_tp_dm||']';
        END IF;
        --
      END LOOP;
      --
    EXCEPTION
      WHEN OTHERS THEN
      v_ret.ret_cd  := SQLCODE;
      v_ret.err_dsc := dbms_utility.format_error_stack;
      v_ret.err_sta := dbms_utility.format_error_backtrace;
    END;
    --
logger.log(pi_dc_k||' IMG RETURNED '||v_ret.ret_cd||' '||v_ret.err_dsc);    
    RETURN v_ret;
    --
  END fn_set_sig_img;
  --
  -- General processing routine, new customer registration, 
  -- Verify customer record, if ok
  -- -- Create customer
  -- -- Create cash account
  -- -- Create portfolio
  PROCEDURE pr_cre_rec(pi_dc_k    IN NUMBER,
                       pi_dc_tk_k IN NUMBER,
                       pi_p1      IN VARCHAR2 DEFAULT NULL,
                       pi_p2      IN VARCHAR2 DEFAULT NULL,
                       pi_p3      IN VARCHAR2 DEFAULT NULL,
                       pi_p4      IN VARCHAR2 DEFAULT NULL,
                       pi_p5      IN VARCHAR2 DEFAULT NULL) IS
  BEGIN
logger.log('CS NEW TASK - CONFIRM DATA VERIFIED AND CREATE CUSTOMER, ');    
    -- Create customer
    DECLARE
      v_cus  pkwf_90_gen.r_cs_new_c;
      v_ret  pkwf_90_gen.r_ret;
      v_dc_id wf_00_00_dtd.c50%TYPE;
    BEGIN
      --
      SELECT dc_id
        INTO v_dc_id
        FROM wf_20_dc
       WHERE row_key = pi_dc_k;
      --
      SELECT *
        INTO v_cus
        FROM wf_vi_30_cs_new_c
       WHERE dc_id = v_dc_id;
      --
      pkwf_89_cs.pr_prc_ctc_c(pi_rec => v_cus);
      --
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'The source document record not found ['||pi_dc_k||']');
      WHEN TOO_MANY_ROWS THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'The source document record is duplicated');
    END;
    --
    -- Create portfolio/cash account/market account
    --
  EXCEPTION
    WHEN OTHERS THEN
      logger.log(dbms_utility.format_error_backtrace, 'wfcsnew', dbms_utility.format_error_stack);
      RAISE;
  END pr_cre_rec;
  --
  -- General processing routine, new customer registration
  -- -- Parameter - CSCS number
  -- -- Update / Create market account
  -- -- Register for WEB access
  -- -- Activate account
  PROCEDURE pr_set_act(pi_dc_k    IN NUMBER,
                       pi_dc_tk_k IN NUMBER,
                       pi_p1      IN VARCHAR2 DEFAULT NULL,
                       pi_p2      IN VARCHAR2 DEFAULT NULL,
                       pi_p3      IN VARCHAR2 DEFAULT NULL,
                       pi_p4      IN VARCHAR2 DEFAULT NULL,
                       pi_p5      IN VARCHAR2 DEFAULT NULL) IS
    --
    v_dc wf_20_dc%ROWTYPE;
    --
  BEGIN
    --
    pkwf_00_vld.pr_reqd(pi_d => pi_p1, pi_dsc => 'Market Account Number (CSCS)');
    pkwf_00_vld.pr_reqd(pi_d => pi_p2, pi_dsc => 'Market CHN Number');
    --
    v_dc := pkwf_20_gen.fn_get_dc(pi_dc_k => pi_dc_k);
    --
    UPDATE wf_vi_30_cs_new
       SET mkt_act_id = pi_p1,
           mkt_chn_no = pi_p2
     WHERE dc_id = v_dc.dc_id; 
    --
  END pr_set_act;
  -- 
  --
  --
END pkwf_30_cs_new_c; 
Error report -
Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\package-body\pkwf_30_cs_new_j_body.sql
In command -
CREATE OR REPLACE PACKAGE BODY pkwf_30_cs_new_j AS
  --
  /* Created By       : Femi Akintoye 
  ** Date Created     : 11-MAR-2016
  **
  ** PURPOSE: WF Routines for Preship Objects
  **
  ** MODIFICATION HISTORY:
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **  
  ** Copyright:  Neulogic Solutions Ltd, 2016
  **
  */
  --
  /* Private Routines */
  PROCEDURE pr_split (pi_rec IN wf_vi_30_cs_new_j%ROWTYPE,
                      po_r1  OUT wf_vi_30_cs_new%ROWTYPE,
                      po_r2  OUT wf_vi_30_cs_new%ROWTYPE) IS
  BEGIN
    --
    po_r1.row_key       := pi_rec.row_key ;
    po_r1.d_id          := pi_rec.d_id ;
    po_r1.dc_tp_k       := pi_rec.dc_tp_k ;
    po_r1.dc_id         := pi_rec.dc_id ;
    po_r1.dc_dtt        := pi_rec.dc_dtt ;
    po_r1.dc_st_dm      := pi_rec.dc_st_dm ;
    po_r1.dc_jsn        := pi_rec.dc_jsn ;
    po_r1.tt_dm         := pi_rec.tt_dm ;
    po_r1.ls_nm         := pi_rec.ls_nm ;
    po_r1.md_nm         := pi_rec.md_nm ;
    po_r1.fi_nm         := pi_rec.fi_nm ;
    po_r1.gdr_dm        := pi_rec.gdr_dm ;
    po_r1.dob_dt        := pi_rec.dob_dt ;
    po_r1.mar_st_dm     := pi_rec.mar_st_dm ;
    po_r1.nty_cd        := pi_rec.nty_cd ;
    po_r1.pry_a_ad1     := pi_rec.pry_a_ad1 ;
    po_r1.pry_a_ad2     := pi_rec.pry_a_ad2 ;
    po_r1.pry_a_cty     := pi_rec.pry_a_cty ;
    po_r1.pry_a_sta_cd  := pi_rec.pry_a_sta_cd ;
    po_r1.pry_a_zip     := pi_rec.pry_a_zip ;
    po_r1.pry_a_ctr_cd  := pi_rec.pry_a_ctr_cd ;
    po_r1.pst_a_ad1     := pi_rec.pst_a_ad1 ;
    po_r1.pst_a_ad2     := pi_rec.pst_a_ad2 ;
    po_r1.pst_a_cty     := pi_rec.pst_a_cty ;
    po_r1.pst_a_sta_cd  := pi_rec.pst_a_sta_cd ;
    po_r1.pst_a_zip     := pi_rec.pst_a_zip ;
    po_r1.pst_a_ctr_cd  := pi_rec.pst_a_ctr_cd ;
    po_r1.pry_em_ad     := pi_rec.pry_em_ad ;
    po_r1.sec_em_ad     := pi_rec.sec_em_ad ;
    po_r1.mbl_phn       := pi_rec.mbl_phn ;
    po_r1.oth_phn       := pi_rec.oth_phn ;
    po_r1.mmd_nm        := pi_rec.mmd_nm ;
    po_r1.nok_nm        := pi_rec.nok_nm ;
    po_r1.nok_rln_cd    := pi_rec.nok_rln_cd ;
    po_r1.nok_phn       := pi_rec.nok_phn ;
    po_r1.nok_a_ad1     := pi_rec.nok_a_ad1 ;
    po_r1.nok_a_ad2     := pi_rec.nok_a_ad2 ;
    po_r1.nok_a_cty     := pi_rec.nok_a_cty ;
    po_r1.nok_a_sta_cd  := pi_rec.nok_a_sta_cd ;
    po_r1.nok_a_zip     := pi_rec.nok_a_zip ;
    po_r1.nok_a_ctr_cd  := pi_rec.nok_a_ctr_cd ;
    po_r1.bk_nm         := pi_rec.bk_nm ;
    po_r1.bk_ac_no      := pi_rec.bk_ac_no ;
    po_r1.bk_bv_no      := pi_rec.bk_bv_no ;
    po_r1.bk_ac_nm      := pi_rec.bk_ac_nm ;
    po_r1.bk_br_nm      := pi_rec.bk_br_nm ;
    po_r1.bk_st_cd      := pi_rec.bk_st_cd ;
    po_r1.bk_a_ad1      := pi_rec.bk_a_ad1 ;
    po_r1.bk_a_ad2      := pi_rec.bk_a_ad2 ;
    po_r1.bk_a_cty      := pi_rec.bk_a_cty ;
    po_r1.bk_a_sta_cd   := pi_rec.bk_a_sta_cd ;
    po_r1.bk_a_zip      := pi_rec.bk_a_zip ;
    po_r1.bk_a_ctr_cd   := pi_rec.bk_a_ctr_cd ;
    po_r1.ocp_nm        := pi_rec.ocp_nm ;
    po_r1.emp_nm        := pi_rec.emp_nm ;
    po_r1.emp_a_ad1     := pi_rec.emp_a_ad1 ;
    po_r1.emp_a_ad2     := pi_rec.emp_a_ad2 ;
    po_r1.emp_a_cty     := pi_rec.emp_a_cty ;
    po_r1.emp_a_sta_cd  := pi_rec.emp_a_sta_cd ;
    po_r1.emp_a_zip     := pi_rec.emp_a_zip ;
    po_r1.emp_a_ctr_cd  := pi_rec.emp_a_ctr_cd ;
    po_r1.emp_phn       := pi_rec.emp_phn ;
    po_r1.ann_inc_amt   := pi_rec.ann_inc_amt ;
    po_r1.c_pic_yn      := pi_rec.c_pic_yn ;
    po_r1.pic_img       := pi_rec.pic_img ;
    po_r1.c_sig_yn      := pi_rec.c_sig_yn ;
    po_r1.sig_img       := pi_rec.sig_img ;
    po_r1.c_ubl_yn      := pi_rec.c_ubl_yn ;
    po_r1.ubl_img       := pi_rec.ubl_img ;
    po_r1.c_idc_yn      := pi_rec.c_idc_yn ;
    po_r1.idc_img       := pi_rec.idc_img ;
    po_r1.mkt_act_id    := pi_rec.mkt_act_id ;
    po_r1.mkt_chn_no    := pi_rec.mkt_chn_no;
    --
    po_r2.row_key       := pi_rec.row_key ;
    po_r2.d_id          := pi_rec.d_id ;
    po_r2.dc_tp_k       := pi_rec.dc_tp_k ;
    po_r2.dc_id         := pi_rec.dc_id ;
    po_r2.dc_dtt        := pi_rec.dc_dtt ;
    po_r2.dc_st_dm      := pi_rec.dc_st_dm ;
    po_r2.dc_jsn        := pi_rec.dc_jsn ;
    po_r2.tt_dm         := pi_rec.j_tt_dm ;
    po_r2.ls_nm         := pi_rec.j_ls_nm ;
    po_r2.md_nm         := pi_rec.j_md_nm ;
    po_r2.fi_nm         := pi_rec.j_fi_nm ;
    po_r2.gdr_dm        := pi_rec.j_gdr_dm ;
    po_r2.dob_dt        := pi_rec.j_dob_dt ;
    po_r2.mar_st_dm     := pi_rec.j_mar_st_dm ;
    po_r2.nty_cd        := pi_rec.j_nty_cd ;
    po_r2.pry_a_ad1     := pi_rec.j_pry_a_ad1 ;
    po_r2.pry_a_ad2     := pi_rec.j_pry_a_ad2 ;
    po_r2.pry_a_cty     := pi_rec.j_pry_a_cty ;
    po_r2.pry_a_sta_cd  := pi_rec.j_pry_a_sta_cd ;
    po_r2.pry_a_zip     := pi_rec.j_pry_a_zip ;
    po_r2.pry_a_ctr_cd  := pi_rec.j_pry_a_ctr_cd ;
    po_r2.pst_a_ad1     := pi_rec.j_pst_a_ad1 ;
    po_r2.pst_a_ad2     := pi_rec.j_pst_a_ad2 ;
    po_r2.pst_a_cty     := pi_rec.j_pst_a_cty ;
    po_r2.pst_a_sta_cd  := pi_rec.j_pst_a_sta_cd ;
    po_r2.pst_a_zip     := pi_rec.j_pst_a_zip ;
    po_r2.pst_a_ctr_cd  := pi_rec.j_pst_a_ctr_cd ;
    po_r2.pry_em_ad     := pi_rec.j_pry_em_ad ;
    po_r2.sec_em_ad     := pi_rec.j_sec_em_ad ;
    po_r2.mbl_phn       := pi_rec.j_mbl_phn ;
    po_r2.oth_phn       := pi_rec.j_oth_phn ;
    po_r2.mmd_nm        := pi_rec.j_mmd_nm ;
    po_r2.nok_nm        := pi_rec.j_nok_nm ;
    po_r2.nok_rln_cd    := pi_rec.j_nok_rln_cd ;
    po_r2.nok_phn       := pi_rec.j_nok_phn ;
    po_r2.nok_a_ad1     := pi_rec.j_nok_a_ad1 ;
    po_r2.nok_a_ad2     := pi_rec.j_nok_a_ad2 ;
    po_r2.nok_a_cty     := pi_rec.j_nok_a_cty ;
    po_r2.nok_a_sta_cd  := pi_rec.j_nok_a_sta_cd ;
    po_r2.nok_a_zip     := pi_rec.j_nok_a_zip ;
    po_r2.nok_a_ctr_cd  := pi_rec.j_nok_a_ctr_cd ;
    po_r2.bk_nm         := pi_rec.j_bk_nm ;
    po_r2.bk_ac_no      := pi_rec.j_bk_ac_no ;
    po_r2.bk_bv_no      := pi_rec.j_bk_bv_no ;
    po_r2.bk_ac_nm      := pi_rec.j_bk_ac_nm ;
    po_r2.bk_br_nm      := pi_rec.j_bk_br_nm ;
    po_r2.bk_st_cd      := pi_rec.j_bk_st_cd ;
    po_r2.bk_a_ad1      := pi_rec.j_bk_a_ad1 ;
    po_r2.bk_a_ad2      := pi_rec.j_bk_a_ad2 ;
    po_r2.bk_a_cty      := pi_rec.j_bk_a_cty ;
    po_r2.bk_a_sta_cd   := pi_rec.j_bk_a_sta_cd ;
    po_r2.bk_a_zip      := pi_rec.j_bk_a_zip ;
    po_r2.bk_a_ctr_cd   := pi_rec.j_bk_a_ctr_cd ;
    po_r2.ocp_nm        := pi_rec.j_ocp_nm ;
    po_r2.emp_nm        := pi_rec.j_emp_nm ;
    po_r2.emp_a_ad1     := pi_rec.j_emp_a_ad1 ;
    po_r2.emp_a_ad2     := pi_rec.j_emp_a_ad2 ;
    po_r2.emp_a_cty     := pi_rec.j_emp_a_cty ;
    po_r2.emp_a_sta_cd  := pi_rec.j_emp_a_sta_cd ;
    po_r2.emp_a_zip     := pi_rec.j_emp_a_zip ;
    po_r2.emp_a_ctr_cd  := pi_rec.j_emp_a_ctr_cd ;
    po_r2.emp_phn       := pi_rec.j_emp_phn ;
    po_r2.ann_inc_amt   := pi_rec.j_ann_inc_amt ;
    po_r2.c_pic_yn      := pi_rec.j_c_pic_yn ;
    po_r2.pic_img       := pi_rec.j_pic_img ;
    po_r2.c_sig_yn      := pi_rec.j_c_sig_yn ;
    po_r2.sig_img       := pi_rec.j_sig_img ;
    po_r2.c_ubl_yn      := pi_rec.j_c_ubl_yn ;
    po_r2.ubl_img       := pi_rec.j_ubl_img ;
    po_r2.c_idc_yn      := pi_rec.j_c_idc_yn ;
    po_r2.idc_img       := pi_rec.j_idc_img ;
    po_r2.mkt_act_id    := pi_rec.mkt_act_id ;
    po_r2.mkt_chn_no    := pi_rec.mkt_chn_no;
    --
  END pr_split;
  --
  /* Public Routines */
  --
  -- Insert/Validation of document
  FUNCTION fn_ins(pi_rec IN wf_vi_30_cs_new_j%ROWTYPE) RETURN pkwf_90_gen.r_ret IS
    v_p     wf_vi_30_cs_new_j%ROWTYPE := pi_rec;
    v_r1    wf_vi_30_cs_new%ROWTYPE;
    v_r2    wf_vi_30_cs_new%ROWTYPE;
    v_k     wf_00_00_dtd.n38%TYPE;
    v_ret   pkwf_90_gen.r_ret;
  BEGIN
    --
    v_ret.ret_cd := 0;
    --
    BEGIN
      --
      pr_split(pi_rec, v_r1, v_r2);
      --
      v_r1.d_id := 'WFVI30CSNEWJ';
      --pkwf_00_vld.pr_reqd (pi_d => v_r.dc_tp_k, pi_dsc => 'Document Type');
      v_r1.dc_tp_k := 0;
      v_r1.dc_st_dm := '0';
      v_r1.dc_jsn   := NULL;
      v_r1.dc_lnk_yn := '1';
      v_r1.dc_lnk_k := NULL;
      --
      v_r1.tt_dm    := pkwf_30_gen.fn_set_fld(v_r1.tt_dm);
      IF v_r1.tt_dm IS NOT NULL THEN
        v_k := pkwf_00_00.fn_get_ttl_k(pi_id => v_r1.tt_dm);
      END IF;
      v_r1.ls_nm    := pkwf_30_gen.fn_set_fld(v_r1.ls_nm);
      pkwf_00_vld.pr_reqd (pi_d => v_r1.ls_nm, pi_dsc => 'Last Name');
      v_r1.md_nm    := pkwf_30_gen.fn_set_fld(v_r1.md_nm);
      v_r1.fi_nm    := pkwf_30_gen.fn_set_fld(v_r1.fi_nm);
      pkwf_00_vld.pr_reqd (pi_d => v_r1.fi_nm, pi_dsc => 'First Name');
      v_r1.gdr_dm   := pkwf_30_gen.fn_set_fld(v_r1.gdr_dm);
      pkwf_00_vld.pr_reqd (pi_d => v_r1.gdr_dm, pi_dsc => 'Gender');
      pkwf_00_00_dmv.pr_val_cs_gdr(pi_dm => v_r1.gdr_dm);
      pkwf_00_vld.pr_reqd (pi_d => v_r1.dob_dt, pi_dsc => 'Date of Birth');
      pkwf_00_vld.pr_not_aft_sys_dt(pi_d => v_r1.dob_dt, pi_dsc => 'Date of Birth');
      v_r1.mar_st_dm   := pkwf_30_gen.fn_set_fld(v_r1.mar_st_dm);
      pkwf_00_vld.pr_reqd (pi_d => v_r1.mar_st_dm, pi_dsc => 'Marital Status');
      pkwf_00_00_dmv.pr_val_cs_mar(pi_dm => v_r1.mar_st_dm);
      pkwf_00_vld.pr_reqd (pi_d => v_r1.nty_cd, pi_dsc => 'Nationality');
      IF v_r1.nty_cd IS NOT NULL THEN
        v_k := pkwf_00_00.fn_get_nty_k(pi_id => v_r1.nty_cd);
      END IF;
      --
      v_r1.pry_a_ad1      := pkwf_30_gen.fn_set_fld(v_r1.pry_a_ad1);
      pkwf_00_vld.pr_reqd (pi_d => v_r1.pry_a_ad1, pi_dsc => 'Primary Address Line 1');
      v_r1.pry_a_ad2      := pkwf_30_gen.fn_set_fld(v_r1.pry_a_ad2);
      v_r1.pry_a_cty      := pkwf_30_gen.fn_set_fld(v_r1.pry_a_cty);
      pkwf_00_vld.pr_reqd (pi_d => v_r1.pry_a_cty, pi_dsc => 'Primary Address City');
      v_r1.pry_a_sta_cd   := pkwf_30_gen.fn_set_fld(v_r1.pry_a_sta_cd);
      v_r1.pry_a_zip      := pkwf_30_gen.fn_set_fld(v_r1.pry_a_zip);
      v_r1.pry_a_ctr_cd   := pkwf_30_gen.fn_set_fld(v_r1.pry_a_ctr_cd);
      pkwf_00_vld.pr_reqd (pi_d => v_r1.pry_a_ctr_cd, pi_dsc => 'Primary Address Country');
      IF v_r1.pry_a_ctr_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_r1.pry_a_ctr_cd);
      END IF;
      IF v_r1.pry_a_sta_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_r1.pry_a_ctr_cd,
                                          pi_id     => v_r1.pry_a_sta_cd);
      END IF;
      --
      v_r1.pst_a_ad1      := pkwf_30_gen.fn_set_fld(v_r1.pst_a_ad1);
      v_r1.pst_a_ad2      := pkwf_30_gen.fn_set_fld(v_r1.pst_a_ad2);
      v_r1.pst_a_cty      := pkwf_30_gen.fn_set_fld(v_r1.pst_a_cty);
      v_r1.pst_a_sta_cd   := pkwf_30_gen.fn_set_fld(v_r1.pst_a_sta_cd);
      v_r1.pst_a_zip      := pkwf_30_gen.fn_set_fld(v_r1.pst_a_zip);
      v_r1.pst_a_ctr_cd   := pkwf_30_gen.fn_set_fld(v_r1.pst_a_ctr_cd);
      IF v_r1.pst_a_ctr_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_r1.pst_a_ctr_cd);
      END IF;
      IF v_r1.pst_a_sta_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_r1.pst_a_ctr_cd,
                                          pi_id     => v_r1.pst_a_sta_cd);
      END IF;
      --
      v_r1.pry_em_ad      := pkwf_30_gen.fn_set_fld(v_r1.pry_em_ad);
      pkwf_00_vld.pr_reqd (pi_d => v_r1.pry_em_ad, pi_dsc => 'Primary Email Address');
      pkwf_00_vld.pr_valid_eml (pi_d => v_r1.pry_em_ad, pi_dsc => 'Primary Email Address');
      v_r1.sec_em_ad      := pkwf_30_gen.fn_set_fld(v_r1.sec_em_ad);
      IF v_r1.sec_em_ad IS NOT NULL THEN
        pkwf_00_vld.pr_valid_eml (pi_d => v_r1.sec_em_ad, pi_dsc => 'Secondary Email Address');
      END IF;
      v_r1.mbl_phn        := pkwf_30_gen.fn_set_fld(v_r1.mbl_phn);
      pkwf_00_vld.pr_reqd (pi_d => v_r1.mbl_phn, pi_dsc => 'Mobile Phone No.');
      pkwf_00_vld.pr_valid_phn (pi_d => v_r1.mbl_phn, pi_dsc => 'Mobile Phone No.');
      v_r1.oth_phn        := pkwf_30_gen.fn_set_fld(v_r1.oth_phn);
      IF v_r1.oth_phn IS NOT NULL THEN
        pkwf_00_vld.pr_valid_phn (pi_d => v_r1.oth_phn, pi_dsc => 'Other Phone No.');
      END IF;
      v_r1.mmd_nm         := pkwf_30_gen.fn_set_fld(v_r1.mmd_nm);
      pkwf_00_vld.pr_reqd (pi_d => v_r1.mmd_nm, pi_dsc => 'Mothers Maiden Name');
      --
      pkwf_00_vld.pr_reqd (pi_d => v_r1.nok_nm, pi_dsc => 'Next of Kin Name');
      IF v_r1.nok_rln_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_rln_k(pi_id => v_r1.nok_rln_cd);
      END IF;
     /*
      pkwf_00_vld.pr_reqd (pi_d => v_r1.nok_phn, pi_dsc => 'Next of Kin Phone No');
      IF v_r1.nok_phn IS NOT NULL THEN
        pkwf_00_vld.pr_valid_phn (pi_d => v_r1.nok_phn, pi_dsc => 'Next of Kin Phone No.');
      END IF;
      */
      pkwf_00_vld.pr_reqd (pi_d => v_r1.nok_a_ad1, pi_dsc => 'Next of Kin Address Line 1');
      v_r1.nok_a_ad2      := pkwf_30_gen.fn_set_fld(v_r1.nok_a_ad2);
      pkwf_00_vld.pr_reqd (pi_d => v_r1.nok_a_cty, pi_dsc => 'Next of Kin Address City');
      v_r1.nok_a_sta_cd   := pkwf_30_gen.fn_set_fld(v_r1.nok_a_sta_cd);
      v_r1.nok_a_zip      := pkwf_30_gen.fn_set_fld(v_r1.nok_a_zip);
      pkwf_00_vld.pr_reqd (pi_d => v_r1.nok_a_ctr_cd, pi_dsc => 'Next of Kin Address Country');
      IF v_r1.nok_a_ctr_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_r1.nok_a_ctr_cd);
      END IF;
      IF v_r1.nok_a_sta_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_r1.nok_a_ctr_cd,
                                          pi_id     => v_r1.nok_a_sta_cd);
      END IF;
      --
      pkwf_00_vld.pr_reqd (pi_d => v_r1.bk_nm, pi_dsc => 'Bank Name');
      pkwf_00_vld.pr_reqd (pi_d => v_r1.bk_ac_no, pi_dsc => 'Bank Account No.');
      pkwf_00_vld.pr_reqd (pi_d => v_r1.bk_bv_no, pi_dsc => 'BVN No.');
      v_r1.bk_ac_nm      := pkwf_30_gen.fn_set_fld(v_r1.bk_ac_nm);
      v_r1.bk_br_nm      := pkwf_30_gen.fn_set_fld(v_r1.bk_br_nm);
      v_r1.bk_st_cd      := pkwf_30_gen.fn_set_fld(v_r1.bk_st_cd);
      v_r1.bk_a_ad1      := pkwf_30_gen.fn_set_fld(v_r1.bk_a_ad1);
      v_r1.bk_a_ad2      := pkwf_30_gen.fn_set_fld(v_r1.bk_a_ad2);
      v_r1.bk_a_cty      := pkwf_30_gen.fn_set_fld(v_r1.bk_a_cty);
      v_r1.bk_a_sta_cd   := pkwf_30_gen.fn_set_fld(v_r1.bk_a_sta_cd);
      v_r1.bk_a_zip      := pkwf_30_gen.fn_set_fld(v_r1.bk_a_zip);
      v_r1.bk_a_ctr_cd   := pkwf_30_gen.fn_set_fld(v_r1.bk_a_ctr_cd);
      IF v_r1.bk_a_ctr_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_r1.bk_a_ctr_cd);
      END IF;
      IF v_r1.bk_a_sta_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_r1.bk_a_ctr_cd,
                                          pi_id     => v_r1.bk_a_sta_cd);
      END IF;
      --
      v_r1.ocp_nm        := pkwf_30_gen.fn_set_fld(v_r1.ocp_nm);
      v_r1.emp_nm        := pkwf_30_gen.fn_set_fld(v_r1.emp_nm);
      v_r1.emp_a_ad1      := pkwf_30_gen.fn_set_fld(v_r1.emp_a_ad1);
      v_r1.emp_a_ad2      := pkwf_30_gen.fn_set_fld(v_r1.emp_a_ad2);
      v_r1.emp_a_cty      := pkwf_30_gen.fn_set_fld(v_r1.emp_a_cty);
      v_r1.emp_a_sta_cd   := pkwf_30_gen.fn_set_fld(v_r1.emp_a_sta_cd);
      v_r1.emp_a_zip      := pkwf_30_gen.fn_set_fld(v_r1.emp_a_zip);
      v_r1.emp_a_ctr_cd   := pkwf_30_gen.fn_set_fld(v_r1.emp_a_ctr_cd);
      IF v_r1.emp_a_ctr_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_r1.emp_a_ctr_cd);
      END IF;
      IF v_r1.emp_a_sta_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_r1.emp_a_ctr_cd,
                                          pi_id     => v_r1.emp_a_sta_cd);
      END IF;
      v_r1.emp_phn       := pkwf_30_gen.fn_set_fld(v_r1.emp_phn);
      IF v_r1.emp_phn IS NOT NULL THEN
        pkwf_00_vld.pr_valid_phn (pi_d => v_r1.emp_phn, pi_dsc => 'Employer Phone No.');
      END IF;
      IF v_r1.ann_inc_amt IS NOT NULL THEN
        pkwf_00_vld.pr_not_below_zero (pi_d => v_r1.ann_inc_amt, pi_dsc => 'Annual Income Amount');
      END IF;
      --    
      v_r1.c_pic_yn := '0';
      v_r1.c_sig_yn := '0';
      v_r1.c_ubl_yn := '0';
      v_r1.c_idc_yn := '0'; 
      --
      v_r1.row_key := pkwf_00_00.fn_rk; 
      v_r1.dc_id := pkwf_30_gen.fn_g_doc_id;
      v_r1.dc_dtt   := SYSDATE;
      --
      -- Create record in object
      INSERT
        INTO wf_vi_30_cs_new
      VALUES v_r1;
      --
      v_ret.po_dc_k := v_r1.row_key;
      --
      --
      v_r2.d_id := 'WFVI30CSNEWJ';
      --pkwf_00_vld.pr_reqd (pi_d => v_r.dc_tp_k, pi_dsc => 'Document Type');
      v_r2.dc_tp_k := 0;
      v_r2.dc_st_dm := '0';
      v_r2.dc_jsn   := NULL;
      v_r1.dc_lnk_yn := '0';
      v_r1.dc_lnk_k := v_r1.row_key;
      --
      v_r2.tt_dm    := pkwf_30_gen.fn_set_fld(v_r2.tt_dm);
      IF v_r2.tt_dm IS NOT NULL THEN
        v_k := pkwf_00_00.fn_get_ttl_k(pi_id => v_r2.tt_dm);
      END IF;
      v_r2.ls_nm    := pkwf_30_gen.fn_set_fld(v_r2.ls_nm);
      pkwf_00_vld.pr_reqd (pi_d => v_r2.ls_nm, pi_dsc => 'Last Name');
      v_r2.md_nm    := pkwf_30_gen.fn_set_fld(v_r2.md_nm);
      v_r2.fi_nm    := pkwf_30_gen.fn_set_fld(v_r2.fi_nm);
      pkwf_00_vld.pr_reqd (pi_d => v_r2.fi_nm, pi_dsc => 'First Name');
      v_r2.gdr_dm   := pkwf_30_gen.fn_set_fld(v_r2.gdr_dm);
      pkwf_00_vld.pr_reqd (pi_d => v_r2.gdr_dm, pi_dsc => 'Gender');
      pkwf_00_00_dmv.pr_val_cs_gdr(pi_dm => v_r2.gdr_dm);
      pkwf_00_vld.pr_reqd (pi_d => v_r2.dob_dt, pi_dsc => 'Date of Birth');
      pkwf_00_vld.pr_not_aft_sys_dt(pi_d => v_r2.dob_dt, pi_dsc => 'Date of Birth');
      v_r2.mar_st_dm   := pkwf_30_gen.fn_set_fld(v_r2.mar_st_dm);
      pkwf_00_vld.pr_reqd (pi_d => v_r2.mar_st_dm, pi_dsc => 'Marital Status');
      pkwf_00_00_dmv.pr_val_cs_mar(pi_dm => v_r2.mar_st_dm);
      pkwf_00_vld.pr_reqd (pi_d => v_r2.nty_cd, pi_dsc => 'Nationality');
      IF v_r2.nty_cd IS NOT NULL THEN
        v_k := pkwf_00_00.fn_get_nty_k(pi_id => v_r2.nty_cd);
      END IF;
      --
      v_r2.pry_a_ad1      := pkwf_30_gen.fn_set_fld(v_r2.pry_a_ad1);
      pkwf_00_vld.pr_reqd (pi_d => v_r2.pry_a_ad1, pi_dsc => 'Primary Address Line 1');
      v_r2.pry_a_ad2      := pkwf_30_gen.fn_set_fld(v_r2.pry_a_ad2);
      v_r2.pry_a_cty      := pkwf_30_gen.fn_set_fld(v_r2.pry_a_cty);
      pkwf_00_vld.pr_reqd (pi_d => v_r2.pry_a_cty, pi_dsc => 'Primary Address City');
      v_r2.pry_a_sta_cd   := pkwf_30_gen.fn_set_fld(v_r2.pry_a_sta_cd);
      v_r2.pry_a_zip      := pkwf_30_gen.fn_set_fld(v_r2.pry_a_zip);
      v_r2.pry_a_ctr_cd   := pkwf_30_gen.fn_set_fld(v_r2.pry_a_ctr_cd);
      pkwf_00_vld.pr_reqd (pi_d => v_r2.pry_a_ctr_cd, pi_dsc => 'Primary Address Country');
      IF v_r2.pry_a_ctr_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_r2.pry_a_ctr_cd);
      END IF;
      IF v_r2.pry_a_sta_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_r2.pry_a_ctr_cd,
                                          pi_id     => v_r2.pry_a_sta_cd);
      END IF;
      --
      v_r2.pst_a_ad1      := pkwf_30_gen.fn_set_fld(v_r2.pst_a_ad1);
      v_r2.pst_a_ad2      := pkwf_30_gen.fn_set_fld(v_r2.pst_a_ad2);
      v_r2.pst_a_cty      := pkwf_30_gen.fn_set_fld(v_r2.pst_a_cty);
      v_r2.pst_a_sta_cd   := pkwf_30_gen.fn_set_fld(v_r2.pst_a_sta_cd);
      v_r2.pst_a_zip      := pkwf_30_gen.fn_set_fld(v_r2.pst_a_zip);
      v_r2.pst_a_ctr_cd   := pkwf_30_gen.fn_set_fld(v_r2.pst_a_ctr_cd);
      IF v_r2.pst_a_ctr_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_r2.pst_a_ctr_cd);
      END IF;
      IF v_r2.pst_a_sta_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_r2.pst_a_ctr_cd,
                                          pi_id     => v_r2.pst_a_sta_cd);
      END IF;
      --
      v_r2.pry_em_ad      := pkwf_30_gen.fn_set_fld(v_r2.pry_em_ad);
      pkwf_00_vld.pr_reqd (pi_d => v_r2.pry_em_ad, pi_dsc => 'Primary Email Address');
      pkwf_00_vld.pr_valid_eml (pi_d => v_r2.pry_em_ad, pi_dsc => 'Primary Email Address');
      v_r2.sec_em_ad      := pkwf_30_gen.fn_set_fld(v_r2.sec_em_ad);
      IF v_r2.sec_em_ad IS NOT NULL THEN
        pkwf_00_vld.pr_valid_eml (pi_d => v_r2.sec_em_ad, pi_dsc => 'Secondary Email Address');
      END IF;
      v_r2.mbl_phn        := pkwf_30_gen.fn_set_fld(v_r2.mbl_phn);
      pkwf_00_vld.pr_reqd (pi_d => v_r2.mbl_phn, pi_dsc => 'Mobile Phone No.');
      pkwf_00_vld.pr_valid_phn (pi_d => v_r2.mbl_phn, pi_dsc => 'Mobile Phone No.');
      v_r2.oth_phn        := pkwf_30_gen.fn_set_fld(v_r2.oth_phn);
      IF v_r2.oth_phn IS NOT NULL THEN
        pkwf_00_vld.pr_valid_phn (pi_d => v_r2.oth_phn, pi_dsc => 'Other Phone No.');
      END IF;
      v_r2.mmd_nm         := pkwf_30_gen.fn_set_fld(v_r2.mmd_nm);
      pkwf_00_vld.pr_reqd (pi_d => v_r2.mmd_nm, pi_dsc => 'Mothers Maiden Name');
      --
      pkwf_00_vld.pr_reqd (pi_d => v_r2.nok_nm, pi_dsc => 'Next of Kin Name');
      IF v_r2.nok_rln_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_rln_k(pi_id => v_r2.nok_rln_cd);
      END IF;
      /*
      pkwf_00_vld.pr_reqd (pi_d => v_r2.nok_phn, pi_dsc => 'Next of Kin Phone No');
      IF v_r2.nok_phn IS NOT NULL THEN
        pkwf_00_vld.pr_valid_phn (pi_d => v_r2.nok_phn, pi_dsc => 'Next of Kin Phone No.');
      END IF;
      */
      pkwf_00_vld.pr_reqd (pi_d => v_r2.nok_a_ad1, pi_dsc => 'Next of Kin Address Line 1');
      v_r2.nok_a_ad2      := pkwf_30_gen.fn_set_fld(v_r2.nok_a_ad2);
      pkwf_00_vld.pr_reqd (pi_d => v_r2.nok_a_cty, pi_dsc => 'Next of Kin Address City');
      v_r2.nok_a_sta_cd   := pkwf_30_gen.fn_set_fld(v_r2.nok_a_sta_cd);
      v_r2.nok_a_zip      := pkwf_30_gen.fn_set_fld(v_r2.nok_a_zip);
      pkwf_00_vld.pr_reqd (pi_d => v_r2.nok_a_ctr_cd, pi_dsc => 'Next of Kin Address Country');
      IF v_r2.nok_a_ctr_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_r2.nok_a_ctr_cd);
      END IF;
      IF v_r2.nok_a_sta_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_r2.nok_a_ctr_cd,
                                          pi_id     => v_r2.nok_a_sta_cd);
      END IF;
      --
      -- Aderemi Alabi 15-SEP-2016
      -- Bank details should only be mandatory for second applicant
     -- pkwf_00_vld.pr_reqd (pi_d => v_r2.bk_nm, pi_dsc => 'Bank Name');
     -- pkwf_00_vld.pr_reqd (pi_d => v_r2.bk_ac_no, pi_dsc => 'Bank Account No.');
     -- pkwf_00_vld.pr_reqd (pi_d => v_r2.bk_bv_no, pi_dsc => 'BVN No.');
      v_r2.bk_ac_nm      := pkwf_30_gen.fn_set_fld(v_r2.bk_ac_nm);
      v_r2.bk_br_nm      := pkwf_30_gen.fn_set_fld(v_r2.bk_br_nm);
      v_r2.bk_st_cd      := pkwf_30_gen.fn_set_fld(v_r2.bk_st_cd);
      v_r2.bk_a_ad1      := pkwf_30_gen.fn_set_fld(v_r2.bk_a_ad1);
      v_r2.bk_a_ad2      := pkwf_30_gen.fn_set_fld(v_r2.bk_a_ad2);
      v_r2.bk_a_cty      := pkwf_30_gen.fn_set_fld(v_r2.bk_a_cty);
      v_r2.bk_a_sta_cd   := pkwf_30_gen.fn_set_fld(v_r2.bk_a_sta_cd);
      v_r2.bk_a_zip      := pkwf_30_gen.fn_set_fld(v_r2.bk_a_zip);
      v_r2.bk_a_ctr_cd   := pkwf_30_gen.fn_set_fld(v_r2.bk_a_ctr_cd);
      IF v_r2.bk_a_ctr_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_r2.bk_a_ctr_cd);
      END IF;
      IF v_r2.bk_a_sta_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_r2.bk_a_ctr_cd,
                                          pi_id     => v_r2.bk_a_sta_cd);
      END IF;
      --
      v_r2.ocp_nm        := pkwf_30_gen.fn_set_fld(v_r2.ocp_nm);
      v_r2.emp_nm        := pkwf_30_gen.fn_set_fld(v_r2.emp_nm);
      v_r2.emp_a_ad1      := pkwf_30_gen.fn_set_fld(v_r2.emp_a_ad1);
      v_r2.emp_a_ad2      := pkwf_30_gen.fn_set_fld(v_r2.emp_a_ad2);
      v_r2.emp_a_cty      := pkwf_30_gen.fn_set_fld(v_r2.emp_a_cty);
      v_r2.emp_a_sta_cd   := pkwf_30_gen.fn_set_fld(v_r2.emp_a_sta_cd);
      v_r2.emp_a_zip      := pkwf_30_gen.fn_set_fld(v_r2.emp_a_zip);
      v_r2.emp_a_ctr_cd   := pkwf_30_gen.fn_set_fld(v_r2.emp_a_ctr_cd);
      IF v_r2.emp_a_ctr_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_r2.emp_a_ctr_cd);
      END IF;
      IF v_r2.emp_a_sta_cd IS NOT NULL THEN
        v_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_r2.emp_a_ctr_cd,
                                          pi_id     => v_r2.emp_a_sta_cd);
      END IF;
      v_r2.emp_phn       := pkwf_30_gen.fn_set_fld(v_r2.emp_phn);
      IF v_r2.emp_phn IS NOT NULL THEN
        pkwf_00_vld.pr_valid_phn (pi_d => v_r2.emp_phn, pi_dsc => 'Employer Phone No.');
      END IF;
      IF v_r2.ann_inc_amt IS NOT NULL THEN
        pkwf_00_vld.pr_not_below_zero (pi_d => v_r2.ann_inc_amt, pi_dsc => 'Annual Income Amount');
      END IF;
      --    
      v_r2.c_pic_yn := '0';
      v_r2.c_sig_yn := '0';
      v_r2.c_ubl_yn := '0';
      v_r2.c_idc_yn := '0'; 
      --
      v_r2.row_key := pkwf_00_00.fn_rk; 
      v_r2.dc_id := v_r1.dc_id||'-2'; --pkwf_30_gen.fn_g_doc_id;
      v_r2.dc_dtt   := SYSDATE;
      --
      -- Create record in object
      INSERT
        INTO wf_vi_30_cs_new
      VALUES v_r2;
      --
      v_ret.po_dc_k := v_r1.row_key;
      --
      pkwf_30_gen.pr_set_dc_dtl(pi_d_id   => v_r1.d_id,
                                pi_dc_id  => v_r1.dc_id,
                                pi_dc_dsc => UPPER(TRIM(v_r1.ls_nm))||', '||INITCAP(v_r1.fi_nm)||' '||INITCAP(v_r1.md_nm));
      --     
    EXCEPTION
      WHEN OTHERS THEN
      v_ret.ret_cd  := SQLCODE;
      --v_ret.rt_id  := 'ON20';
      v_ret.err_dsc := dbms_utility.format_error_stack;
      v_ret.err_sta := dbms_utility.format_error_backtrace;
    END;
    --
logger.log(v_r1.d_id||' RETURNED '||v_ret.ret_cd||' '||v_ret.err_dsc, 'ins', v_ret.err_sta);    
    RETURN v_ret;
    --
  END fn_ins;
  --
  --
  FUNCTION fn_get_j_dc_k(pi_dc_k IN NUMBER) RETURN NUMBER IS
    v_k wf_00_00_dtd.n38%TYPE;
  BEGIN
    --
    BEGIN
      SELECT row_key
        INTO v_k
        FROM wf_vi_30_cs_new
       WHERE dc_lnk_k = pi_dc_k;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        v_k := -1;
      WHEN TOO_MANY_ROWS THEN
        v_k := -2;
    END;
    --
    RETURN v_k;
    --
  END fn_get_j_dc_k;
  --
  -- Set images as appropriate
  FUNCTION fn_set_img(pi_dc_k IN NUMBER) RETURN pkwf_90_gen.r_ret IS
    v_ret   pkwf_90_gen.r_ret;
  BEGIN
    --
    BEGIN
      --
      FOR c1 IN (SELECT *
                   FROM wf_30_dc_im
                  WHERE dc_k = pi_dc_k)
      LOOP
        IF c1.im_tp_dm = 'PC' THEN
          UPDATE wf_vi_30_cs_new
             SET pic_img = c1.im_blb,
                 c_pic_yn = '1'
           WHERE row_key = pi_dc_k;
        ELSIF c1.im_tp_dm = 'SG' THEN
          UPDATE wf_vi_30_cs_new
             SET sig_img = c1.im_blb,
                 c_sig_yn = '1'
           WHERE row_key = pi_dc_k;
        ELSIF c1.im_tp_dm = 'UB' THEN
          UPDATE wf_vi_30_cs_new
             SET ubl_img = c1.im_blb,
                 c_ubl_yn = '1'
           WHERE row_key = pi_dc_k;
        ELSIF c1.im_tp_dm = 'ID' THEN
          UPDATE wf_vi_30_cs_new
             SET idc_img = c1.im_blb,
                 c_idc_yn = '1'
           WHERE row_key = pi_dc_k;
        ELSE
          v_ret.ret_cd  := 99;
          v_ret.err_dsc := 'Unknown Image Type ['||c1.im_tp_dm||']';
          v_ret.err_sta := 'Unknown Image Type ['||c1.im_tp_dm||']';
        END IF;
        --
      END LOOP;
      --
    EXCEPTION
      WHEN OTHERS THEN
      v_ret.ret_cd  := SQLCODE;
      v_ret.err_dsc := dbms_utility.format_error_stack;
      v_ret.err_sta := dbms_utility.format_error_backtrace;
    END;
    --
logger.log(pi_dc_k||' IMG RETURNED '||v_ret.ret_cd||' '||v_ret.err_dsc);    
    RETURN v_ret;
    --
  END fn_set_img;
  --
  -- General processing routine, new customer registration, 
  -- Verify customer record, if ok
  -- -- Create customer
  -- -- Create cash account
  -- -- Create portfolio
  PROCEDURE pr_cre_rec(pi_dc_k    IN NUMBER,
                       pi_dc_tk_k IN NUMBER,
                       pi_p1      IN VARCHAR2 DEFAULT NULL,
                       pi_p2      IN VARCHAR2 DEFAULT NULL,
                       pi_p3      IN VARCHAR2 DEFAULT NULL,
                       pi_p4      IN VARCHAR2 DEFAULT NULL,
                       pi_p5      IN VARCHAR2 DEFAULT NULL) IS
  BEGIN
logger.log('CS NEW TASK - CONFIRM DATA VERIFIED AND CREATE CUSTOMER, ');    
    -- Create customer
    DECLARE
      v_cus   pkwf_90_gen.r_cs_new;
      v_cus_j pkwf_90_gen.r_cs_new_j;
      v_ret   pkwf_90_gen.r_ret;
      v_dc_id wf_00_00_dtd.c50%TYPE;
    BEGIN
      --
      SELECT dc_id
        INTO v_dc_id
        FROM wf_20_dc
       WHERE row_key = pi_dc_k;
      --
      SELECT *
        INTO v_cus
        FROM wf_vi_30_cs_new
       WHERE dc_id = v_dc_id;
      --
      SELECT *
        INTO v_cus_j
        FROM wf_vi_30_cs_new_j
       WHERE dc_lnk_k = v_cus.row_key;
      --
      pkwf_89_cs.pr_prc_ctc_j(pi_rec   => v_cus,
                              pi_rec_j => v_cus_j);
      --
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'The source document record not found ['||pi_dc_k||']');
      WHEN TOO_MANY_ROWS THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'The source document record is duplicated');
    END;
    --
    -- Create portfolio/cash account/market account
    --
  EXCEPTION
    WHEN OTHERS THEN
      logger.log(dbms_utility.format_error_backtrace, 'wfcsnew', dbms_utility.format_error_stack);
      RAISE;
  END pr_cre_rec;
  --
  -- General processing routine, new customer registration
  -- -- Parameter - CSCS number
  -- -- Update / Create market account
  -- -- Register for WEB access
  -- -- Activate account
  PROCEDURE pr_set_act(pi_dc_k    IN NUMBER,
                       pi_dc_tk_k IN NUMBER,
                       pi_p1      IN VARCHAR2 DEFAULT NULL,
                       pi_p2      IN VARCHAR2 DEFAULT NULL,
                       pi_p3      IN VARCHAR2 DEFAULT NULL,
                       pi_p4      IN VARCHAR2 DEFAULT NULL,
                       pi_p5      IN VARCHAR2 DEFAULT NULL) IS
    --
    v_dc wf_20_dc%ROWTYPE;
    --
  BEGIN
    --
    pkwf_00_vld.pr_reqd(pi_d => pi_p1, pi_dsc => 'Market Account Number (CSCS)');
    pkwf_00_vld.pr_reqd(pi_d => pi_p2, pi_dsc => 'Market CHN Number');
    --
    v_dc := pkwf_20_gen.fn_get_dc(pi_dc_k => pi_dc_k);
    --
    UPDATE wf_vi_30_cs_new
       SET mkt_act_id = pi_p1,
           mkt_chn_no = pi_p2
     WHERE dc_id = v_dc.dc_id; 
    --
  END pr_set_act;
  -- 
  --
  --
END pkwf_30_cs_new_j; 
Error report -
Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\package-body\pkwf_30_cs_reg_2_body.sql
In command -
CREATE OR REPLACE PACKAGE BODY pkwf_30_cs_reg_2 AS
  --
  /* Created By       : Femi Akintoye 
  ** Date Created     : 11-MAR-2016
  **
  ** PURPOSE: WF Routines for Preship Objects
  **
  ** MODIFICATION HISTORY:
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **  
  ** Copyright:  Neulogic Solutions Ltd, 2016
  **
  */
  --
  /* Private Routines */
  --
  /* Public Routines */
  --
  -- Insert/Validation of document
  FUNCTION fn_ins(pi_rec IN wf_vi_30_cs_reg_2%ROWTYPE) RETURN pkwf_90_gen.r_ret IS
    v_r     wf_vi_30_cs_reg_2%ROWTYPE := pi_rec;
    v_k     wf_00_00_dtd.n38%TYPE;
    v_ret   pkwf_90_gen.r_ret;
  BEGIN
    --
    v_ret.ret_cd := 0;
    --
    BEGIN
      --
      v_r.d_id := 'WFVI30CSREG2';
--      pkwf_00_vld.pr_reqd (pi_d => v_r.dc_tp_k, pi_dsc => 'Document Type');
      v_r.dc_tp_k := 0;
      v_r.dc_st_dm := '0';
      v_r.dc_jsn   := NULL;
      --
      v_r.cus_id    := pkwf_30_gen.fn_set_fld(v_r.cus_id);
      pkwf_00_vld.pr_reqd (pi_d => v_r.cus_id, pi_dsc => 'Customer ID.');
      --v_r.cus_id    := LPAD(v_r.mk_ac_id, '0', 10);
      v_r.cus_nm       := pkwf_30_gen.fn_set_fld(v_r.cus_nm);
      pkwf_00_vld.pr_reqd (pi_d => v_r.cus_nm, pi_dsc => 'Customer Name');
      v_r.pry_em_ad   := pkwf_30_gen.fn_set_fld(v_r.pry_em_ad);
      pkwf_00_vld.pr_reqd (pi_d => v_r.pry_em_ad, pi_dsc => 'Email Address');
      v_r.mbl_phn     := pkwf_30_gen.fn_set_fld(v_r.mbl_phn);
      pkwf_00_vld.pr_reqd (pi_d => v_r.mbl_phn, pi_dsc => 'Phone Number');
      v_r.mbl_phn     := pkwf_30_gen.fn_set_fld(v_r.mbl_phn);
      --pkwf_00_vld.pr_reqd (pi_d => v_r.dob_dt, pi_dsc => 'Date of Birth');
      --pkwf_00_vld.pr_not_aft_sys_dt(pi_d => v_r.dob_dt, pi_dsc => 'Date of Birth');
      --
      v_r.row_key := pkwf_00_00.fn_rk; 
      v_r.dc_id := pkwf_30_gen.fn_g_doc_id;
      v_r.dc_dtt   := SYSDATE;
      --
      -- Create record in object
      INSERT
        INTO wf_vi_30_cs_reg_2
      VALUES v_r;
      --
      v_ret.po_dc_k := v_r.row_key;
      --
      pkwf_30_gen.pr_set_dc_dtl(pi_d_id   => v_r.d_id,
                                pi_dc_id  => v_r.dc_id,
                                pi_dc_dsc => 'PORTAL REGISTRATION REQUEST - For Customer Id.'||v_r.cus_id);
      --
    EXCEPTION
      WHEN OTHERS THEN
      v_ret.ret_cd  := SQLCODE;
      --v_ret.rt_id  := 'ON20';
      v_ret.err_dsc := dbms_utility.format_error_stack;
      v_ret.err_sta := dbms_utility.format_error_backtrace;
    END;
    --
    logger.log(v_r.d_id||' RETURNED '||v_ret.ret_cd||' '||v_ret.err_dsc, 'ins', v_ret.err_sta);    
    RETURN v_ret;
    --
  END fn_ins;
  --
  -- General processing routine, new customer registration, 
  -- Verify customer record, if ok
  -- -- Create customer
  -- -- Create cash account
  -- -- Create portfolio
  PROCEDURE pr_prc_vrf(pi_dc_k    IN NUMBER,
                       pi_dc_tk_k IN NUMBER,
                       pi_p1      IN VARCHAR2 DEFAULT NULL,
                       pi_p2      IN VARCHAR2 DEFAULT NULL,
                       pi_p3      IN VARCHAR2 DEFAULT NULL,
                       pi_p4      IN VARCHAR2 DEFAULT NULL,
                       pi_p5      IN VARCHAR2 DEFAULT NULL) IS
  BEGIN
logger.log('CS NEW TASK - CONFIRM DATA VERIFIED AND CREATE CUSTOMER, ');    
    -- Create customer
    DECLARE
      v_cus  pkwf_90_gen.r_cs_new;
      v_ret  pkwf_90_gen.r_ret;
      v_dc_id wf_00_00_dtd.c50%TYPE;
    BEGIN
      --
      SELECT dc_id
        INTO v_dc_id
        FROM wf_20_dc
       WHERE row_key = pi_dc_k;
      --
      SELECT *
        INTO v_cus
        FROM wf_vi_30_cs_new
       WHERE dc_id = v_dc_id;
      --
      pkwf_89_cs.pr_prc_ctc(pi_rec => v_cus);
      --
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'The source document record found ['||pi_dc_k||']');
      WHEN TOO_MANY_ROWS THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'The source document record is duplicated');
    END;
    --
    -- Create portfolio/cash account/market account
    --
  END pr_prc_vrf;
  --
  -- General processing routine, new customer registration
  -- -- Register for WEB access using market account
  PROCEDURE pr_cre_map_st(pi_dc_k    IN NUMBER,
                          pi_dc_tk_k IN NUMBER,
                          pi_p1      IN VARCHAR2 DEFAULT NULL,
                          pi_p2      IN VARCHAR2 DEFAULT NULL,
                          pi_p3      IN VARCHAR2 DEFAULT NULL,
                          pi_p4      IN VARCHAR2 DEFAULT NULL,
                          pi_p5      IN VARCHAR2 DEFAULT NULL) IS
  BEGIN
    -- Create customer
    DECLARE
      v_map  pkwf_90_gen.r_cs_reg2;
      v_ret  pkwf_90_gen.r_ret;
      v_dc_id wf_00_00_dtd.c50%TYPE;
    BEGIN
      --
      SELECT dc_id
        INTO v_dc_id
        FROM wf_20_dc
       WHERE row_key = pi_dc_k;
      --
      SELECT *
        INTO v_map
        FROM wf_vi_30_cs_reg_2
       WHERE dc_id = v_dc_id;
      --
      pkwf_89_cs.pr_prc_reg_2(pi_rec => v_map);
      --
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'The source document record found ['||pi_dc_k||']');
      WHEN TOO_MANY_ROWS THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'The source document record is duplicated');
    END;
    --
    -- Create portfolio/cash account/market account
    --
  EXCEPTION
    WHEN OTHERS THEN
      logger.log(dbms_utility.format_error_backtrace, 'wfcsnew', dbms_utility.format_error_stack);
      RAISE;
  END pr_cre_map_st;
  -- 
  --
  --
  --
  --
END pkwf_30_cs_reg_2; 
Error report -
Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\package-body\pkwf_30_cs_reg_body.sql
In command -
CREATE OR REPLACE PACKAGE BODY pkwf_30_cs_reg AS
  --
  /* Created By       : Femi Akintoye 
  ** Date Created     : 11-MAR-2016
  **
  ** PURPOSE: WF Routines for Preship Objects
  **
  ** MODIFICATION HISTORY:
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **  
  ** Copyright:  Neulogic Solutions Ltd, 2016
  **
  */
  --
  /* Private Routines */
  --
  /* Public Routines */
  --
  -- Insert/Validation of document
  FUNCTION fn_ins(pi_rec IN wf_vi_30_cs_reg%ROWTYPE) RETURN pkwf_90_gen.r_ret IS
    v_r     wf_vi_30_cs_reg%ROWTYPE := pi_rec;
    v_k     wf_00_00_dtd.n38%TYPE;
    v_ret   pkwf_90_gen.r_ret;
  BEGIN
    --
    v_ret.ret_cd := 0;
    --
    BEGIN
      --
      v_r.d_id := 'WFVI30CSREG';
--      pkwf_00_vld.pr_reqd (pi_d => v_r.dc_tp_k, pi_dsc => 'Document Type');
      v_r.dc_tp_k := 0;
      v_r.dc_st_dm := '0';
      v_r.dc_jsn   := NULL;
      --
      v_r.mk_ac_id    := pkwf_30_gen.fn_set_fld(v_r.mk_ac_id);
      pkwf_00_vld.pr_reqd (pi_d => v_r.mk_ac_id, pi_dsc => 'Market Account');
      v_r.mk_ac_id    := LPAD(v_r.mk_ac_id, 10, '0');
      v_r.ac_nm       := pkwf_30_gen.fn_set_fld(v_r.ac_nm);
      pkwf_00_vld.pr_reqd (pi_d => v_r.ac_nm, pi_dsc => 'Account Name');
      v_r.pry_em_ad   := pkwf_30_gen.fn_set_fld(v_r.pry_em_ad);
      pkwf_00_vld.pr_reqd (pi_d => v_r.pry_em_ad, pi_dsc => 'Email Address');
      v_r.mbl_phn     := pkwf_30_gen.fn_set_fld(v_r.mbl_phn);
      pkwf_00_vld.pr_reqd (pi_d => v_r.mbl_phn, pi_dsc => 'Phone Number');
      pkwf_00_vld.pr_reqd (pi_d => v_r.dob_dt, pi_dsc => 'Date of Birth');
      pkwf_00_vld.pr_not_aft_sys_dt(pi_d => v_r.dob_dt, pi_dsc => 'Date of Birth');
      --
      v_r.row_key := pkwf_00_00.fn_rk; 
      v_r.dc_id := pkwf_30_gen.fn_g_doc_id;
      v_r.dc_dtt   := SYSDATE;
      --
      -- Create record in object
      INSERT
        INTO wf_vi_30_cs_reg
      VALUES v_r;
      --
      v_ret.po_dc_k := v_r.row_key;
      --
      pkwf_30_gen.pr_set_dc_dtl(pi_d_id   => v_r.d_id,
                                pi_dc_id  => v_r.dc_id,
                                pi_dc_dsc => 'PORTAL REGISTRATION REQUEST - For CSCS No. '||v_r.mk_ac_id);
      --
    EXCEPTION
      WHEN OTHERS THEN
      v_ret.ret_cd  := SQLCODE;
      --v_ret.rt_id  := 'ON20';
      v_ret.err_dsc := dbms_utility.format_error_stack;
      v_ret.err_sta := dbms_utility.format_error_backtrace;
    END;
    --
logger.log(v_r.d_id||' RETURNED '||v_ret.ret_cd||' '||v_ret.err_dsc, 'ins', v_ret.err_sta);    
    RETURN v_ret;
    --
  END fn_ins;
  --
  -- General processing routine, new customer registration, 
  -- Verify customer record, if ok
  -- -- Create customer
  -- -- Create cash account
  -- -- Create portfolio
  PROCEDURE pr_prc_vrf(pi_dc_k    IN NUMBER,
                       pi_dc_tk_k IN NUMBER,
                       pi_p1      IN VARCHAR2 DEFAULT NULL,
                       pi_p2      IN VARCHAR2 DEFAULT NULL,
                       pi_p3      IN VARCHAR2 DEFAULT NULL,
                       pi_p4      IN VARCHAR2 DEFAULT NULL,
                       pi_p5      IN VARCHAR2 DEFAULT NULL) IS
  BEGIN
logger.log('CS NEW TASK - CONFIRM DATA VERIFIED AND CREATE CUSTOMER, ');    
    -- Create customer
    DECLARE
      v_cus  pkwf_90_gen.r_cs_new;
      v_ret  pkwf_90_gen.r_ret;
      v_dc_id wf_00_00_dtd.c50%TYPE;
    BEGIN
      --
      SELECT dc_id
        INTO v_dc_id
        FROM wf_20_dc
       WHERE row_key = pi_dc_k;
      --
      SELECT *
        INTO v_cus
        FROM wf_vi_30_cs_new
       WHERE dc_id = v_dc_id;
      --
      pkwf_89_cs.pr_prc_ctc(pi_rec => v_cus);
      --
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'The source document record found ['||pi_dc_k||']');
      WHEN TOO_MANY_ROWS THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'The source document record is duplicated');
    END;
    --
    -- Create portfolio/cash account/market account
    --
  END pr_prc_vrf;
  --
  -- General processing routine, new customer registration
  -- -- Register for WEB access using market account
  PROCEDURE pr_cre_map_st(pi_dc_k    IN NUMBER,
                          pi_dc_tk_k IN NUMBER,
                          pi_p1      IN VARCHAR2 DEFAULT NULL,
                          pi_p2      IN VARCHAR2 DEFAULT NULL,
                          pi_p3      IN VARCHAR2 DEFAULT NULL,
                          pi_p4      IN VARCHAR2 DEFAULT NULL,
                          pi_p5      IN VARCHAR2 DEFAULT NULL) IS
  BEGIN
    -- Create customer
    DECLARE
      v_map  pkwf_90_gen.r_cs_reg;
      v_ret  pkwf_90_gen.r_ret;
      v_dc_id wf_00_00_dtd.c50%TYPE;
    BEGIN
      --
      SELECT dc_id
        INTO v_dc_id
        FROM wf_20_dc
       WHERE row_key = pi_dc_k;
      --
      SELECT *
        INTO v_map
        FROM wf_vi_30_cs_reg
       WHERE dc_id = v_dc_id;
      --
      pkwf_89_st.pr_prc_reg(pi_rec => v_map);
      --
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'The source document record found ['||pi_dc_k||']');
      WHEN TOO_MANY_ROWS THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'The source document record is duplicated');
    END;
    --
    -- Create portfolio/cash account/market account
    --
  EXCEPTION
    WHEN OTHERS THEN
      logger.log(dbms_utility.format_error_backtrace, 'wfcsnew', dbms_utility.format_error_stack);
      RAISE;
  END pr_cre_map_st;
  -- 
  --
  --
  --
  --
END pkwf_30_cs_reg; 
Error report -
Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\package-body\pkwf_30_gen_body.sql
In command -
CREATE OR REPLACE PACKAGE BODY pkwf_30_gen AS
  --
  /* Created By       : Femi Akintoye 
  ** Date Created     : 11-MAR-2016
  **
  ** PURPOSE: WF Routines for Preship Objects
  **
  ** MODIFICATION HISTORY:
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **  
  ** Copyright:  Neulogic Solutions Ltd, 2016
  **
  */
  --
  /* Private Routines */
  --
  --
  /* Public Routines */
  -- 
  -- Get Document Id
  FUNCTION fn_g_doc_id RETURN VARCHAR2 IS
    v_c     NUMBER(38);
  BEGIN
    --
    v_c := MOD(pkwf_00_00.fn_doc,100000);
    RETURN TO_CHAR(SYSDATE,'YYYYMMDD')||LPAD(v_c, 6, '0');
  END fn_g_doc_id;
  --
  --
  FUNCTION fn_set_fld (pi_dat IN VARCHAR2) RETURN VARCHAR2 IS
    v_d  VARCHAR2(250);
  BEGIN
    v_d := TRIM(pi_dat);
    v_d := REPLACE(v_d,'<','');
    v_d := REPLACE(v_d,'>','');
    RETURN v_d;
  END fn_set_fld;
  --
  --
  PROCEDURE pr_set_dc_dtl(pi_d_id   IN VARCHAR2,
                          pi_dc_id  IN VARCHAR2,
                          pi_dc_dsc IN VARCHAR2) IS
      -- Configure workflow document link
    v_dc    wf_20_dc%ROWTYPE;
    v_dk    wf_20_dc_tk%ROWTYPE;
    v_tp    wf_10_tp%ROWTYPE;
    v_c     NUMBER(38);
  BEGIN
    --
    BEGIN
      SELECT B.*
        INTO v_tp
        FROM wf_10_tp_lk A, wf_10_tp B
       WHERE A.d_id = pi_d_id
         AND A.tp_k = B.row_key;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'Unable to locate the configuration of this workflow type. Please contact administrator ['||pi_d_id||']');
      WHEN TOO_MANY_ROWS THEN
        pkwf_00_00_err.pr_raise(pi_msg => 'Configuration of this workflow type is duplicated. Please contact administrator ['||pi_d_id||']');
    END;
    --
    UPDATE wf_30_dc
       SET dc_tp_k = v_tp.row_key
     WHERE dc_id = pi_dc_id;
    --
    v_c := MOD(pkwf_00_00.fn_doc,100000);
    --
    v_dc.row_key   := pkwf_00_00.fn_rk; 
    v_dc.bus_dt    := TRUNC(SYSDATE);
    v_dc.sys_dtt   := SYSDATE;
    v_dc.tp_k      := v_tp.row_key;
    v_dc.dc_id     := pi_dc_id;
    v_dc.dc_dsc    := pi_dc_dsc; --UPPER(TRIM(v_r.ls_nm))||', '||INITCAP(v_r.fi_nm)||' '||INITCAP(v_r.md_nm);
    v_dc.st_dtt    := SYSDATE;
    v_dc.ed_dtt    := NULL;
    v_dc.dc_st_dm  := '0';
    v_dc.cr_sq_no  := 1;
    v_dc.tk_no     := 0;
    --
    INSERT
      INTO wf_20_dc
    VALUES v_dc;
    --
    FOR c1 IN (SELECT *
                 FROM wf_10_tp_tk
                WHERE tp_k = v_tp.row_key
                ORDER BY seq_no ASC)
    LOOP
      --
      v_dk.row_key  := pkwf_00_00.fn_rk;
      v_dk.bus_dt   := TRUNC(SYSDATE); 
      v_dk.sys_dtt  := SYSDATE;
      v_dk.dc_k     := v_dc.row_key;
      v_dk.tk_k     := c1.row_key; 
      v_dk.mb_k     := NULL;
      v_dk.st_dtt   := NULL;
      v_dk.ed_dtt   := NULL;
      v_dk.ac_rmk   := NULL;
      v_dk.dn_yn    := '0';
      v_dk.tk_sq_no := c1.seq_no;
      --
      INSERT 
        INTO wf_20_dc_tk
      VALUES v_dk;
      --
    END LOOP;
    --
    -- Send Alert to default mail group for this document
    IF (v_tp.acc_alt_id IS NOT NULL) AND (v_tp.acc_eml IS NOT NULL) THEN
      DECLARE
        v_al   pkwf_90_alt.v_alt;
      BEGIN
        v_al := NULL;
        v_al.pi_msg_id := v_tp.acc_alt_id;
        --
        v_al.pi_rcpt_adr := v_tp.acc_eml;
        -- Generate Alert
        v_al.pi_src_key   := v_dc.row_key;     
        v_al.pi_src_ref   := v_dc.dc_id;
        v_al.pi_sbj1      := '';
        v_al.pi_sbj2      := pkwf_90_alt.fn_fmt_qty(pi_qty => 0);
        v_al.pi_sbj3      := ''; 
        v_al.pi_bdy1      := '';
        v_al.pi_bdy2      := '';
        v_al.pi_bdy3      := '';
        v_al.pi_bdy4      := '';
        v_al.pi_bdy5      := '';
        v_al.pi_bdy6      := '';
        v_al.pi_bdy7      := pkwf_90_alt.fn_fmt_qty(pi_qty => 0);
        --
        pkwf_90_alt.pr_crt_msg (pi_rec => v_al);
      END;
    END IF;
    --
  END;
  --
  --  
END pkwf_30_gen; 
Error report -
Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\package-body\pkwf_30_ws_body.sql
In command -
create or replace PACKAGE BODY pkwf_30_ws AS
  --
  /* Created By       : Aderemi Alabi 
  ** Date Created     : 25-JUN-2016
  **
  ** PURPOSE: WF Routines for WS Requests
  **
  ** MODIFICATION HISTORY:
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **  
  ** Copyright:  Neulogic Solutions Ltd, 2016
  **
  */
  --
  --
  pv_ls logger_logs.scope%type := $$plsql_unit;
  pv_lp logger.tab_param;
  --
  --
  /* Private Routines */
  --
  FUNCTION fn_json_dt(pi_val IN VARCHAR2) RETURN DATE IS
    v_fmt VARCHAR2(50) := 'YYYY-MM-DD';-- THH24:MI:SSZ';
    v_ret DATE;
  BEGIN
    v_ret := TO_DATE(SUBSTR(pi_val,1,10), v_fmt);
    RETURN v_ret;
  EXCEPTION
    WHEN OTHERS THEN
      RAISE;
  END fn_json_dt;
  --
  FUNCTION  fn_parse_json(pi_json IN CLOB) RETURN apex_json.t_values IS
    v_jlst     apex_json.t_values;
    e_invalid_json EXCEPTION;
    PRAGMA EXCEPTION_INIT(e_invalid_json, -20987);
  BEGIN
    --
    pv_ls := pv_ls || '.fn_parse_json';
    --
    IF pi_json IS NULL THEN
      logger.append_param(pv_lp,' JSON','Empty');
      raise_application_error(-20055, 'Empty JSON Object. No further processing');
    ELSE  
      apex_json.parse(v_jlst, pi_json);
      RETURN v_jlst;
    END IF; 
    --   
    logger.log('Parsing JSON', pv_ls, NULL, pv_lp);
    --    
  EXCEPTION
    WHEN e_invalid_json THEN
      logger.append_param(pv_lp,' JSON','Invalid');
      logger.log('Parsing JSON', pv_ls, NULL, pv_lp);
      raise_application_error(-20055, 'Invalid JSON Object. No further processing');
    WHEN OTHERS THEN
      logger.log_error('exception', pv_ls, dbms_utility.format_error_stack ||'|'||
                                          dbms_utility.format_error_backtrace, pv_lp);
      raise_application_error(-20055, 'Invalid JSON Object. No further processing');    
  END fn_parse_json;
  --
  FUNCTION fn_gen_json(pi_cd IN VARCHAR2, pi_msg IN VARCHAR2) RETURN CLOB IS
    v_cd  VARCHAR2(20);
    v_msg VARCHAR2(2000);
  BEGIN
    --
    IF pi_cd = '0' THEN
      v_cd  := '000';
      v_msg := NVL(pi_msg,'Web Access request received successfully');
    ELSE
      v_cd  := pi_cd;
      v_msg := pi_msg;
    END IF;    
    apex_json.initialize_clob_output;
    apex_json.open_object();
    apex_json.open_array('response');
    apex_json.open_object();
    apex_json.write('code', v_cd);
    apex_json.write('message', v_msg);
    apex_json.close_object;
    apex_json.close_array;
    apex_json.close_object;
    --
    RETURN apex_json.get_clob_output;
    --
  END fn_gen_json;
  --
  --
  /* Public Routines */
  --
  -- Online Access for ST
  FUNCTION fn_web_access(pi_obj IN CLOB) RETURN CLOB IS
    --
    v_rec    wf_vi_30_cs_reg%ROWTYPE;
    v_ret    pkwf_90_gen.r_ret;
    v_jlst   apex_json.t_values;
    v_return CLOB;
    --
  BEGIN
    --
    pv_ls := pv_ls || '.fn_web_access';
    logger.append_param(pv_lp,' REQ-JSON',pi_obj);
    --
    v_jlst := fn_parse_json(pi_obj);
    v_rec.mk_ac_id  := apex_json.get_varchar2(p_path => 'webaccess[%d].mk_ac_id', p0 => 1, p_values => v_jlst);
    v_rec.ac_nm     := apex_json.get_varchar2(p_path => 'webaccess[%d].ac_nm', p0 => 1, p_values => v_jlst);
    v_rec.dob_dt    := fn_json_dt(apex_json.get_varchar2(p_path => 'webaccess[%d].dob_dt', p0 => 1, p_values => v_jlst));
    v_rec.pry_em_ad := apex_json.get_varchar2(p_path => 'webaccess[%d].pry_em_ad', p0 => 1, p_values => v_jlst);
    v_rec.mbl_phn   := apex_json.get_varchar2(p_path => 'webaccess[%d].mbl_phn', p0 => 1, p_values => v_jlst);
    --
    v_ret := pkwf_30_cs_reg.fn_ins(v_rec);
    --
    IF v_ret.ret_cd = '0' THEN
      v_return := fn_gen_json(v_ret.ret_cd, NULL);
    ELSE 
      v_return := fn_gen_json(v_ret.ret_cd, v_ret.err_dsc);
    END IF;     
    --
    logger.append_param(pv_lp,' RSP-JSON',v_return);
    logger.log('WB-Online Access', pv_ls, NULL, pv_lp);
    RETURN v_return;
    --
  EXCEPTION
    WHEN OTHERS THEN
      logger.log_error('exception', pv_ls, dbms_utility.format_error_stack ||'|'||
                                          dbms_utility.format_error_backtrace, pv_lp);
      logger.log('WB-Online Access', pv_ls, NULL, pv_lp);
      v_return := fn_gen_json(sqlcode, sqlerrm);
      RETURN v_return;      
  END fn_web_access;  
  --
  -- Online Access for AM
  FUNCTION fn_web_access2(pi_obj IN CLOB) RETURN CLOB IS
    --
    v_rec    wf_vi_30_cs_reg_2%ROWTYPE;
    v_ret    pkwf_90_gen.r_ret;
    v_jlst   apex_json.t_values;
    v_return CLOB;
    --
  BEGIN
    --
    pv_ls := pv_ls || '.fn_web_access2';
    logger.append_param(pv_lp,' REQ-JSON',pi_obj);
    --
    v_jlst := fn_parse_json(pi_obj);
    v_rec.cus_id    := apex_json.get_varchar2(p_path => 'webaccess[%d].cus_id', p0 => 1, p_values => v_jlst);
    v_rec.cus_nm    := apex_json.get_varchar2(p_path => 'webaccess[%d].cus_nm', p0 => 1, p_values => v_jlst);
    v_rec.dob_dt    := fn_json_dt(apex_json.get_varchar2(p_path => 'webaccess2%d].dob_dt', p0 => 1, p_values => v_jlst));
    v_rec.pry_em_ad := apex_json.get_varchar2(p_path => 'webaccess[%d].pry_em_ad', p0 => 1, p_values => v_jlst);
    v_rec.mbl_phn   := apex_json.get_varchar2(p_path => 'webaccess[%d].mbl_phn', p0 => 1, p_values => v_jlst);
    --
    v_ret := pkwf_30_cs_reg_2.fn_ins(v_rec);
    --
    IF v_ret.ret_cd = '0' THEN
      v_return := fn_gen_json(v_ret.ret_cd, NULL);
    ELSE 
      v_return := fn_gen_json(v_ret.ret_cd, v_ret.err_dsc);
    END IF;     
    --
    logger.append_param(pv_lp,' RSP-JSON',v_return);
    logger.log('WB-Online Access2', pv_ls, NULL, pv_lp);
    RETURN v_return;
    --
  EXCEPTION
    WHEN OTHERS THEN
      logger.log_error('exception', pv_ls, dbms_utility.format_error_stack ||'|'||
                                          dbms_utility.format_error_backtrace, pv_lp);
      logger.log('WB-Online Access2', pv_ls, NULL, pv_lp);
      v_return := fn_gen_json(sqlcode, sqlerrm);
      RETURN v_return;      
  END fn_web_access2;  
  --
  -- Cash Withdarawal
  FUNCTION fn_cash_withdraw(pi_obj IN CLOB) RETURN CLOB IS
    --
    v_rec    wf_vi_30_ch_wdr%ROWTYPE;
    v_ret    pkwf_90_gen.r_ret;
    v_jlst   apex_json.t_values;
    v_return CLOB;
    --
  BEGIN
    --
    pv_ls := pv_ls || '.fn_cash_withdraw';
    logger.append_param(pv_lp,' REQ-JSON',pi_obj);
    --
    v_jlst := fn_parse_json(pi_obj);
    v_rec.ac_id       := apex_json.get_varchar2(p_path => 'withdrawal[%d].ac_id', p0 => 1, p_values => v_jlst);
    v_rec.pm_bk_id    := apex_json.get_varchar2(p_path => 'withdrawal[%d].pm_bk_id', p0 => 1, p_values => v_jlst);
    v_rec.pm_bk_ac_no := apex_json.get_varchar2(p_path => 'withdrawal[%d].pm_bk_ac_no', p0 => 1, p_values => v_jlst);
    v_rec.wdr_amt     := apex_json.get_number(p_path => 'withdrawal[%d].wdr_amt', p0 => 1, p_values => v_jlst);
    --
    v_ret := pkwf_30_ch_wdr.fn_ins(v_rec);
    --
    IF v_ret.ret_cd = '0' THEN
      v_return := fn_gen_json(v_ret.ret_cd, NULL);
    ELSE 
      v_return := fn_gen_json(v_ret.ret_cd, v_ret.err_dsc);
    END IF;     
    --
    logger.append_param(pv_lp,' RSP-JSON',v_return);
    logger.log('CH-Cash Withdrawal', pv_ls, NULL, pv_lp);
    RETURN v_return;
    --
  EXCEPTION
    WHEN OTHERS THEN
      logger.log_error('exception', pv_ls, dbms_utility.format_error_stack ||'|'||
                                          dbms_utility.format_error_backtrace, pv_lp);
      logger.log('CH-Cash Withdrawal', pv_ls, NULL, pv_lp);
      v_return := fn_gen_json(sqlcode, sqlerrm);
      RETURN v_return;      
  END fn_cash_withdraw;  
  --
  -- IF Mandate
  FUNCTION fn_if_mandate(pi_obj IN CLOB) RETURN CLOB IS
    --
    v_rec    wf_vi_30_am_if_mnd%ROWTYPE;
    v_ret    pkwf_90_gen.r_ret;
    v_jlst   apex_json.t_values;
    v_return CLOB;
    --
  BEGIN
    --
    pv_ls := pv_ls || '.fn_if_mandate';
    logger.append_param(pv_lp,' REQ-JSON',pi_obj);
    --
    v_jlst := fn_parse_json(pi_obj);
    v_rec.cus_id      := apex_json.get_varchar2(p_path => 'withdrawal[%d].cus_id', p0 => 1, p_values => v_jlst);
    v_rec.fnd_id      := apex_json.get_varchar2(p_path => 'withdrawal[%d].fnd_id', p0 => 1, p_values => v_jlst);
    v_rec.fnd_dsc     := apex_json.get_varchar2(p_path => 'withdrawal[%d].fnd_dsc', p0 => 1, p_values => v_jlst);
    v_rec.ast_tp_dm   := apex_json.get_varchar2(p_path => 'withdrawal[%d].ast_tp_dm', p0 => 1, p_values => v_jlst);
    v_rec.ast_tp_dsc  := apex_json.get_varchar2(p_path => 'withdrawal[%d].ast_tp_dsc', p0 => 1, p_values => v_jlst);
    v_rec.ast_cl_dsc  := apex_json.get_varchar2(p_path => 'withdrawal[%d].ast_cl_dsc', p0 => 1, p_values => v_jlst);
    v_rec.ast_scl_dsc := apex_json.get_varchar2(p_path => 'withdrawal[%d].ast_scl_dsc', p0 => 1, p_values => v_jlst);
    v_rec.ast_dsc     := apex_json.get_varchar2(p_path => 'withdrawal[%d].ast_dsc', p0 => 1, p_values => v_jlst);
    v_rec.ast_curr_id := apex_json.get_varchar2(p_path => 'withdrawal[%d].ast_curr_id', p0 => 1, p_values => v_jlst);
    v_rec.ast_curr_ds := apex_json.get_varchar2(p_path => 'withdrawal[%d].ast_curr_ds', p0 => 1, p_values => v_jlst);
    v_rec.if_acct_id  := apex_json.get_varchar2(p_path => 'withdrawal[%d].if_acct_id', p0 => 1, p_values => v_jlst);
    v_rec.if_acct_dsc := apex_json.get_varchar2(p_path => 'withdrawal[%d].if_acct_dsc', p0 => 1, p_values => v_jlst);    
    v_rec.hld_val     := apex_json.get_number(p_path => 'withdrawal[%d].hld_val', p0 => 1, p_values => v_jlst);
    v_rec.mnd_dsc     := apex_json.get_varchar2(p_path => 'withdrawal[%d].mnd_dsc', p0 => 1, p_values => v_jlst);
    --
    v_ret := pkwf_30_am_if_mnd.fn_ins(v_rec);
    --
    IF v_ret.ret_cd = '0' THEN
      v_return := fn_gen_json(v_ret.ret_cd, NULL);
    ELSE 
      v_return := fn_gen_json(v_ret.ret_cd, v_ret.err_dsc);
    END IF;     
    --
    logger.append_param(pv_lp,' RSP-JSON',v_return);
    logger.log('IF-Mandate', pv_ls, NULL, pv_lp);
    RETURN v_return;
    --
  EXCEPTION
    WHEN OTHERS THEN
      logger.log_error('exception', pv_ls, dbms_utility.format_error_stack ||'|'||
                                          dbms_utility.format_error_backtrace, pv_lp);
      logger.log('IF-Mandate', pv_ls, NULL, pv_lp);
      v_return := fn_gen_json(sqlcode, sqlerrm);
      RETURN v_return;      
  END fn_if_mandate;  
  --
  -- MF Redeem
  FUNCTION fn_mf_redeem(pi_obj IN CLOB) RETURN CLOB IS
    --
    v_rec    wf_vi_30_am_mf_rdm%ROWTYPE;
    v_ret    pkwf_90_gen.r_ret;
    v_jlst   apex_json.t_values;
    v_return CLOB;
    --
  BEGIN
    --
    pv_ls := pv_ls || '.fn_mf_redeem';
    logger.append_param(pv_lp,' REQ-JSON',pi_obj);
    --
    v_jlst := fn_parse_json(pi_obj);
    v_rec.cus_id      := apex_json.get_varchar2(p_path => 'redemption[%d].cus_id', p0 => 1, p_values => v_jlst);
    v_rec.fnd_id      := apex_json.get_varchar2(p_path => 'redemption[%d].fnd_id', p0 => 1, p_values => v_jlst);
    v_rec.fnd_dsc     := apex_json.get_varchar2(p_path => 'redemption[%d].fnd_dsc', p0 => 1, p_values => v_jlst);
    v_rec.ast_tp_dm   := apex_json.get_varchar2(p_path => 'redemption[%d].ast_tp_dm', p0 => 1, p_values => v_jlst);
    v_rec.ast_tp_dsc  := apex_json.get_varchar2(p_path => 'redemption[%d].ast_tp_dsc', p0 => 1, p_values => v_jlst);
    v_rec.ast_cl_dsc  := apex_json.get_varchar2(p_path => 'redemption[%d].ast_cl_dsc', p0 => 1, p_values => v_jlst);
    v_rec.ast_scl_dsc := apex_json.get_varchar2(p_path => 'redemption[%d].ast_scl_dsc', p0 => 1, p_values => v_jlst);
    v_rec.ast_dsc     := apex_json.get_varchar2(p_path => 'redemption[%d].ast_dsc', p0 => 1, p_values => v_jlst);
    v_rec.ast_curr_id := apex_json.get_varchar2(p_path => 'redemption[%d].ast_curr_id', p0 => 1, p_values => v_jlst);
    v_rec.ast_curr_ds := apex_json.get_varchar2(p_path => 'redemption[%d].ast_curr_ds', p0 => 1, p_values => v_jlst);
    v_rec.mf_acct_id  := apex_json.get_varchar2(p_path => 'redemption[%d].mf_acct_id', p0 => 1, p_values => v_jlst);
    v_rec.mf_acct_dsc := apex_json.get_varchar2(p_path => 'redemption[%d].mf_acct_dsc', p0 => 1, p_values => v_jlst);    
    v_rec.eff_dt      := fn_json_dt(apex_json.get_varchar2(p_path => 'redemption[%d].eff_dt', p0 => 1, p_values => v_jlst));    
    v_rec.tenor_dsc   := apex_json.get_varchar2(p_path => 'redemption[%d].tenor_dsc', p0 => 1, p_values => v_jlst);    
    v_rec.unt_qty     := apex_json.get_number(p_path => 'redemption[%d].unt_qty', p0 => 1, p_values => v_jlst);
    v_rec.cur_prc     := apex_json.get_number(p_path => 'redemption[%d].cur_prc', p0 => 1, p_values => v_jlst);
    v_rec.hld_val     := apex_json.get_number(p_path => 'redemption[%d].hld_val', p0 => 1, p_values => v_jlst);
    v_rec.cur_val     := apex_json.get_number(p_path => 'redemption[%d].cur_val', p0 => 1, p_values => v_jlst);
    v_rec.rdp_unt     := apex_json.get_number(p_path => 'redemption[%d].rdp_unt', p0 => 1, p_values => v_jlst);
    --
    v_ret := pkwf_30_am_mf_rdm.fn_ins(v_rec);
    --
    IF v_ret.ret_cd = '0' THEN
      v_return := fn_gen_json(v_ret.ret_cd, NULL);
    ELSE 
      v_return := fn_gen_json(v_ret.ret_cd, v_ret.err_dsc);
    END IF;     
    --
    logger.append_param(pv_lp,' RSP-JSON',v_return);
    logger.log('MF-Redemption', pv_ls, NULL, pv_lp);
    RETURN v_return;
    --
  EXCEPTION
    WHEN OTHERS THEN
      logger.log_error('exception', pv_ls, dbms_utility.format_error_stack ||'|'||
                                          dbms_utility.format_error_backtrace, pv_lp);
      logger.log('MF-Redemption', pv_ls, NULL, pv_lp);
      v_return := fn_gen_json(sqlcode, sqlerrm);
      RETURN v_return;      
  END fn_mf_redeem;  
  --
  -- CS New Individual
  FUNCTION fn_cs_new_i(pi_obj IN CLOB) RETURN CLOB IS
    --
    v_rec    wf_vi_30_cs_new%ROWTYPE;
    v_ret    pkwf_90_gen.r_ret;
    v_jlst   apex_json.t_values;
    v_return CLOB;
    --
  BEGIN
    --
    pv_ls := pv_ls || '.fn_cs_new_i';
    logger.append_param(pv_lp,' REQ-JSON',pi_obj);
    --
    v_jlst := fn_parse_json(pi_obj);
    v_rec.pdt_id     := apex_json.get_varchar2(p_path => 'customer[%d].pdt_id', p0 => 1, p_values => v_jlst);
    v_rec.tt_dm     := apex_json.get_varchar2(p_path => 'customer[%d].tt_dm', p0 => 1, p_values => v_jlst);
    v_rec.ls_nm     := apex_json.get_varchar2(p_path => 'customer[%d].ls_nm', p0 => 1, p_values => v_jlst);
    v_rec.md_nm     := apex_json.get_varchar2(p_path => 'customer[%d].md_nm', p0 => 1, p_values => v_jlst);
    v_rec.fi_nm     := apex_json.get_varchar2(p_path => 'customer[%d].fi_nm', p0 => 1, p_values => v_jlst);
    v_rec.gdr_dm    := apex_json.get_varchar2(p_path => 'customer[%d].gdr_dm', p0 => 1, p_values => v_jlst);
    v_rec.dob_dt    := fn_json_dt(apex_json.get_varchar2(p_path => 'customer[%d].dob_dt', p0 => 1, p_values => v_jlst));
    v_rec.mar_st_dm := apex_json.get_varchar2(p_path => 'customer[%d].mar_st_dm', p0 => 1, p_values => v_jlst);
    v_rec.nty_cd    := apex_json.get_varchar2(p_path => 'customer[%d].nty_cd', p0 => 1, p_values => v_jlst);
    v_rec.pry_a_ad1 := apex_json.get_varchar2(p_path => 'customer[%d].pry_a_ad1', p0 => 1, p_values => v_jlst);
    v_rec.pry_a_ad2 := apex_json.get_varchar2(p_path => 'customer[%d].pry_a_ad2', p0 => 1, p_values => v_jlst);
    v_rec.pry_a_cty := apex_json.get_varchar2(p_path => 'customer[%d].pry_a_cty', p0 => 1, p_values => v_jlst);
    v_rec.pry_a_sta_cd := apex_json.get_varchar2(p_path => 'customer[%d].pry_a_sta_cd', p0 => 1, p_values => v_jlst);
    v_rec.pry_a_zip := apex_json.get_varchar2(p_path => 'customer[%d].pry_a_zip', p0 => 1, p_values => v_jlst);
    v_rec.pry_a_ctr_cd := apex_json.get_varchar2(p_path => 'customer[%d].pry_a_ctr_cd', p0 => 1, p_values => v_jlst);
    v_rec.pst_a_ad1 := apex_json.get_varchar2(p_path => 'customer[%d].pst_a_ad1', p0 => 1, p_values => v_jlst);
    v_rec.pst_a_ad2 := apex_json.get_varchar2(p_path => 'customer[%d].pst_a_ad2', p0 => 1, p_values => v_jlst);
    v_rec.pst_a_cty := apex_json.get_varchar2(p_path => 'customer[%d].pst_a_cty', p0 => 1, p_values => v_jlst);
    v_rec.pst_a_sta_cd := apex_json.get_varchar2(p_path => 'customer[%d].pst_a_sta_cd', p0 => 1, p_values => v_jlst);
    v_rec.pst_a_zip := apex_json.get_varchar2(p_path => 'customer[%d].pst_a_zip', p0 => 1, p_values => v_jlst);
    v_rec.pst_a_ctr_cd := apex_json.get_varchar2(p_path => 'customer[%d].pst_a_ctr_cd', p0 => 1, p_values => v_jlst);
    v_rec.pry_em_ad := apex_json.get_varchar2(p_path => 'customer[%d].pry_em_ad', p0 => 1, p_values => v_jlst);
    v_rec.sec_em_ad := apex_json.get_varchar2(p_path => 'customer[%d].sec_em_ad', p0 => 1, p_values => v_jlst);
    v_rec.mbl_phn   := apex_json.get_varchar2(p_path => 'customer[%d].mbl_phn', p0 => 1, p_values => v_jlst);
    v_rec.oth_phn   := apex_json.get_varchar2(p_path => 'customer[%d].oth_phn', p0 => 1, p_values => v_jlst);
    v_rec.mmd_nm    := apex_json.get_varchar2(p_path => 'customer[%d].mmd_nm', p0 => 1, p_values => v_jlst);
    v_rec.nok_nm    := apex_json.get_varchar2(p_path => 'customer[%d].nok_nm', p0 => 1, p_values => v_jlst);
    v_rec.nok_rln_cd := apex_json.get_varchar2(p_path => 'customer[%d].nok_rln_cd', p0 => 1, p_values => v_jlst);
    v_rec.nok_phn := apex_json.get_varchar2(p_path => 'customer[%d].nok_phn', p0 => 1, p_values => v_jlst);
    v_rec.nok_a_ad1 := apex_json.get_varchar2(p_path => 'customer[%d].nok_a_ad1', p0 => 1, p_values => v_jlst);
    v_rec.nok_a_ad2 := apex_json.get_varchar2(p_path => 'customer[%d].nok_a_ad2', p0 => 1, p_values => v_jlst);
    v_rec.nok_a_cty := apex_json.get_varchar2(p_path => 'customer[%d].nok_a_cty', p0 => 1, p_values => v_jlst);
    v_rec.nok_a_sta_cd := apex_json.get_varchar2(p_path => 'customer[%d].nok_a_sta_cd', p0 => 1, p_values => v_jlst);
    v_rec.nok_a_zip := apex_json.get_varchar2(p_path => 'customer[%d].nok_a_zip', p0 => 1, p_values => v_jlst);
    v_rec.nok_a_ctr_cd := apex_json.get_varchar2(p_path => 'customer[%d].nok_a_ctr_cd', p0 => 1, p_values => v_jlst);
    v_rec.bk_nm     := apex_json.get_varchar2(p_path => 'customer[%d].bk_nm', p0 => 1, p_values => v_jlst);
    v_rec.bk_ac_no  := apex_json.get_varchar2(p_path => 'customer[%d].bk_ac_no', p0 => 1, p_values => v_jlst);
    v_rec.bk_bv_no  := apex_json.get_varchar2(p_path => 'customer[%d].bk_bv_no', p0 => 1, p_values => v_jlst);
    v_rec.bk_ac_nm  := apex_json.get_varchar2(p_path => 'customer[%d].bk_ac_nm', p0 => 1, p_values => v_jlst);
    v_rec.bk_br_nm  := apex_json.get_varchar2(p_path => 'customer[%d].bk_br_nm', p0 => 1, p_values => v_jlst);
    v_rec.bk_st_cd  := apex_json.get_varchar2(p_path => 'customer[%d].bk_st_cd', p0 => 1, p_values => v_jlst);
    v_rec.bk_a_ad1  := apex_json.get_varchar2(p_path => 'customer[%d].bk_a_ad1', p0 => 1, p_values => v_jlst);
    v_rec.bk_a_ad2  := apex_json.get_varchar2(p_path => 'customer[%d].bk_a_ad2', p0 => 1, p_values => v_jlst);
    v_rec.bk_a_cty  := apex_json.get_varchar2(p_path => 'customer[%d].bk_a_cty', p0 => 1, p_values => v_jlst);
    v_rec.bk_a_sta_cd := apex_json.get_varchar2(p_path => 'customer[%d].bk_a_sta_cd', p0 => 1, p_values => v_jlst);
    v_rec.bk_a_zip  := apex_json.get_varchar2(p_path => 'customer[%d].bk_a_zip', p0 => 1, p_values => v_jlst);
    v_rec.bk_a_ctr_cd := apex_json.get_varchar2(p_path => 'customer[%d].bk_a_ctr_cd', p0 => 1, p_values => v_jlst);
    v_rec.ocp_nm := apex_json.get_varchar2(p_path => 'customer[%d].ocp_nm', p0 => 1, p_values => v_jlst);
    v_rec.emp_nm := apex_json.get_varchar2(p_path => 'customer[%d].emp_nm', p0 => 1, p_values => v_jlst);
    v_rec.emp_a_ad1 := apex_json.get_varchar2(p_path => 'customer[%d].emp_a_ad1', p0 => 1, p_values => v_jlst);
    v_rec.emp_a_ad2 := apex_json.get_varchar2(p_path => 'customer[%d].emp_a_ad2', p0 => 1, p_values => v_jlst);
    v_rec.emp_a_cty := apex_json.get_varchar2(p_path => 'customer[%d].emp_a_cty', p0 => 1, p_values => v_jlst);
    v_rec.emp_a_sta_cd := apex_json.get_varchar2(p_path => 'customer[%d].emp_a_sta_cd', p0 => 1, p_values => v_jlst);
    v_rec.emp_a_zip := apex_json.get_varchar2(p_path => 'customer[%d].emp_a_zip', p0 => 1, p_values => v_jlst);
    v_rec.emp_a_ctr_cd := apex_json.get_varchar2(p_path => 'customer[%d].emp_a_ctr_cd', p0 => 1, p_values => v_jlst);
    v_rec.emp_phn   := apex_json.get_varchar2(p_path => 'customer[%d].emp_phn', p0 => 1, p_values => v_jlst);
    v_rec.ann_inc_amt := apex_json.get_varchar2(p_path => 'customer[%d].ann_inc_amt', p0 => 1, p_values => v_jlst);
    v_rec.c_pic_yn := apex_json.get_varchar2(p_path => 'customer[%d].c_pic_yn', p0 => 1, p_values => v_jlst);
    v_rec.c_sig_yn := apex_json.get_varchar2(p_path => 'customer[%d].c_sig_yn', p0 => 1, p_values => v_jlst);
    v_rec.c_ubl_yn := apex_json.get_varchar2(p_path => 'customer[%d].c_ubl_yn', p0 => 1, p_values => v_jlst);
    v_rec.c_idc_yn := apex_json.get_varchar2(p_path => 'customer[%d].c_idc_yn', p0 => 1, p_values => v_jlst);--
    v_ret := pkwf_30_cs_new.fn_ins(v_rec);
    --
    IF v_ret.ret_cd = '0' THEN
      v_return := fn_gen_json(v_ret.ret_cd, v_ret.po_dc_k);
    ELSE 
      v_return := fn_gen_json(v_ret.ret_cd, v_ret.err_dsc);
    END IF;     
    --
    logger.append_param(pv_lp,' RSP-JSON',v_return);
    logger.log('CS-Customer I', pv_ls, NULL, pv_lp);
    RETURN v_return;
    --
  EXCEPTION
    WHEN OTHERS THEN
      logger.log_error('exception', pv_ls, dbms_utility.format_error_stack ||'|'||
                                          dbms_utility.format_error_backtrace, pv_lp);
      logger.log('CS-Customer I', pv_ls, NULL, pv_lp);
      v_return := fn_gen_json(sqlcode, sqlerrm);
      RETURN v_return;      
  END fn_cs_new_i;  
  --
  -- CS New Joint
  FUNCTION fn_cs_new_j(pi_obj IN CLOB) RETURN CLOB IS
    --
    v_rec    wf_vi_30_cs_new_j%ROWTYPE;
    v_ret    pkwf_90_gen.r_ret;
    v_jlst   apex_json.t_values;
    v_return CLOB;
    --
  BEGIN
    --
    pv_ls := pv_ls || '.fn_cs_new_j';
    logger.append_param(pv_lp,' REQ-JSON',pi_obj);
    --
    v_jlst := fn_parse_json(pi_obj);
    --Customer 1
    v_rec.pdt_id     := apex_json.get_varchar2(p_path => 'customer1[%d].pdt_id', p0 => 1, p_values => v_jlst);
    v_rec.tt_dm     := apex_json.get_varchar2(p_path => 'customer1[%d].tt_dm', p0 => 1, p_values => v_jlst);
    v_rec.ls_nm     := apex_json.get_varchar2(p_path => 'customer1[%d].ls_nm', p0 => 1, p_values => v_jlst);
    v_rec.md_nm     := apex_json.get_varchar2(p_path => 'customer1[%d].md_nm', p0 => 1, p_values => v_jlst);
    v_rec.fi_nm     := apex_json.get_varchar2(p_path => 'customer1[%d].fi_nm', p0 => 1, p_values => v_jlst);
    v_rec.gdr_dm    := apex_json.get_varchar2(p_path => 'customer1[%d].gdr_dm', p0 => 1, p_values => v_jlst);
    v_rec.dob_dt    := fn_json_dt(apex_json.get_varchar2(p_path => 'customer1[%d].dob_dt', p0 => 1, p_values => v_jlst));
    v_rec.mar_st_dm := apex_json.get_varchar2(p_path => 'customer1[%d].mar_st_dm', p0 => 1, p_values => v_jlst);
    v_rec.nty_cd    := apex_json.get_varchar2(p_path => 'customer1[%d].nty_cd', p0 => 1, p_values => v_jlst);
    v_rec.pry_a_ad1 := apex_json.get_varchar2(p_path => 'customer1[%d].pry_a_ad1', p0 => 1, p_values => v_jlst);
    v_rec.pry_a_ad2 := apex_json.get_varchar2(p_path => 'customer1[%d].pry_a_ad2', p0 => 1, p_values => v_jlst);
    v_rec.pry_a_cty := apex_json.get_varchar2(p_path => 'customer1[%d].pry_a_cty', p0 => 1, p_values => v_jlst);
    v_rec.pry_a_sta_cd := apex_json.get_varchar2(p_path => 'customer1[%d].pry_a_sta_cd', p0 => 1, p_values => v_jlst);
    v_rec.pry_a_zip := apex_json.get_varchar2(p_path => 'customer1[%d].pry_a_zip', p0 => 1, p_values => v_jlst);
    v_rec.pry_a_ctr_cd := apex_json.get_varchar2(p_path => 'customer1[%d].pry_a_ctr_cd', p0 => 1, p_values => v_jlst);
    v_rec.pst_a_ad1 := apex_json.get_varchar2(p_path => 'customer1[%d].pst_a_ad1', p0 => 1, p_values => v_jlst);
    v_rec.pst_a_ad2 := apex_json.get_varchar2(p_path => 'customer1[%d].pst_a_ad2', p0 => 1, p_values => v_jlst);
    v_rec.pst_a_cty := apex_json.get_varchar2(p_path => 'customer1[%d].pst_a_cty', p0 => 1, p_values => v_jlst);
    v_rec.pst_a_sta_cd := apex_json.get_varchar2(p_path => 'customer1[%d].pst_a_sta_cd', p0 => 1, p_values => v_jlst);
    v_rec.pst_a_zip := apex_json.get_varchar2(p_path => 'customer1[%d].pst_a_zip', p0 => 1, p_values => v_jlst);
    v_rec.pst_a_ctr_cd := apex_json.get_varchar2(p_path => 'customer1[%d].pst_a_ctr_cd', p0 => 1, p_values => v_jlst);
    v_rec.pry_em_ad := apex_json.get_varchar2(p_path => 'customer1[%d].pry_em_ad', p0 => 1, p_values => v_jlst);
    v_rec.sec_em_ad := apex_json.get_varchar2(p_path => 'customer1[%d].sec_em_ad', p0 => 1, p_values => v_jlst);
    v_rec.mbl_phn   := apex_json.get_varchar2(p_path => 'customer1[%d].mbl_phn', p0 => 1, p_values => v_jlst);
    v_rec.oth_phn   := apex_json.get_varchar2(p_path => 'customer1[%d].oth_phn', p0 => 1, p_values => v_jlst);
    v_rec.mmd_nm    := apex_json.get_varchar2(p_path => 'customer1[%d].mmd_nm', p0 => 1, p_values => v_jlst);
    v_rec.nok_nm    := apex_json.get_varchar2(p_path => 'customer1[%d].nok_nm', p0 => 1, p_values => v_jlst);
    v_rec.nok_rln_cd := apex_json.get_varchar2(p_path => 'customer1[%d].nok_rln_cd', p0 => 1, p_values => v_jlst);
    v_rec.nok_phn := apex_json.get_varchar2(p_path => 'customer1[%d].nok_phn', p0 => 1, p_values => v_jlst);
    v_rec.nok_a_ad1 := apex_json.get_varchar2(p_path => 'customer1[%d].nok_a_ad1', p0 => 1, p_values => v_jlst);
    v_rec.nok_a_ad2 := apex_json.get_varchar2(p_path => 'customer1[%d].nok_a_ad2', p0 => 1, p_values => v_jlst);
    v_rec.nok_a_cty := apex_json.get_varchar2(p_path => 'customer1[%d].nok_a_cty', p0 => 1, p_values => v_jlst);
    v_rec.nok_a_sta_cd := apex_json.get_varchar2(p_path => 'customer1[%d].nok_a_sta_cd', p0 => 1, p_values => v_jlst);
    v_rec.nok_a_zip := apex_json.get_varchar2(p_path => 'customer1[%d].nok_a_zip', p0 => 1, p_values => v_jlst);
    v_rec.nok_a_ctr_cd := apex_json.get_varchar2(p_path => 'customer1[%d].nok_a_ctr_cd', p0 => 1, p_values => v_jlst);
    v_rec.bk_nm     := apex_json.get_varchar2(p_path => 'customer1[%d].bk_nm', p0 => 1, p_values => v_jlst);
    v_rec.bk_ac_no  := apex_json.get_varchar2(p_path => 'customer1[%d].bk_ac_no', p0 => 1, p_values => v_jlst);
    v_rec.bk_bv_no  := apex_json.get_varchar2(p_path => 'customer1[%d].bk_bv_no', p0 => 1, p_values => v_jlst);
    v_rec.bk_ac_nm  := apex_json.get_varchar2(p_path => 'customer1[%d].bk_ac_nm', p0 => 1, p_values => v_jlst);
    v_rec.bk_br_nm  := apex_json.get_varchar2(p_path => 'customer1[%d].bk_br_nm', p0 => 1, p_values => v_jlst);
    v_rec.bk_st_cd  := apex_json.get_varchar2(p_path => 'customer1[%d].bk_st_cd', p0 => 1, p_values => v_jlst);
    v_rec.bk_a_ad1  := apex_json.get_varchar2(p_path => 'customer1[%d].bk_a_ad1', p0 => 1, p_values => v_jlst);
    v_rec.bk_a_ad2  := apex_json.get_varchar2(p_path => 'customer1[%d].bk_a_ad2', p0 => 1, p_values => v_jlst);
    v_rec.bk_a_cty  := apex_json.get_varchar2(p_path => 'customer1[%d].bk_a_cty', p0 => 1, p_values => v_jlst);
    v_rec.bk_a_sta_cd := apex_json.get_varchar2(p_path => 'customer1[%d].bk_a_sta_cd', p0 => 1, p_values => v_jlst);
    v_rec.bk_a_zip  := apex_json.get_varchar2(p_path => 'customer1[%d].bk_a_zip', p0 => 1, p_values => v_jlst);
    v_rec.bk_a_ctr_cd := apex_json.get_varchar2(p_path => 'customer1[%d].bk_a_ctr_cd', p0 => 1, p_values => v_jlst);
    v_rec.ocp_nm := apex_json.get_varchar2(p_path => 'customer1[%d].ocp_nm', p0 => 1, p_values => v_jlst);
    v_rec.emp_nm := apex_json.get_varchar2(p_path => 'customer1[%d].emp_nm', p0 => 1, p_values => v_jlst);
    v_rec.emp_a_ad1 := apex_json.get_varchar2(p_path => 'customer1[%d].emp_a_ad1', p0 => 1, p_values => v_jlst);
    v_rec.emp_a_ad2 := apex_json.get_varchar2(p_path => 'customer1[%d].emp_a_ad2', p0 => 1, p_values => v_jlst);
    v_rec.emp_a_cty := apex_json.get_varchar2(p_path => 'customer1[%d].emp_a_cty', p0 => 1, p_values => v_jlst);
    v_rec.emp_a_sta_cd := apex_json.get_varchar2(p_path => 'customer1[%d].emp_a_sta_cd', p0 => 1, p_values => v_jlst);
    v_rec.emp_a_zip := apex_json.get_varchar2(p_path => 'customer1[%d].emp_a_zip', p0 => 1, p_values => v_jlst);
    v_rec.emp_a_ctr_cd := apex_json.get_varchar2(p_path => 'customer1[%d].emp_a_ctr_cd', p0 => 1, p_values => v_jlst);
    v_rec.emp_phn   := apex_json.get_varchar2(p_path => 'customer1[%d].emp_phn', p0 => 1, p_values => v_jlst);
    v_rec.ann_inc_amt := apex_json.get_number(p_path => 'customer1[%d].ann_inc_amt', p0 => 1, p_values => v_jlst);
    v_rec.c_pic_yn := apex_json.get_varchar2(p_path => 'customer1[%d].c_pic_yn', p0 => 1, p_values => v_jlst);
    v_rec.c_sig_yn := apex_json.get_varchar2(p_path => 'customer1[%d].c_sig_yn', p0 => 1, p_values => v_jlst);
    v_rec.c_ubl_yn := apex_json.get_varchar2(p_path => 'customer1[%d].c_ubl_yn', p0 => 1, p_values => v_jlst);
    v_rec.c_idc_yn := apex_json.get_varchar2(p_path => 'customer1[%d].c_idc_yn', p0 => 1, p_values => v_jlst);--
    -- Customer2
    v_rec.j_tt_dm     := apex_json.get_varchar2(p_path => 'customer2[%d].tt_dm', p0 => 1, p_values => v_jlst);
    v_rec.j_ls_nm     := apex_json.get_varchar2(p_path => 'customer2[%d].ls_nm', p0 => 1, p_values => v_jlst);
    v_rec.j_md_nm     := apex_json.get_varchar2(p_path => 'customer2[%d].md_nm', p0 => 1, p_values => v_jlst);
    v_rec.j_fi_nm     := apex_json.get_varchar2(p_path => 'customer2[%d].fi_nm', p0 => 1, p_values => v_jlst);
    v_rec.j_gdr_dm    := apex_json.get_varchar2(p_path => 'customer2[%d].gdr_dm', p0 => 1, p_values => v_jlst);
    v_rec.j_dob_dt    := fn_json_dt(apex_json.get_varchar2(p_path => 'customer2[%d].dob_dt', p0 => 1, p_values => v_jlst));
    v_rec.j_mar_st_dm := apex_json.get_varchar2(p_path => 'customer2[%d].mar_st_dm', p0 => 1, p_values => v_jlst);
    v_rec.j_nty_cd    := apex_json.get_varchar2(p_path => 'customer2[%d].nty_cd', p0 => 1, p_values => v_jlst);
    v_rec.j_pry_a_ad1 := apex_json.get_varchar2(p_path => 'customer2[%d].pry_a_ad1', p0 => 1, p_values => v_jlst);
    v_rec.j_pry_a_ad2 := apex_json.get_varchar2(p_path => 'customer2[%d].pry_a_ad2', p0 => 1, p_values => v_jlst);
    v_rec.j_pry_a_cty := apex_json.get_varchar2(p_path => 'customer2[%d].pry_a_cty', p0 => 1, p_values => v_jlst);
    v_rec.j_pry_a_sta_cd := apex_json.get_varchar2(p_path => 'customer2[%d].pry_a_sta_cd', p0 => 1, p_values => v_jlst);
    v_rec.j_pry_a_zip := apex_json.get_varchar2(p_path => 'customer2[%d].pry_a_zip', p0 => 1, p_values => v_jlst);
    v_rec.j_pry_a_ctr_cd := apex_json.get_varchar2(p_path => 'customer2[%d].pry_a_ctr_cd', p0 => 1, p_values => v_jlst);
    v_rec.j_pst_a_ad1 := apex_json.get_varchar2(p_path => 'customer2[%d].pst_a_ad1', p0 => 1, p_values => v_jlst);
    v_rec.j_pst_a_ad2 := apex_json.get_varchar2(p_path => 'customer2[%d].pst_a_ad2', p0 => 1, p_values => v_jlst);
    v_rec.j_pst_a_cty := apex_json.get_varchar2(p_path => 'customer2[%d].pst_a_cty', p0 => 1, p_values => v_jlst);
    v_rec.j_pst_a_sta_cd := apex_json.get_varchar2(p_path => 'customer2[%d].pst_a_sta_cd', p0 => 1, p_values => v_jlst);
    v_rec.j_pst_a_zip := apex_json.get_varchar2(p_path => 'customer2[%d].pst_a_zip', p0 => 1, p_values => v_jlst);
    v_rec.j_pst_a_ctr_cd := apex_json.get_varchar2(p_path => 'customer2[%d].pst_a_ctr_cd', p0 => 1, p_values => v_jlst);
    v_rec.j_pry_em_ad := apex_json.get_varchar2(p_path => 'customer2[%d].pry_em_ad', p0 => 1, p_values => v_jlst);
    v_rec.j_sec_em_ad := apex_json.get_varchar2(p_path => 'customer2[%d].sec_em_ad', p0 => 1, p_values => v_jlst);
    v_rec.j_mbl_phn   := apex_json.get_varchar2(p_path => 'customer2[%d].mbl_phn', p0 => 1, p_values => v_jlst);
    v_rec.j_oth_phn   := apex_json.get_varchar2(p_path => 'customer2[%d].oth_phn', p0 => 1, p_values => v_jlst);
    v_rec.j_mmd_nm    := apex_json.get_varchar2(p_path => 'customer2[%d].mmd_nm', p0 => 1, p_values => v_jlst);
    v_rec.j_nok_nm    := apex_json.get_varchar2(p_path => 'customer2[%d].nok_nm', p0 => 1, p_values => v_jlst);
    v_rec.j_nok_rln_cd := apex_json.get_varchar2(p_path => 'customer2[%d].nok_rln_cd', p0 => 1, p_values => v_jlst);
    v_rec.j_nok_phn := apex_json.get_varchar2(p_path => 'customer2[%d].nok_phn', p0 => 1, p_values => v_jlst);
    v_rec.j_nok_a_ad1 := apex_json.get_varchar2(p_path => 'customer2[%d].nok_a_ad1', p0 => 1, p_values => v_jlst);
    v_rec.j_nok_a_ad2 := apex_json.get_varchar2(p_path => 'customer2[%d].nok_a_ad2', p0 => 1, p_values => v_jlst);
    v_rec.j_nok_a_cty := apex_json.get_varchar2(p_path => 'customer2[%d].nok_a_cty', p0 => 1, p_values => v_jlst);
    v_rec.j_nok_a_sta_cd := apex_json.get_varchar2(p_path => 'customer2[%d].nok_a_sta_cd', p0 => 1, p_values => v_jlst);
    v_rec.j_nok_a_zip := apex_json.get_varchar2(p_path => 'customer2[%d].nok_a_zip', p0 => 1, p_values => v_jlst);
    v_rec.j_nok_a_ctr_cd := apex_json.get_varchar2(p_path => 'customer2[%d].nok_a_ctr_cd', p0 => 1, p_values => v_jlst);
    v_rec.j_bk_nm     := apex_json.get_varchar2(p_path => 'customer2[%d].bk_nm', p0 => 1, p_values => v_jlst);
    v_rec.j_bk_ac_no  := apex_json.get_varchar2(p_path => 'customer2[%d].bk_ac_no', p0 => 1, p_values => v_jlst);
    v_rec.j_bk_bv_no  := apex_json.get_varchar2(p_path => 'customer2[%d].bk_bv_no', p0 => 1, p_values => v_jlst);
    v_rec.j_bk_ac_nm  := apex_json.get_varchar2(p_path => 'customer2[%d].bk_ac_nm', p0 => 1, p_values => v_jlst);
    v_rec.j_bk_br_nm  := apex_json.get_varchar2(p_path => 'customer2[%d].bk_br_nm', p0 => 1, p_values => v_jlst);
    v_rec.j_bk_st_cd  := apex_json.get_varchar2(p_path => 'customer2[%d].bk_st_cd', p0 => 1, p_values => v_jlst);
    v_rec.j_bk_a_ad1  := apex_json.get_varchar2(p_path => 'customer2[%d].bk_a_ad1', p0 => 1, p_values => v_jlst);
    v_rec.j_bk_a_ad2  := apex_json.get_varchar2(p_path => 'customer2[%d].bk_a_ad2', p0 => 1, p_values => v_jlst);
    v_rec.j_bk_a_cty  := apex_json.get_varchar2(p_path => 'customer2[%d].bk_a_cty', p0 => 1, p_values => v_jlst);
    v_rec.j_bk_a_sta_cd := apex_json.get_varchar2(p_path => 'customer2[%d].bk_a_sta_cd', p0 => 1, p_values => v_jlst);
    v_rec.j_bk_a_zip  := apex_json.get_varchar2(p_path => 'customer2[%d].bk_a_zip', p0 => 1, p_values => v_jlst);
    v_rec.j_bk_a_ctr_cd := apex_json.get_varchar2(p_path => 'customer2[%d].bk_a_ctr_cd', p0 => 1, p_values => v_jlst);
    v_rec.j_ocp_nm := apex_json.get_varchar2(p_path => 'customer2[%d].ocp_nm', p0 => 1, p_values => v_jlst);
    v_rec.j_emp_nm := apex_json.get_varchar2(p_path => 'customer2[%d].emp_nm', p0 => 1, p_values => v_jlst);
    v_rec.j_emp_a_ad1 := apex_json.get_varchar2(p_path => 'customer2[%d].emp_a_ad1', p0 => 1, p_values => v_jlst);
    v_rec.j_emp_a_ad2 := apex_json.get_varchar2(p_path => 'customer2[%d].emp_a_ad2', p0 => 1, p_values => v_jlst);
    v_rec.j_emp_a_cty := apex_json.get_varchar2(p_path => 'customer2[%d].emp_a_cty', p0 => 1, p_values => v_jlst);
    v_rec.j_emp_a_sta_cd := apex_json.get_varchar2(p_path => 'customer2[%d].emp_a_sta_cd', p0 => 1, p_values => v_jlst);
    v_rec.j_emp_a_zip := apex_json.get_varchar2(p_path => 'customer2[%d].emp_a_zip', p0 => 1, p_values => v_jlst);
    v_rec.j_emp_a_ctr_cd := apex_json.get_varchar2(p_path => 'customer2[%d].emp_a_ctr_cd', p0 => 1, p_values => v_jlst);
    v_rec.j_emp_phn   := apex_json.get_varchar2(p_path => 'customer2[%d].emp_phn', p0 => 1, p_values => v_jlst);
    v_rec.j_ann_inc_amt := apex_json.get_number(p_path => 'customer2[%d].ann_inc_amt', p0 => 1, p_values => v_jlst);
    v_rec.j_c_pic_yn := apex_json.get_varchar2(p_path => 'customer2[%d].c_pic_yn', p0 => 1, p_values => v_jlst);
    v_rec.j_c_sig_yn := apex_json.get_varchar2(p_path => 'customer2[%d].c_sig_yn', p0 => 1, p_values => v_jlst);
    v_rec.j_c_ubl_yn := apex_json.get_varchar2(p_path => 'customer2[%d].c_ubl_yn', p0 => 1, p_values => v_jlst);
    v_rec.j_c_idc_yn := apex_json.get_varchar2(p_path => 'customer2[%d].c_idc_yn', p0 => 1, p_values => v_jlst);--
    --
    v_ret := pkwf_30_cs_new_j.fn_ins(v_rec);
    --
    logger.log('Return Code => ' || v_ret.ret_cd || ', Corporate Customer Key => ' || v_ret.po_dc_k);
    IF v_ret.ret_cd = '0' THEN
      v_return := fn_gen_json(v_ret.ret_cd, v_ret.po_dc_k);
    ELSE 
      v_return := fn_gen_json(v_ret.ret_cd, v_ret.err_dsc);
    END IF;     
    --
    logger.append_param(pv_lp,' RSP-JSON',v_return);
    logger.log('CS-Customer J', pv_ls, NULL, pv_lp);
    RETURN v_return;
    --
  EXCEPTION
    WHEN OTHERS THEN
      logger.log_error('exception', pv_ls, dbms_utility.format_error_stack ||'|'||
                                          dbms_utility.format_error_backtrace, pv_lp);
      logger.log('CS-Customer J', pv_ls, NULL, pv_lp);
      v_return := fn_gen_json(sqlcode, sqlerrm);
      RETURN v_return;      
  END fn_cs_new_j;  
  --
  -- CS New Corporate
  FUNCTION fn_cs_new_c(pi_obj IN CLOB) RETURN CLOB IS
    --
    v_rec    wf_vi_30_cs_new_c%ROWTYPE;
    v_ret    pkwf_90_gen.r_ret;
    v_jlst   apex_json.t_values;
    v_return CLOB;
    --
  BEGIN
    --
    pv_ls := pv_ls || '.fn_cs_new_c';
    logger.append_param(pv_lp,' REQ-JSON',pi_obj);
    --
    v_jlst := fn_parse_json(pi_obj);
    v_rec.org_nm    := apex_json.get_varchar2(p_path => 'customer[%d].org_nm', p0 => 1, p_values => v_jlst);
    v_rec.reg_nbr   := apex_json.get_varchar2(p_path => 'customer[%d].reg_nbr', p0 => 1, p_values => v_jlst);
    v_rec.tax_id    := apex_json.get_varchar2(p_path => 'customer[%d].tax_id', p0 => 1, p_values => v_jlst);
    v_rec.reg_dt    := fn_json_dt(apex_json.get_varchar2(p_path => 'customer[%d].reg_dt', p0 => 1, p_values => v_jlst));
    v_rec.reg_ctr_cd := apex_json.get_varchar2(p_path => 'customer[%d].reg_ctr_cd', p0 => 1, p_values => v_jlst);
    v_rec.org_ad1   := apex_json.get_varchar2(p_path => 'customer[%d].org_ad1', p0 => 1, p_values => v_jlst);
    v_rec.org_ad2   := apex_json.get_varchar2(p_path => 'customer[%d].org_ad2', p0 => 1, p_values => v_jlst);
    v_rec.org_cty   := apex_json.get_varchar2(p_path => 'customer[%d].org_cty', p0 => 1, p_values => v_jlst);
    v_rec.org_sta_cd := apex_json.get_varchar2(p_path => 'customer[%d].org_sta_cd', p0 => 1, p_values => v_jlst);
    v_rec.org_zip   := apex_json.get_varchar2(p_path => 'customer[%d].org_zip', p0 => 1, p_values => v_jlst);
    v_rec.org_ctr_cd := apex_json.get_varchar2(p_path => 'customer[%d].org_ctr_cd', p0 => 1, p_values => v_jlst);
    v_rec.est_trn_val := apex_json.get_varchar2(p_path => 'customer[%d].est_trn_val', p0 => 1, p_values => v_jlst);
    v_rec.bk_nm     := apex_json.get_varchar2(p_path => 'customer[%d].bk_nm', p0 => 1, p_values => v_jlst);
    v_rec.bk_ac_no  := apex_json.get_varchar2(p_path => 'customer[%d].bk_ac_no', p0 => 1, p_values => v_jlst);
    v_rec.bk_ac_nm  := apex_json.get_varchar2(p_path => 'customer[%d].bk_ac_nm', p0 => 1, p_values => v_jlst);
    v_rec.bk_br_nm  := apex_json.get_varchar2(p_path => 'customer[%d].bk_br_nm', p0 => 1, p_values => v_jlst);
    v_rec.bk_st_cd  := apex_json.get_varchar2(p_path => 'customer[%d].bk_st_cd', p0 => 1, p_values => v_jlst);
    v_rec.bk_a_ad1  := apex_json.get_varchar2(p_path => 'customer[%d].bk_a_ad1', p0 => 1, p_values => v_jlst);
    v_rec.bk_a_ad2  := apex_json.get_varchar2(p_path => 'customer[%d].bk_a_ad2', p0 => 1, p_values => v_jlst);
    v_rec.bk_a_cty  := apex_json.get_varchar2(p_path => 'customer[%d].bk_a_cty', p0 => 1, p_values => v_jlst);
    v_rec.bk_a_sta_cd := apex_json.get_varchar2(p_path => 'customer[%d].bk_a_sta_cd', p0 => 1, p_values => v_jlst);
    v_rec.bk_a_zip  := apex_json.get_varchar2(p_path => 'customer[%d].bk_a_zip', p0 => 1, p_values => v_jlst);
    v_rec.bk_a_ctr_cd := apex_json.get_varchar2(p_path => 'customer[%d].bk_a_ctr_cd', p0 => 1, p_values => v_jlst);
    --
    logger.log('Coporate Insert ');
    v_ret := pkwf_30_cs_new_c.fn_ins(v_rec);
    --
    IF v_ret.ret_cd = '0' THEN
       v_return := fn_gen_json(v_ret.ret_cd, v_ret.po_dc_k);
    ELSE 
      v_return := fn_gen_json(v_ret.ret_cd, v_ret.err_dsc);
    END IF;     
    --
    logger.append_param(pv_lp,' RSP-JSON',v_return);
    logger.log('CS-Customer C', pv_ls, NULL, pv_lp);
    RETURN v_return;
    --
  EXCEPTION
    WHEN OTHERS THEN
      logger.log_error('exception', pv_ls, dbms_utility.format_error_stack ||'|'||
                                          dbms_utility.format_error_backtrace, pv_lp);
      logger.log('CS-Customer C', pv_ls, NULL, pv_lp);
      v_return := fn_gen_json(sqlcode, sqlerrm);
      RETURN v_return;      
  END fn_cs_new_c;  
  --
END pkwf_30_ws;
Error report -
Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\package-body\pkwf_89_cs_body.sql
In command -
CREATE OR REPLACE PACKAGE BODY pkwf_89_cs AS
  --
  /* Created By       : Femi Akintoye 
  ** Date Created     : 11-MAR-2016
  **
  ** PURPOSE: WF Routines for Preship Objects
  **
  ** MODIFICATION HISTORY:
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **  
  ** Copyright:  Neulogic Solutions Ltd, 2016
  **
  */
  --
  /* Private Routines */
  --
  --
  /* Public Routines */
  --
  PROCEDURE pr_prc_ctc_c (pi_rec IN OUT pkwf_90_gen.r_cs_new_c) IS
    --
    v_r     pkwf_90_gen.r_cs_new_c := pi_rec;
    v_ctc   pkcs_90_wf.r_00_ctc@WF_SY;
    v_ptf   pkst_90_wf.r_00_ptf@WF_SY;
  BEGIN
    --
--    v_ctc.ctc_k,
    v_ctc.r_ps             := 'WF';
--    v_ctc.c_n,
--    v_ctc.brch_id,
--    v_ctc.cus_tp_dm,
--    v_ctc.eff_dt,
--    v_ctc.cus_id,
--    v_ctc.ctc_id,
--    v_ctc.appr_stat_dm,
    v_ctc.ind_yn           := '0';
    --v_ctc.sta_dm,
    v_ctc.reg_id := v_r.reg_nbr;
    v_ctc.reg_dt := v_r.reg_dt;
   -- v_ctc.nty_cd_k         := pkwf_00_00.fn_get_nty_k(pi_id => v_r.nty_cd);
    --v_ctc.orig_sta_k,     
    --v_ctc.orig_lga_k,         
    v_ctc.tax_idn_nbr :=  v_r.tax_id;
    --v_ctc.tov_cd_k,
    --v_ctc.ttl_cd_k         := pkwf_00_00.fn_get_ttl_k(pi_id => v_r.tt_dm);
    --v_ctc.lst_nme          := v_r.ls_nm;
    --v_ctc.fir_nme          := v_r.fi_nm;
    --v_ctc.mle_nme          := v_r.md_nm;
    v_ctc.org_nme          := v_r.org_nm;
    --v_ctc.nme_sfx,
    --v_ctc.dt_of_bth        := v_r.dob_dt;
    --v_ctc.mrl_sta_dm       := v_r.mar_st_dm;
    --v_ctc.wdd_annv_dt,
    --v_ctc.sps_ful_nme,
    --v_ctc.gdr_dm           := v_r.gdr_dm;
    --v_ctc.mtr_mdn_nme      := v_r.mmd_nm;
    -- Identification Details
    --v_ctc.idn_cd_k,
    --v_ctc.idn_cd_dsc,
    --v_ctc.idn_nbr,
    --v_ctc.idn_iss_dt,
    --v_ctc.idn_exp_dt,
    --v_ctc.idn_issg_atry,
    --
    -- Employee Details
    --v_ctc.jb_ttl_dsc       := v_r.ocp_nm;
    --v_ctc.empr_nme         := v_r.emp_nm;
    --v_ctc.empr_adr_l1      := v_r.emp_a_ad1;
    --v_ctc.empr_adr_l2      := v_r.emp_a_ad2;   
    --v_ctc.empr_adr_cty     := v_r.emp_a_cty;
    --IF v_r.pst_a_ctr_cd IS NOT NULL THEN
      --v_ctc.empr_adr_ctr_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_r.emp_a_ctr_cd);
    --END IF;
    --IF v_r.pst_a_sta_cd IS NOT NULL THEN
      --v_ctc.empr_adr_sta_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_r.emp_a_ctr_cd,
                                                        -- pi_id     => v_r.emp_a_sta_cd);
    --END IF;
    --
    --v_ctc.bus_phn          := v_r.emp_phn;
    --v_ctc.hom_phn          := v_r.oth_phn;
    --v_ctc.mbl_phn          := v_r.mbl_phn;
    --v_ctc.sms_phn,
    --v_ctc.fax_nbr,
    --v_ctc.pry_eml_adr      := v_r.pry_em_ad;
    --v_ctc.alt_eml_adr      := v_r.sec_em_ad;
    -- Address Details
    v_ctc.pry_adr_l1       := v_r.org_ad1;
    v_ctc.pry_adr_l2       := v_r.org_ad2;
    v_ctc.pry_adr_cty      := v_r.org_cty;
    v_ctc.pry_adr_zip      := v_r.org_zip;
    v_ctc.pry_adr_sta_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_r.org_ctr_cd,
                                                      pi_id     => v_r.org_sta_cd);
    v_ctc.pry_adr_ctr_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_r.org_ctr_cd);
    --v_ctc.alt_adr_l1       := v_r.pst_a_ad1;
    --v_ctc.alt_adr_l2       := v_r.pst_a_ad2;
    --v_ctc.alt_adr_cty      := v_r.pst_a_cty;
    --v_ctc.alt_adr_zip      := v_r.pst_a_zip;
    --IF v_r.pst_a_ctr_cd IS NOT NULL THEN
      --v_ctc.alt_adr_ctr_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_r.pst_a_ctr_cd);
    --END IF;
    --IF v_r.pst_a_sta_cd IS NOT NULL THEN
      --v_ctc.alt_adr_sta_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_r.pst_a_ctr_cd,
                                                        --pi_id     => v_r.pst_a_sta_cd);
    --END IF;
    --v_ctc.pst_adr_dm,
    --
    -- Bank Details
    v_ctc.pry_bnk_nme      := v_r.bk_nm;
    v_ctc.pry_bnk_srt_cd   := v_r.bk_st_cd;
    v_ctc.pry_bnk_acct_nbr := v_r.bk_ac_no;
    --v_ctc.pry_bnk_adr,
    --v_ctc.bvn_id           := v_r.bk_bv_no;
    --
    -- Next of Kin (NOK)
    --v_ctc.nok_yn,
    --v_ctc.nok_ctc_k,
    --v_ctc.nok_ctc_id,
    --v_ctc.nok_ctc_nme      := v_r.nok_nm;
    --v_ctc.nok_ttl_cd_k,
    --v_ctc.nok_lst_nme,
    --v_ctc.nok_mle_nme,
    --v_ctc.nok_fir_nme,
    --IF v_r.nok_rln_cd IS NOT NULL THEN
      --v_ctc.nok_rltn_cd_k    := pkwf_00_00.fn_get_rln_k(pi_id => v_r.nok_rln_cd);
    --END IF;
    --v_ctc.nok_rltn_cd_dsc,
    --v_ctc.nok_adr_l1       := v_r.nok_a_ad1;
    --v_ctc.nok_adr_l2       := v_r.nok_a_ad2;
    --v_ctc.nok_adr_cty      := v_r.nok_a_cty;
    --v_ctc.nok_adr_zip      := v_r.nok_a_zip;
    --IF v_r.nok_a_ctr_cd IS NOT NULL THEN
     -- v_ctc.nok_adr_ctr_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_r.nok_a_ctr_cd);
    --END IF;
    --IF v_r.nok_a_sta_cd IS NOT NULL THEN
    -- v_ctc.nok_adr_sta_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_r.nok_a_ctr_cd,
                                                    --   pi_id     => v_r.nok_a_sta_cd);
    --END IF;
    --v_ctc.nok_pry_phn_nbr  := v_r.nok_phn;
    --v_ctc.nok_alt_phn_nbr,
    --v_ctc.nok_pry_eml_adr,
    --v_ctc.nok_alt_eml_adr
    --
    DECLARE
      v_ctc_k wf_00_00_dtd.n38%TYPE;
      v_cus_k wf_00_00_dtd.n38%TYPE;
      v_k     wf_00_00_dtd.n38%TYPE;
    BEGIN
logger.log('STARTING CREATION PROCESS');      
      pkcs_90_wf.pr_prc_ctc@WF_SY(pi_rec => v_ctc,
                                  po_ctc_k => v_ctc_k,
                                  po_cus_k => v_cus_k);
      --
logger.log('CREATED NEW CUSTOMER ['||v_ctc.cus_id||']');      
      --
      -- Push images accross and process
      v_k := pkwf_00_00.fn_rk;
      INSERT
        INTO cs_90_wf_blb
            (row_key, dc_k, blb_ref, ctc_k, cus_k, tp_dm, wf_blb)
      SELECT
            v_k, row_key, 'x', v_ctc_k, v_cus_k, 'P', pic_img
        FROM wf_vi_30_cs_new
       WHERE row_key = v_r.row_key;
       INSERT INTO cs_90_wf_blb@wf_sy SELECT * FROM cs_90_wf_blb WHERE row_key = v_r.row_key;
      --
      v_k := pkwf_00_00.fn_rk;
      INSERT
        INTO cs_90_wf_blb
            (row_key, dc_k, blb_ref, ctc_k, cus_k, tp_dm, wf_blb)
      SELECT
            v_k, row_key, 'x', v_ctc_k, v_cus_k, 'S', sig_img
        FROM wf_vi_30_cs_new
       WHERE row_key = v_r.row_key;
       INSERT INTO cs_90_wf_blb@wf_sy SELECT * FROM cs_90_wf_blb WHERE row_key = v_r.row_key;
      --
logger.log('CSNEW 2 ['||v_ctc.cus_id||']');      
      v_k := pkwf_00_00.fn_rk;
      INSERT
        INTO cs_90_wf_blb
            (row_key, dc_k, blb_ref, ctc_k, cus_k, tp_dm, wf_blb)
      SELECT v_k, v_r.row_key, 'x', v_ctc_k, v_cus_k, 'D', dc_blb
        FROM wf_20_dc
       WHERE dc_id = v_r.dc_id;
       INSERT INTO cs_90_wf_blb@wf_sy SELECT * FROM cs_90_wf_blb WHERE row_key = v_r.row_key;
      --
logger.log('CSNEW 3 ['||v_ctc.cus_id||']');      
      pkcs_90_wf.pr_prc_img@WF_SY(pi_dc_k   => v_r.row_key,
                                  pi_dc_id  => v_r.dc_id,
                                  pi_cus_k  => v_cus_k,
                                  pi_doc_tp => 'CD001');  -- NEED A PARAMETER FOR THIS, DOCUMENT TYPE
      --
logger.log('IMAGES PROCESSED');      
      pkcs_90_wf.pr_prc_web@WF_SY(pi_cus_k => v_cus_k); -- Web mapping
      --      
logger.log('WEB ACCESS MAPPED');      
      --
      v_ptf.mkt_id     := 'NSE1';
      v_ptf.ptf_tp_id  := '10';    -- NEED A PARAMETER FOR THIS, PORTFOLIO TYPE
      v_ptf.cus_id     := v_ctc.cus_id;
      v_ptf.cus_nme    := v_ctc.org_nme;
      v_ptf.prd_id     := 'P10';   -- NEED A PARAMETER FOR THIS, PRODUCT
      v_ptf.mkt_act_id := v_r.mkt_act_id;
      v_ptf.mkt_chn_no := v_r.mkt_chn_no;
      --     
      pkst_90_wf.pr_cre_ptf@WF_SY(pi_rec => v_ptf);
      --
logger.log('PORTFOLIOS CREATED');      
    END;
    --
  EXCEPTION
    WHEN OTHERS THEN
      logger.log('ERROR SENDING NEW CUS - '||dbms_utility.format_error_backtrace);
      ROLLBACK;
      RAISE;
  END pr_prc_ctc_c;  
  --
  
  PROCEDURE pr_prc_ctc (pi_rec IN OUT pkwf_90_gen.r_cs_new) IS
    --
    v_r     pkwf_90_gen.r_cs_new := pi_rec;
    v_ctc   pkcs_90_wf.r_00_ctc@WF_SY;
    v_ptf   pkst_90_wf.r_00_ptf@WF_SY;
  BEGIN
    --
--    v_ctc.ctc_k,
    v_ctc.r_ps             := 'WF';
--    v_ctc.c_n,
--    v_ctc.brch_id,
--    v_ctc.cus_tp_dm,
--    v_ctc.eff_dt,
--    v_ctc.cus_id,
--    v_ctc.ctc_id,
--    v_ctc.appr_stat_dm,
    v_ctc.ind_yn           := '1';
    --v_ctc.sta_dm,
    --v_ctc.reg_id,
    --v_ctc.reg_dt,
    v_ctc.nty_cd_k         := pkwf_00_00.fn_get_nty_k(pi_id => v_r.nty_cd);
    --v_ctc.orig_sta_k,     
    --v_ctc.orig_lga_k,         
    --v_ctc.tax_idn_nbr,
    --v_ctc.tov_cd_k,
    v_ctc.ttl_cd_k         := pkwf_00_00.fn_get_ttl_k(pi_id => v_r.tt_dm);
    v_ctc.lst_nme          := v_r.ls_nm;
    v_ctc.fir_nme          := v_r.fi_nm;
    v_ctc.mle_nme          := v_r.md_nm;
    v_ctc.org_nme          := UPPER(v_r.ls_nm)||' '||INITCAP(v_r.fi_nm)||' '||INITCAP(v_r.md_nm);
    --v_ctc.nme_sfx,
    v_ctc.dt_of_bth        := v_r.dob_dt;
    v_ctc.mrl_sta_dm       := v_r.mar_st_dm;
    --v_ctc.wdd_annv_dt,
    --v_ctc.sps_ful_nme,
    v_ctc.gdr_dm           := v_r.gdr_dm;
    v_ctc.mtr_mdn_nme      := v_r.mmd_nm;
    -- Identification Details
    --v_ctc.idn_cd_k,
    --v_ctc.idn_cd_dsc,
    --v_ctc.idn_nbr,
    --v_ctc.idn_iss_dt,
    --v_ctc.idn_exp_dt,
    --v_ctc.idn_issg_atry,
    --
    -- Employee Details
    v_ctc.jb_ttl_dsc       := v_r.ocp_nm;
    v_ctc.empr_nme         := v_r.emp_nm;
    v_ctc.empr_adr_l1      := v_r.emp_a_ad1;
    v_ctc.empr_adr_l2      := v_r.emp_a_ad2;   
    v_ctc.empr_adr_cty     := v_r.emp_a_cty;
    IF v_r.pst_a_ctr_cd IS NOT NULL THEN
      v_ctc.empr_adr_ctr_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_r.emp_a_ctr_cd);
    END IF;
    IF v_r.pst_a_sta_cd IS NOT NULL THEN
      v_ctc.empr_adr_sta_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_r.emp_a_ctr_cd,
                                                         pi_id     => v_r.emp_a_sta_cd);
    END IF;
    --
    v_ctc.bus_phn          := v_r.emp_phn;
    v_ctc.hom_phn          := v_r.oth_phn;
    v_ctc.mbl_phn          := v_r.mbl_phn;
    --v_ctc.sms_phn,
    --v_ctc.fax_nbr,
    v_ctc.pry_eml_adr      := v_r.pry_em_ad;
    v_ctc.alt_eml_adr      := v_r.sec_em_ad;
    -- Address Details
    v_ctc.pry_adr_l1       := v_r.pry_a_ad1;
    v_ctc.pry_adr_l2       := v_r.pry_a_ad2;
    v_ctc.pry_adr_cty      := v_r.pry_a_cty;
    v_ctc.pry_adr_zip      := v_r.pry_a_zip;
    v_ctc.pry_adr_sta_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_r.pry_a_ctr_cd,
                                                      pi_id     => v_r.pry_a_sta_cd);
    v_ctc.pry_adr_ctr_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_r.pry_a_ctr_cd);
    v_ctc.alt_adr_l1       := v_r.pst_a_ad1;
    v_ctc.alt_adr_l2       := v_r.pst_a_ad2;
    v_ctc.alt_adr_cty      := v_r.pst_a_cty;
    v_ctc.alt_adr_zip      := v_r.pst_a_zip;
    IF v_r.pst_a_ctr_cd IS NOT NULL THEN
      v_ctc.alt_adr_ctr_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_r.pst_a_ctr_cd);
    END IF;
    IF v_r.pst_a_sta_cd IS NOT NULL THEN
      v_ctc.alt_adr_sta_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_r.pst_a_ctr_cd,
                                                        pi_id     => v_r.pst_a_sta_cd);
    END IF;
    --v_ctc.pst_adr_dm,
    --
    -- Bank Details
    v_ctc.pry_bnk_nme      := v_r.bk_nm;
    v_ctc.pry_bnk_srt_cd   := v_r.bk_st_cd;
    v_ctc.pry_bnk_acct_nbr := v_r.bk_ac_no;
    --v_ctc.pry_bnk_adr,
    v_ctc.bvn_id           := v_r.bk_bv_no;
    --
    -- Next of Kin (NOK)
    --v_ctc.nok_yn,
    --v_ctc.nok_ctc_k,
    --v_ctc.nok_ctc_id,
    v_ctc.nok_ctc_nme      := v_r.nok_nm;
    --v_ctc.nok_ttl_cd_k,
    --v_ctc.nok_lst_nme,
    --v_ctc.nok_mle_nme,
    --v_ctc.nok_fir_nme,
    IF v_r.nok_rln_cd IS NOT NULL THEN
      v_ctc.nok_rltn_cd_k    := pkwf_00_00.fn_get_rln_k(pi_id => v_r.nok_rln_cd);
    END IF;
    --v_ctc.nok_rltn_cd_dsc,
    v_ctc.nok_adr_l1       := v_r.nok_a_ad1;
    v_ctc.nok_adr_l2       := v_r.nok_a_ad2;
    v_ctc.nok_adr_cty      := v_r.nok_a_cty;
    v_ctc.nok_adr_zip      := v_r.nok_a_zip;
    IF v_r.nok_a_ctr_cd IS NOT NULL THEN
      v_ctc.nok_adr_ctr_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_r.nok_a_ctr_cd);
    END IF;
    IF v_r.nok_a_sta_cd IS NOT NULL THEN
     v_ctc.nok_adr_sta_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_r.nok_a_ctr_cd,
                                                       pi_id     => v_r.nok_a_sta_cd);
    END IF;
    v_ctc.nok_pry_phn_nbr  := v_r.nok_phn;
    --v_ctc.nok_alt_phn_nbr,
    --v_ctc.nok_pry_eml_adr,
    --v_ctc.nok_alt_eml_adr
    --
    DECLARE
      v_ctc_k wf_00_00_dtd.n38%TYPE;
      v_cus_k wf_00_00_dtd.n38%TYPE;
      v_k     wf_00_00_dtd.n38%TYPE;
      v_b     BLOB := EMPTY_BLOB();
    BEGIN
logger.log('STARTING CREATION PROCESS');      
      pkcs_90_wf.pr_prc_ctc@WF_SY(pi_rec => v_ctc,
                                  po_ctc_k => v_ctc_k,
                                  po_cus_k => v_cus_k);
      --
logger.log('CREATED NEW CUSTOMER ['||v_ctc.cus_id||']'|| ' ROW KEY=>' || v_r.row_key);      
      --
      -- Push images accross and process
      v_k := pkwf_00_00.fn_rk;
      INSERT INTO cs_90_wf_blb
            (row_key, dc_k, blb_ref, ctc_k, cus_k, tp_dm, wf_blb)
       SELECT
            v_k, row_key, 'x', v_ctc_k, v_cus_k, 'P', pic_img
        FROM wf_vi_30_cs_new
       WHERE row_key = v_r.row_key;
       INSERT INTO cs_90_wf_blb@wf_sy SELECT * FROM cs_90_wf_blb WHERE row_key = v_r.row_key;
      --
      v_k := pkwf_00_00.fn_rk;
      INSERT
        INTO cs_90_wf_blb
            (row_key, dc_k, blb_ref, ctc_k, cus_k, tp_dm, wf_blb)
      SELECT
            v_k, row_key, 'x', v_ctc_k, v_cus_k, 'S', sig_img
        FROM wf_vi_30_cs_new
       WHERE row_key = v_r.row_key;
       INSERT INTO cs_90_wf_blb@wf_sy SELECT * FROM cs_90_wf_blb WHERE row_key = v_r.row_key;
      --
logger.log('CSNEW 2 ['||v_ctc.cus_id||']');      
      v_k := pkwf_00_00.fn_rk;
      INSERT
        INTO cs_90_wf_blb
            (row_key, dc_k, blb_ref, ctc_k, cus_k, tp_dm, wf_blb)
      SELECT v_k, v_r.row_key, 'x', v_ctc_k, v_cus_k, 'D', dc_blb
        FROM wf_20_dc
       WHERE dc_id = v_r.dc_id;
       INSERT INTO cs_90_wf_blb@wf_sy SELECT * FROM cs_90_wf_blb WHERE row_key = v_r.row_key;
      --
logger.log('CSNEW 3 ['||v_ctc.cus_id||']');      
      pkcs_90_wf.pr_prc_img@WF_SY(pi_dc_k   => v_r.row_key,
                                  pi_dc_id  => v_r.dc_id,
                                  pi_cus_k  => v_cus_k,
                                  pi_doc_tp => 'CD001');  -- NEED A PARAMETER FOR THIS, DOCUMENT TYPE
      --
logger.log('IMAGES PROCESSED');      
      pkcs_90_wf.pr_prc_web@WF_SY(pi_cus_k => v_cus_k); -- Web mapping
      --      
logger.log('WEB ACCESS MAPPED');      
      --
      v_ptf.mkt_id     := 'NSE1';
      v_ptf.ptf_tp_id  := '10';    -- NEED A PARAMETER FOR THIS, PORTFOLIO TYPE
      v_ptf.cus_id     := v_ctc.cus_id;
      v_ptf.cus_nme    := v_ctc.org_nme;
      v_ptf.prd_id     := 'P10';   -- NEED A PARAMETER FOR THIS, PRODUCT
      v_ptf.mkt_act_id := v_r.mkt_act_id;
      v_ptf.mkt_chn_no := v_r.mkt_chn_no;
      --     
      pkst_90_wf.pr_cre_ptf@WF_SY(pi_rec => v_ptf);
      --
logger.log('PORTFOLIOS CREATED');      
    END;
    --
  EXCEPTION
    WHEN OTHERS THEN
      logger.log('ERROR SENDING NEW CUS - '||dbms_utility.format_error_backtrace);
      ROLLBACK;
      RAISE;
  END pr_prc_ctc;  
  --
  --
  PROCEDURE pr_prc_ctc_j (pi_rec   IN OUT pkwf_90_gen.r_cs_new,
                          pi_rec_j IN OUT pkwf_90_gen.r_cs_new) IS
    --
    v_r      pkwf_90_gen.r_cs_new := pi_rec;
    v_j      pkwf_90_gen.r_cs_new := pi_rec_j;
    v_ctc    pkcs_90_wf.r_00_ctc@WF_SY;
    v_ctc_j  pkcs_90_wf.r_00_ctc@WF_SY;
    v_ptf    pkst_90_wf.r_00_ptf@WF_SY;
  BEGIN
    -- 
    --==========================================================================
    -- PRIMARY CONTACT
    v_ctc.r_ps             := 'WF';
    v_ctc.ind_yn           := '1';
    v_ctc.nty_cd_k         := pkwf_00_00.fn_get_nty_k(pi_id => v_r.nty_cd);
    v_ctc.ttl_cd_k         := pkwf_00_00.fn_get_ttl_k(pi_id => v_r.tt_dm);
    v_ctc.lst_nme          := v_r.ls_nm;
    v_ctc.fir_nme          := v_r.fi_nm;
    v_ctc.mle_nme          := v_r.md_nm;
    v_ctc.org_nme          := UPPER(v_r.ls_nm)||' '||INITCAP(v_r.fi_nm)||' '||INITCAP(v_r.md_nm);
    v_ctc.dt_of_bth        := v_r.dob_dt;
    v_ctc.mrl_sta_dm       := v_r.mar_st_dm;
    v_ctc.gdr_dm           := v_r.gdr_dm;
    v_ctc.mtr_mdn_nme      := v_r.mmd_nm;
    -- Employee Details
    v_ctc.jb_ttl_dsc       := v_r.ocp_nm;
    v_ctc.empr_nme         := v_r.emp_nm;
    v_ctc.empr_adr_l1      := v_r.emp_a_ad1;
    v_ctc.empr_adr_l2      := v_r.emp_a_ad2;   
    v_ctc.empr_adr_cty     := v_r.emp_a_cty;
    IF v_r.pst_a_ctr_cd IS NOT NULL THEN
      v_ctc.empr_adr_ctr_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_r.emp_a_ctr_cd);
    END IF;
    IF v_r.pst_a_sta_cd IS NOT NULL THEN
      v_ctc.empr_adr_sta_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_r.emp_a_ctr_cd,
                                                         pi_id     => v_r.emp_a_sta_cd);
    END IF;
    --
    v_ctc.bus_phn          := v_r.emp_phn;
    v_ctc.hom_phn          := v_r.oth_phn;
    v_ctc.mbl_phn          := v_r.mbl_phn;
    v_ctc.pry_eml_adr      := v_r.pry_em_ad;
    v_ctc.alt_eml_adr      := v_r.sec_em_ad;
    -- Address Details
    v_ctc.pry_adr_l1       := v_r.pry_a_ad1;
    v_ctc.pry_adr_l2       := v_r.pry_a_ad2;
    v_ctc.pry_adr_cty      := v_r.pry_a_cty;
    v_ctc.pry_adr_zip      := v_r.pry_a_zip;
    v_ctc.pry_adr_sta_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_r.pry_a_ctr_cd,
                                                      pi_id     => v_r.pry_a_sta_cd);
    v_ctc.pry_adr_ctr_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_r.pry_a_ctr_cd);
    v_ctc.alt_adr_l1       := v_r.pst_a_ad1;
    v_ctc.alt_adr_l2       := v_r.pst_a_ad2;
    v_ctc.alt_adr_cty      := v_r.pst_a_cty;
    v_ctc.alt_adr_zip      := v_r.pst_a_zip;
    IF v_r.pst_a_ctr_cd IS NOT NULL THEN
      v_ctc.alt_adr_ctr_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_r.pst_a_ctr_cd);
    END IF;
    IF v_r.pst_a_sta_cd IS NOT NULL THEN
      v_ctc.alt_adr_sta_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_r.pst_a_ctr_cd,
                                                        pi_id     => v_r.pst_a_sta_cd);
    END IF;
    -- Bank Details
    v_ctc.pry_bnk_nme      := v_r.bk_nm;
    v_ctc.pry_bnk_srt_cd   := v_r.bk_st_cd;
    v_ctc.pry_bnk_acct_nbr := v_r.bk_ac_no;
    --v_ctc.pry_bnk_adr,
    v_ctc.bvn_id           := v_r.bk_bv_no;
    --
    -- Next of Kin (NOK)
    v_ctc.nok_ctc_nme      := v_r.nok_nm;
    IF v_r.nok_rln_cd IS NOT NULL THEN
      v_ctc.nok_rltn_cd_k    := pkwf_00_00.fn_get_rln_k(pi_id => v_r.nok_rln_cd);
    END IF;
    --v_ctc.nok_rltn_cd_dsc,
    v_ctc.nok_adr_l1       := v_r.nok_a_ad1;
    v_ctc.nok_adr_l2       := v_r.nok_a_ad2;
    v_ctc.nok_adr_cty      := v_r.nok_a_cty;
    v_ctc.nok_adr_zip      := v_r.nok_a_zip;
    IF v_r.nok_a_ctr_cd IS NOT NULL THEN
      v_ctc.nok_adr_ctr_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_r.nok_a_ctr_cd);
    END IF;
    IF v_r.nok_a_sta_cd IS NOT NULL THEN
     v_ctc.nok_adr_sta_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_r.nok_a_ctr_cd,
                                                       pi_id     => v_r.nok_a_sta_cd);
    END IF;
    v_ctc.nok_pry_phn_nbr  := v_r.nok_phn;
    --
    --==========================================================================
    -- SECONDARY CONTACT
    v_ctc_j.r_ps             := 'WF';
    v_ctc_j.ind_yn           := '1';
    v_ctc_j.nty_cd_k         := pkwf_00_00.fn_get_nty_k(pi_id => v_j.nty_cd);
    v_ctc_j.ttl_cd_k         := pkwf_00_00.fn_get_ttl_k(pi_id => v_j.tt_dm);
    v_ctc_j.lst_nme          := v_j.ls_nm;
    v_ctc_j.fir_nme          := v_j.fi_nm;
    v_ctc_j.mle_nme          := v_j.md_nm;
    v_ctc_j.org_nme          := UPPER(v_j.ls_nm)||' '||INITCAP(v_j.fi_nm)||' '||INITCAP(v_j.md_nm);
    v_ctc_j.dt_of_bth        := v_j.dob_dt;
    v_ctc_j.mrl_sta_dm       := v_j.mar_st_dm;
    v_ctc_j.gdr_dm           := v_j.gdr_dm;
    v_ctc_j.mtr_mdn_nme      := v_j.mmd_nm;
    -- Employee Details
    v_ctc_j.jb_ttl_dsc       := v_j.ocp_nm;
    v_ctc_j.empr_nme         := v_j.emp_nm;
    v_ctc_j.empr_adr_l1      := v_j.emp_a_ad1;
    v_ctc_j.empr_adr_l2      := v_j.emp_a_ad2;   
    v_ctc_j.empr_adr_cty     := v_j.emp_a_cty;
    IF v_j.pst_a_ctr_cd IS NOT NULL THEN
      v_ctc_j.empr_adr_ctr_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_j.emp_a_ctr_cd);
    END IF;
    IF v_j.pst_a_sta_cd IS NOT NULL THEN
      v_ctc_j.empr_adr_sta_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_j.emp_a_ctr_cd,
                                                           pi_id     => v_j.emp_a_sta_cd);
    END IF;
    --
    v_ctc_j.bus_phn          := v_j.emp_phn;
    v_ctc_j.hom_phn          := v_j.oth_phn;
    v_ctc_j.mbl_phn          := v_j.mbl_phn;
    v_ctc_j.pry_eml_adr      := v_j.pry_em_ad;
    v_ctc_j.alt_eml_adr      := v_j.sec_em_ad;
    -- Address Details
    v_ctc_j.pry_adr_l1       := v_j.pry_a_ad1;
    v_ctc_j.pry_adr_l2       := v_j.pry_a_ad2;
    v_ctc_j.pry_adr_cty      := v_j.pry_a_cty;
    v_ctc_j.pry_adr_zip      := v_j.pry_a_zip;
    v_ctc_j.pry_adr_sta_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_j.pry_a_ctr_cd,
                                                        pi_id     => v_j.pry_a_sta_cd);
    v_ctc_j.pry_adr_ctr_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_j.pry_a_ctr_cd);
    v_ctc_j.alt_adr_l1       := v_j.pst_a_ad1;
    v_ctc_j.alt_adr_l2       := v_j.pst_a_ad2;
    v_ctc_j.alt_adr_cty      := v_j.pst_a_cty;
    v_ctc_j.alt_adr_zip      := v_j.pst_a_zip;
    IF v_j.pst_a_ctr_cd IS NOT NULL THEN
      v_ctc_j.alt_adr_ctr_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_j.pst_a_ctr_cd);
    END IF;
    IF v_j.pst_a_sta_cd IS NOT NULL THEN
      v_ctc_j.alt_adr_sta_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_j.pst_a_ctr_cd,
                                                          pi_id     => v_j.pst_a_sta_cd);
    END IF;
    -- Bank Details
    v_ctc_j.pry_bnk_nme      := v_j.bk_nm;
    v_ctc_j.pry_bnk_srt_cd   := v_j.bk_st_cd;
    v_ctc_j.pry_bnk_acct_nbr := v_j.bk_ac_no;
    --v_ctc_j.pry_bnk_adr,
    v_ctc_j.bvn_id           := v_j.bk_bv_no;
    --
    -- Next of Kin (NOK)
    v_ctc_j.nok_ctc_nme      := v_j.nok_nm;
    IF v_j.nok_rln_cd IS NOT NULL THEN
      v_ctc_j.nok_rltn_cd_k    := pkwf_00_00.fn_get_rln_k(pi_id => v_j.nok_rln_cd);
    END IF;
    --v_ctc_j.nok_rltn_cd_dsc,
    v_ctc_j.nok_adr_l1       := v_j.nok_a_ad1;
    v_ctc_j.nok_adr_l2       := v_j.nok_a_ad2;
    v_ctc_j.nok_adr_cty      := v_j.nok_a_cty;
    v_ctc_j.nok_adr_zip      := v_j.nok_a_zip;
    IF v_j.nok_a_ctr_cd IS NOT NULL THEN
      v_ctc_j.nok_adr_ctr_k    := pkwf_00_00.fn_get_ctr_k(pi_id => v_j.nok_a_ctr_cd);
    END IF;
    IF v_j.nok_a_sta_cd IS NOT NULL THEN
     v_ctc_j.nok_adr_sta_k    := pkwf_00_00.fn_get_sta_k(pi_ctr_id => v_j.nok_a_ctr_cd,
                                                         pi_id     => v_j.nok_a_sta_cd);
    END IF;
    v_ctc_j.nok_pry_phn_nbr  := v_j.nok_phn;
    --
    --==========================================================================
    --
    DECLARE
      v_ctc_k   wf_00_00_dtd.n38%TYPE;
      v_ctc_j_k wf_00_00_dtd.n38%TYPE;
      v_cus_k   wf_00_00_dtd.n38%TYPE;
      v_k       wf_00_00_dtd.n38%TYPE;
    BEGIN
logger.log('STARTING CREATION PROCESS');      
      pkcs_90_wf.pr_prc_ctc_j@WF_SY(pi_rec     => v_ctc,
                                    pi_rec_j   => v_ctc_j,
                                    po_ctc_k   => v_ctc_k,
                                    po_ctc_j_k => v_ctc_j_k,
                                    po_cus_k   => v_cus_k);
      --
logger.log('CREATED NEW CUSTOMER ['||v_ctc.cus_id||']');      
      --
      -- Push images accross and process
      v_k := pkwf_00_00.fn_rk;
      INSERT
        INTO cs_90_wf_blb
            (row_key, dc_k, blb_ref, ctc_k, cus_k, tp_dm, wf_blb)
      SELECT
            v_k, row_key, 'x', v_ctc_k, v_cus_k, 'P', pic_img
        FROM wf_vi_30_cs_new
       WHERE row_key = v_r.row_key;
       INSERT INTO cs_90_wf_blb@wf_sy SELECT * FROM cs_90_wf_blb WHERE row_key = v_r.row_key;
      --
      v_k := pkwf_00_00.fn_rk;
      INSERT
        INTO cs_90_wf_blb
            (row_key, dc_k, blb_ref, ctc_k, cus_k, tp_dm, wf_blb)
      SELECT
            v_k, row_key, 'x', v_ctc_k, v_cus_k, 'S', sig_img
        FROM wf_vi_30_cs_new
       WHERE row_key = v_r.row_key;
       INSERT INTO cs_90_wf_blb@wf_sy SELECT * FROM cs_90_wf_blb WHERE row_key = v_r.row_key;
      --
logger.log('CSNEW 2 ['||v_ctc.cus_id||']');      
      v_k := pkwf_00_00.fn_rk;
      INSERT
        INTO cs_90_wf_blb
            (row_key, dc_k, blb_ref, ctc_k, cus_k, tp_dm, wf_blb)
      SELECT v_k, v_r.row_key, 'x', v_ctc_k, v_cus_k, 'D', dc_blb
        FROM wf_20_dc
       WHERE dc_id = v_r.dc_id;
       INSERT INTO cs_90_wf_blb@wf_sy SELECT * FROM cs_90_wf_blb WHERE row_key = v_r.row_key;
      --
logger.log('CSNEW 3 ['||v_ctc.cus_id||']');      
      pkcs_90_wf.pr_prc_img@WF_SY(pi_dc_k   => v_r.row_key,
                                  pi_dc_id  => v_r.dc_id,
                                  pi_cus_k  => v_cus_k,
                                  pi_doc_tp => 'CD001');  -- NEED A PARAMETER FOR THIS, DOCUMENT TYPE
      --
logger.log('IMAGES PROCESSED');      
      pkcs_90_wf.pr_prc_web@WF_SY(pi_cus_k => v_cus_k); -- Web mapping
      --      
logger.log('WEB ACCESS MAPPED');      
      --
      v_ptf.mkt_id     := 'NSE1';
      v_ptf.ptf_tp_id  := '10';    -- NEED A PARAMETER FOR THIS, PORTFOLIO TYPE
      v_ptf.cus_id     := v_ctc.cus_id;
      v_ptf.cus_nme    := v_ctc.org_nme;
      v_ptf.prd_id     := 'P10';   -- NEED A PARAMETER FOR THIS, PRODUCT
      v_ptf.mkt_act_id := v_r.mkt_act_id;
      v_ptf.mkt_chn_no := v_r.mkt_chn_no;
      --     
      pkst_90_wf.pr_cre_ptf@WF_SY(pi_rec => v_ptf);
      --
logger.log('PORTFOLIOS CREATED');      
    END;
    --
  EXCEPTION
    WHEN OTHERS THEN
      logger.log('ERROR SENDING NEW CUS - '||dbms_utility.format_error_backtrace);
      ROLLBACK;
      RAISE;
  END pr_prc_ctc_j;  
  --
  -- Register new client based on CSCS number
  PROCEDURE pr_prc_reg_2 (pi_rec IN OUT pkwf_90_gen.r_cs_reg2) IS
    --
    v_r     pkwf_90_gen.r_cs_reg2 := pi_rec;
    --
  BEGIN
    --
    pkcs_90_wf.pr_prc_web@WF_SY(pi_cus_id => v_r.cus_id); -- Web mapping
    --
    --
  END pr_prc_reg_2;  
  --
  --
END pkwf_89_cs; 
Error report -
Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\package-body\pkwf_89_st_body.sql
In command -
CREATE OR REPLACE PACKAGE BODY pkwf_89_st AS
  --
  /* Created By       : Femi Akintoye 
  ** Date Created     : 11-MAR-2016
  **
  ** PURPOSE: WF Routines for Preship Objects
  **
  ** MODIFICATION HISTORY:
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **  
  ** Copyright:  Neulogic Solutions Ltd, 2016
  **
  */
  --
  /* Private Routines */
  --
  --
  /* Public Routines */
  --
  -- Register new client based on CSCS number
  PROCEDURE pr_prc_reg (pi_rec IN OUT pkwf_90_gen.r_cs_reg) IS
    --
    v_r     pkwf_90_gen.r_cs_reg := pi_rec;
    v_map   pkst_90_wf.r_00_map@WF_SY;
  BEGIN
    --
    v_map.mkt_act_id := v_r.mk_ac_id;
    --
    pkst_90_wf.pr_cre_map@WF_SY(pi_rec => v_map);
    --
    --v_ctc.cus_id;
    --
  END pr_prc_reg;  
  --
  --
END pkwf_89_st; 
Error report -
Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\package-body\pkwf_90_alt_body.sql
In command -
CREATE OR REPLACE PACKAGE BODY pkwf_90_alt AS
  --
  /* Created By       : Femi Akintoye
  ** Date Created     : 22-OCT-2014
  ** Release Version  : 2.0
  **
  ** PURPOSE: Alerts Interface
  **
  ** MODIFICATION HISTORY:
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **
  */
  --
  /* Private Routines */
  --
  gv_pvm          pk99$$00_eml.r_pv;
  --
  --
  /* Public Routines */
  --
  PROCEDURE pr_crt_msg (pi_rec IN v_alt) IS
  BEGIN
    --
    gv_pvm  := NULL;
    --
    gv_pvm.pi_src_app := 'WF';  
    gv_pvm.pi_msg_id := pi_rec.pi_msg_id;
    gv_pvm.pi_rcpt_adr := pi_rec.pi_rcpt_adr;
    gv_pvm.pi_now_yn := '1';  
    --
    gv_pvm.pi_src_ref := pi_rec.pi_src_ref;
    gv_pvm.pi_src_key := pi_rec.pi_src_key;
    --
    gv_pvm.pi_sbj1  := pi_rec.pi_sbj1;
    gv_pvm.pi_sbj2  := pi_rec.pi_sbj2;
    gv_pvm.pi_sbj3  := pi_rec.pi_sbj3;
    gv_pvm.pi_bdy1  := pi_rec.pi_bdy1;
    gv_pvm.pi_bdy2  := pi_rec.pi_bdy2;
    gv_pvm.pi_bdy3  := pi_rec.pi_bdy3;
    gv_pvm.pi_bdy4  := pi_rec.pi_bdy4;
    gv_pvm.pi_bdy5  := pi_rec.pi_bdy5;
    gv_pvm.pi_bdy6  := pi_rec.pi_bdy6;
    gv_pvm.pi_bdy7  := pi_rec.pi_bdy7;
    gv_pvm.pi_bdy8  := pi_rec.pi_bdy8;
    gv_pvm.pi_bdy9  := pi_rec.pi_bdy9;
    gv_pvm.pi_bdy10 := pi_rec.pi_bdy10;
    gv_pvm.pi_bdy11 := pi_rec.pi_bdy11;
    gv_pvm.pi_bdy12 := pi_rec.pi_bdy12;
    gv_pvm.pi_bdy13 := pi_rec.pi_bdy13;
    gv_pvm.pi_bdy14 := pi_rec.pi_bdy14;
    gv_pvm.pi_bdy15 := pi_rec.pi_bdy15; 
    --    
    -- Generate Alert Message    
logger.log('ALERT-'||gv_pvm.pi_msg_id||'/'||gv_pvm.pi_rcpt_adr);
    pk99$$00_eml.pr_snd2 (pi_pv => gv_pvm);
    --
logger.log('ALERT RESULT='||gv_pvm.po_snt_yn||'/'||gv_pvm.po_err_txt);
    --    
  END pr_crt_msg;
  --  
  -- Format the Amount Input (Output Format: 999,999,999,999,990.99 trimming Leading Blanks if any)
  FUNCTION fn_fmt_qty (pi_qty NUMBER) RETURN VARCHAR2 IS
  BEGIN
   RETURN pkwf_00_dsp.fn_fmt_qty(pi_qty);
  END fn_fmt_qty;
  --  
  -- Format the Amount Input (Output Format: 999,999,999,999,990.99 trimming Leading Blanks if any)
  FUNCTION fn_fmt_amt (pi_amt NUMBER) RETURN VARCHAR2 IS
  BEGIN
   RETURN pkwf_00_dsp.fn_fmt_amt(pi_amt); --pk99$$00_alrt.fn_fmt_amt (pi_amt);
  END fn_fmt_amt;
  --
  -- Format the Rate Input (Output Format: 999,999.999999% to input decimal places (max 6), trimming Leading Blanks if any)
  FUNCTION fn_fmt_rt (pi_rt NUMBER, pi_dcml_pls PLS_INTEGER DEFAULT 2) RETURN VARCHAR2 IS
  BEGIN
    RETURN pkwf_00_dsp.fn_fmt_rt (pi_rt => pi_rt, pi_dcml_pls => pi_dcml_pls);
  END fn_fmt_rt;
  -- 
  -- Format the Amount Input (Output Format: Amount in words)
  FUNCTION fn_amt_in_word (pi_amt IN NUMBER, pi_cur_id IN VARCHAR2) RETURN VARCHAR2 IS
  BEGIN
    RETURN pk99$$00.fn_amt_in_word (pi_amt => pi_amt, pi_cur_id => pi_cur_id) ;
  END fn_amt_in_word;
  --
  FUNCTION fn_snd_alt(pi_ptf_tp_k IN NUMBER, pi_alt_id IN VARCHAR2) RETURN BOOLEAN RESULT_CACHE IS
    v_yn wf_00_00_dtd.c1%TYPE := 0;
  BEGIN
    --
--    BEGIN
--      SELECT snd_yn
--        INTO v_yn
--        FROM st_10_ptf_tps_alt
--       WHERE ptf_tp_k = pi_ptf_tp_k
--         AND alt_dm = pi_alt_id;
--    EXCEPTION
--      WHEN NO_DATA_FOUND THEN
--        logger.log_warning('ALERT [alt='||pi_alt_id||'] in [ptp='||pi_ptf_tp_k||'] not found');
--        v_yn := '0';
--    END;
    --
    IF v_yn = '1' THEN
      RETURN TRUE;
    ELSE
      RETURN FALSE;
    END IF;
    --
  END;
  --
  --
  FUNCTION fn_snd_alt_eml(pi_ptf_tp_k IN NUMBER, pi_alt_id IN VARCHAR2) RETURN VARCHAR2 RESULT_CACHE IS
    v_eml wf_00_00_dtd.C1000%TYPE;
  BEGIN
    --
--    BEGIN
--      SELECT dft_eml_adr
--        INTO v_eml
--        FROM st_10_ptf_tps_alt
--       WHERE ptf_tp_k = pi_ptf_tp_k
--         AND alt_dm = pi_alt_id;
--    EXCEPTION
--      WHEN NO_DATA_FOUND THEN
--        logger.log_warning('ALERT ADDR [alt='||pi_alt_id||'] in [ptp='||pi_ptf_tp_k||'] not found');
--        v_eml := NULL;
--    END;
    --
    RETURN v_eml;
    --
  END;
  --
END pkwf_90_alt;
Error report -
Closed Connection

Error starting at line : 1 File @ C:\Neulogic\private\WF\package-body\pkwf_90_gen_body.sql
In command -
CREATE OR REPLACE PACKAGE BODY pkwf_90_gen AS
  --
  /* Created By       : Femi Akintoye 
  ** Date Created     : 11-MAR-2016
  **
  ** PURPOSE: WF Routines for Preship Objects
  **
  ** MODIFICATION HISTORY:
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **
  **    Modified By   :
  **    Date          :
  **    Version       :
  **    Remarks       :
  **  
  ** Copyright:  Neulogic Solutions Ltd, 2016
  **
  */
  --
  /* Private Routines */
  --
  --
  /* Public Routines */
  --
  FUNCTION fn_01_cus_ins(pi_rec IN r_cs_new) RETURN r_ret IS
    v_ret   r_ret;
  BEGIN
    --
    v_ret := pkwf_30_cs_new.fn_ins(pi_rec => pi_rec);
    --
    RETURN v_ret;
    --
  END fn_01_cus_ins;
  --
  --
  FUNCTION fn_01_set_img(pi_dc_k IN NUMBER) RETURN r_ret IS
    v_ret   r_ret;
  BEGIN
    --
    v_ret := pkwf_30_cs_new.fn_set_img(pi_dc_k => pi_dc_k);
    --
    RETURN v_ret;
    --
  END fn_01_set_img;
  --
  --
  FUNCTION fn_02_reg_ins(pi_rec IN r_cs_reg) RETURN r_ret IS
    v_ret   r_ret;
  BEGIN
    --
    v_ret := pkwf_30_cs_reg.fn_ins(pi_rec => pi_rec);
    --
    RETURN v_ret;
    --
  END fn_02_reg_ins;
  --
  --
  FUNCTION fn_03_wdr_ins(pi_rec IN r_ch_wdr) RETURN r_ret IS
    v_ret   r_ret;
  BEGIN
    --
    v_ret := pkwf_30_ch_wdr.fn_ins(pi_rec => pi_rec);
    --
    RETURN v_ret;
    --
  END fn_03_wdr_ins;
  --
  --
END pkwf_90_gen; 
Error report -
Closed Connection


populating 99 tables
___________________________________________________________


Error starting at line : 87 File @ C:\Neulogic\private\99\install.sql
In command -
@./scripts/sysdata/load_data.sql
Error report -
Unable to open file: "./scripts/sysdata/load_data.sql"


creating 99 table triggers
___________________________________________________________


Error starting at line : 93 File @ C:\Neulogic\private\99\install.sql
In command -
@./scripts/install/create_99_triggers.sql
Error report -
Unable to open file: "./scripts/install/create_99_triggers.sql"


creating 99 Global Context
___________________________________________________________


Error starting at line : 99 File @ C:\Neulogic\private\99\install.sql
In command -
@./scripts/install/create_99_context.sql
Error report -
Unable to open file: "./scripts/install/create_99_context.sql"


recompiling invalid objects
___________________________________________________________


Error starting at line : 105 File @ C:\Neulogic\private\99\install.sql
In command -
@./scripts/install/recompile_objects.sql
Error report -
Unable to open file: "./scripts/install/recompile_objects.sql"


99 Objects Installed

Please read the Installation log file...

;-)
